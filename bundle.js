/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 31);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export $override */
/* unused harmony export clone */
/* harmony export (immutable) */ __webpack_exports__["p"] = merge;
/* unused harmony export mergeAll */
/* harmony export (immutable) */ __webpack_exports__["h"] = extend;
/* unused harmony export defaults */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return createCanvas; });
/* harmony export (immutable) */ __webpack_exports__["i"] = getContext;
/* harmony export (immutable) */ __webpack_exports__["k"] = indexOf;
/* harmony export (immutable) */ __webpack_exports__["a"] = inherits;
/* harmony export (immutable) */ __webpack_exports__["j"] = mixin;
/* harmony export (immutable) */ __webpack_exports__["m"] = isArrayLike;
/* harmony export (immutable) */ __webpack_exports__["b"] = each;
/* harmony export (immutable) */ __webpack_exports__["o"] = map;
/* unused harmony export reduce */
/* unused harmony export filter */
/* unused harmony export find */
/* harmony export (immutable) */ __webpack_exports__["n"] = bind;
/* unused harmony export curry */
/* unused harmony export isArray */
/* harmony export (immutable) */ __webpack_exports__["l"] = isFunction;
/* harmony export (immutable) */ __webpack_exports__["f"] = isString;
/* harmony export (immutable) */ __webpack_exports__["g"] = isObject;
/* unused harmony export isBuiltInObject */
/* unused harmony export isDom */
/* unused harmony export eqNaN */
/* unused harmony export retrieve */
/* harmony export (immutable) */ __webpack_exports__["e"] = retrieve2;
/* harmony export (immutable) */ __webpack_exports__["d"] = retrieve3;
/* unused harmony export slice */
/* harmony export (immutable) */ __webpack_exports__["c"] = normalizeCssArray;
/* unused harmony export assert */
/* unused harmony export setAsPrimitive */
/* unused harmony export isPrimitive */
/* unused harmony export createHashMap */
/* unused harmony export noop */
/**
 * @module zrender/core/util
 */

// 用于处理merge时无法遍历Date等对象的问题
var BUILTIN_OBJECT = {
    '[object Function]': 1,
    '[object RegExp]': 1,
    '[object Date]': 1,
    '[object Error]': 1,
    '[object CanvasGradient]': 1,
    '[object CanvasPattern]': 1,
    // For node-canvas
    '[object Image]': 1,
    '[object Canvas]': 1
};

var TYPED_ARRAY = {
    '[object Int8Array]': 1,
    '[object Uint8Array]': 1,
    '[object Uint8ClampedArray]': 1,
    '[object Int16Array]': 1,
    '[object Uint16Array]': 1,
    '[object Int32Array]': 1,
    '[object Uint32Array]': 1,
    '[object Float32Array]': 1,
    '[object Float64Array]': 1
};

var objToString = Object.prototype.toString;

var arrayProto = Array.prototype;
var nativeForEach = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var nativeReduce = arrayProto.reduce;

// Avoid assign to an exported variable, for transforming to cjs.
var methods = {};

function $override(name, fn) {
    methods[name] = fn;
}

/**
 * Those data types can be cloned:
 *     Plain object, Array, TypedArray, number, string, null, undefined.
 * Those data types will be assgined using the orginal data:
 *     BUILTIN_OBJECT
 * Instance of user defined class will be cloned to a plain object, without
 * properties in prototype.
 * Other data types is not supported (not sure what will happen).
 *
 * Caution: do not support clone Date, for performance consideration.
 * (There might be a large number of date in `series.data`).
 * So date should not be modified in and out of echarts.
 *
 * @param {*} source
 * @return {*} new
 */
function clone(source) {
    if (source == null || typeof source != 'object') {
        return source;
    }

    var result = source;
    var typeStr = objToString.call(source);

    if (typeStr === '[object Array]') {
        result = [];
        for (var i = 0, len = source.length; i < len; i++) {
            result[i] = clone(source[i]);
        }
    }
    else if (TYPED_ARRAY[typeStr]) {
        var Ctor = source.constructor;
        if (source.constructor.from) {
            result = Ctor.from(source);
        }
        else {
            result = new Ctor(source.length);
            for (var i = 0, len = source.length; i < len; i++) {
                result[i] = clone(source[i]);
            }
        }
    }
    else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
        result = {};
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                result[key] = clone(source[key]);
            }
        }
    }

    return result;
}

/**
 * @memberOf module:zrender/core/util
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overwrite=false]
 */
function merge(target, source, overwrite) {
    // We should escapse that source is string
    // and enter for ... in ...
    if (!isObject(source) || !isObject(target)) {
        return overwrite ? clone(source) : target;
    }

    for (var key in source) {
        if (source.hasOwnProperty(key)) {
            var targetProp = target[key];
            var sourceProp = source[key];

            if (isObject(sourceProp)
                && isObject(targetProp)
                && !isArray(sourceProp)
                && !isArray(targetProp)
                && !isDom(sourceProp)
                && !isDom(targetProp)
                && !isBuiltInObject(sourceProp)
                && !isBuiltInObject(targetProp)
                && !isPrimitive(sourceProp)
                && !isPrimitive(targetProp)
            ) {
                // 如果需要递归覆盖，就递归调用merge
                merge(targetProp, sourceProp, overwrite);
            }
            else if (overwrite || !(key in target)) {
                // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
                // NOTE，在 target[key] 不存在的时候也是直接覆盖
                target[key] = clone(source[key], true);
            }
        }
    }

    return target;
}

/**
 * @param {Array} targetAndSources The first item is target, and the rests are source.
 * @param {boolean} [overwrite=false]
 * @return {*} target
 */
function mergeAll(targetAndSources, overwrite) {
    var result = targetAndSources[0];
    for (var i = 1, len = targetAndSources.length; i < len; i++) {
        result = merge(result, targetAndSources[i], overwrite);
    }
    return result;
}

/**
 * @param {*} target
 * @param {*} source
 * @memberOf module:zrender/core/util
 */
function extend(target, source) {
    for (var key in source) {
        if (source.hasOwnProperty(key)) {
            target[key] = source[key];
        }
    }
    return target;
}

/**
 * @param {*} target
 * @param {*} source
 * @param {boolean} [overlay=false]
 * @memberOf module:zrender/core/util
 */
function defaults(target, source, overlay) {
    for (var key in source) {
        if (source.hasOwnProperty(key)
            && (overlay ? source[key] != null : target[key] == null)
        ) {
            target[key] = source[key];
        }
    }
    return target;
}

var createCanvas = function () {
    return methods.createCanvas();
};

methods.createCanvas = function () {
    return document.createElement('canvas');
};

// FIXME
var _ctx;

function getContext() {
    if (!_ctx) {
        // Use util.createCanvas instead of createCanvas
        // because createCanvas may be overwritten in different environment
        _ctx = createCanvas().getContext('2d');
    }
    return _ctx;
}

/**
 * 查询数组中元素的index
 * @memberOf module:zrender/core/util
 */
function indexOf(array, value) {
    if (array) {
        if (array.indexOf) {
            return array.indexOf(value);
        }
        for (var i = 0, len = array.length; i < len; i++) {
            if (array[i] === value) {
                return i;
            }
        }
    }
    return -1;
}

/**
 * 构造类继承关系
 *
 * @memberOf module:zrender/core/util
 * @param {Function} clazz 源类
 * @param {Function} baseClazz 基类
 */
function inherits(clazz, baseClazz) {
    var clazzPrototype = clazz.prototype;
    function F() {}
    F.prototype = baseClazz.prototype;
    clazz.prototype = new F();

    for (var prop in clazzPrototype) {
        clazz.prototype[prop] = clazzPrototype[prop];
    }
    clazz.prototype.constructor = clazz;
    clazz.superClass = baseClazz;
}

/**
 * @memberOf module:zrender/core/util
 * @param {Object|Function} target
 * @param {Object|Function} sorce
 * @param {boolean} overlay
 */
function mixin(target, source, overlay) {
    target = 'prototype' in target ? target.prototype : target;
    source = 'prototype' in source ? source.prototype : source;

    defaults(target, source, overlay);
}

/**
 * Consider typed array.
 * @param {Array|TypedArray} data
 */
function isArrayLike(data) {
    if (! data) {
        return;
    }
    if (typeof data == 'string') {
        return false;
    }
    return typeof data.length == 'number';
}

/**
 * 数组或对象遍历
 * @memberOf module:zrender/core/util
 * @param {Object|Array} obj
 * @param {Function} cb
 * @param {*} [context]
 */
function each(obj, cb, context) {
    if (!(obj && cb)) {
        return;
    }
    if (obj.forEach && obj.forEach === nativeForEach) {
        obj.forEach(cb, context);
    }
    else if (obj.length === +obj.length) {
        for (var i = 0, len = obj.length; i < len; i++) {
            cb.call(context, obj[i], i, obj);
        }
    }
    else {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                cb.call(context, obj[key], key, obj);
            }
        }
    }
}

/**
 * 数组映射
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */
function map(obj, cb, context) {
    if (!(obj && cb)) {
        return;
    }
    if (obj.map && obj.map === nativeMap) {
        return obj.map(cb, context);
    }
    else {
        var result = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            result.push(cb.call(context, obj[i], i, obj));
        }
        return result;
    }
}

/**
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {Object} [memo]
 * @param {*} [context]
 * @return {Array}
 */
function reduce(obj, cb, memo, context) {
    if (!(obj && cb)) {
        return;
    }
    if (obj.reduce && obj.reduce === nativeReduce) {
        return obj.reduce(cb, memo, context);
    }
    else {
        for (var i = 0, len = obj.length; i < len; i++) {
            memo = cb.call(context, memo, obj[i], i, obj);
        }
        return memo;
    }
}

/**
 * 数组过滤
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {Array}
 */
function filter(obj, cb, context) {
    if (!(obj && cb)) {
        return;
    }
    if (obj.filter && obj.filter === nativeFilter) {
        return obj.filter(cb, context);
    }
    else {
        var result = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            if (cb.call(context, obj[i], i, obj)) {
                result.push(obj[i]);
            }
        }
        return result;
    }
}

/**
 * 数组项查找
 * @memberOf module:zrender/core/util
 * @param {Array} obj
 * @param {Function} cb
 * @param {*} [context]
 * @return {*}
 */
function find(obj, cb, context) {
    if (!(obj && cb)) {
        return;
    }
    for (var i = 0, len = obj.length; i < len; i++) {
        if (cb.call(context, obj[i], i, obj)) {
            return obj[i];
        }
    }
}

/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @param {*} context
 * @return {Function}
 */
function bind(func, context) {
    var args = nativeSlice.call(arguments, 2);
    return function () {
        return func.apply(context, args.concat(nativeSlice.call(arguments)));
    };
}

/**
 * @memberOf module:zrender/core/util
 * @param {Function} func
 * @return {Function}
 */
function curry(func) {
    var args = nativeSlice.call(arguments, 1);
    return function () {
        return func.apply(this, args.concat(nativeSlice.call(arguments)));
    };
}

/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */
function isArray(value) {
    return objToString.call(value) === '[object Array]';
}

/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */
function isFunction(value) {
    return typeof value === 'function';
}

/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */
function isString(value) {
    return objToString.call(value) === '[object String]';
}

/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */
function isObject(value) {
    // Avoid a V8 JIT bug in Chrome 19-20.
    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = typeof value;
    return type === 'function' || (!!value && type == 'object');
}

/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */
function isBuiltInObject(value) {
    return !!BUILTIN_OBJECT[objToString.call(value)];
}

/**
 * @memberOf module:zrender/core/util
 * @param {*} value
 * @return {boolean}
 */
function isDom(value) {
    return typeof value === 'object'
        && typeof value.nodeType === 'number'
        && typeof value.ownerDocument === 'object';
}

/**
 * Whether is exactly NaN. Notice isNaN('a') returns true.
 * @param {*} value
 * @return {boolean}
 */
function eqNaN(value) {
    return value !== value;
}

/**
 * If value1 is not null, then return value1, otherwise judget rest of values.
 * Low performance.
 * @memberOf module:zrender/core/util
 * @return {*} Final value
 */
function retrieve(values) {
    for (var i = 0, len = arguments.length; i < len; i++) {
        if (arguments[i] != null) {
            return arguments[i];
        }
    }
}

function retrieve2(value0, value1) {
    return value0 != null
        ? value0
        : value1;
}

function retrieve3(value0, value1, value2) {
    return value0 != null
        ? value0
        : value1 != null
        ? value1
        : value2;
}

/**
 * @memberOf module:zrender/core/util
 * @param {Array} arr
 * @param {number} startIndex
 * @param {number} endIndex
 * @return {Array}
 */
function slice() {
    return Function.call.apply(nativeSlice, arguments);
}

/**
 * Normalize css liked array configuration
 * e.g.
 *  3 => [3, 3, 3, 3]
 *  [4, 2] => [4, 2, 4, 2]
 *  [4, 3, 2] => [4, 3, 2, 3]
 * @param {number|Array.<number>} val
 * @return {Array.<number>}
 */
function normalizeCssArray(val) {
    if (typeof (val) === 'number') {
        return [val, val, val, val];
    }
    var len = val.length;
    if (len === 2) {
        // vertical | horizontal
        return [val[0], val[1], val[0], val[1]];
    }
    else if (len === 3) {
        // top | horizontal | bottom
        return [val[0], val[1], val[2], val[1]];
    }
    return val;
}

/**
 * @memberOf module:zrender/core/util
 * @param {boolean} condition
 * @param {string} message
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(message);
    }
}

var primitiveKey = '__ec_primitive__';
/**
 * Set an object as primitive to be ignored traversing children in clone or merge
 */
function setAsPrimitive(obj) {
    obj[primitiveKey] = true;
}

function isPrimitive(obj) {
    return obj[primitiveKey];
}

/**
 * @constructor
 * @param {Object} obj Only apply `ownProperty`.
 */
function HashMap(obj) {
    obj && each(obj, function (value, key) {
        this.set(key, value);
    }, this);
}

// Add prefix to avoid conflict with Object.prototype.
var HASH_MAP_PREFIX = '_ec_';
var HASH_MAP_PREFIX_LENGTH = 4;

HashMap.prototype = {
    constructor: HashMap,
    // Do not provide `has` method to avoid defining what is `has`.
    // (We usually treat `null` and `undefined` as the same, different
    // from ES6 Map).
    get: function (key) {
        return this[HASH_MAP_PREFIX + key];
    },
    set: function (key, value) {
        this[HASH_MAP_PREFIX + key] = value;
        // Comparing with invocation chaining, `return value` is more commonly
        // used in this case: `var someVal = map.set('a', genVal());`
        return value;
    },
    // Although util.each can be performed on this hashMap directly, user
    // should not use the exposed keys, who are prefixed.
    each: function (cb, context) {
        context !== void 0 && (cb = bind(cb, context));
        for (var prefixedKey in this) {
            this.hasOwnProperty(prefixedKey)
                && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));
        }
    },
    // Do not use this method if performance sensitive.
    removeKey: function (key) {
        delete this[HASH_MAP_PREFIX + key];
    }
};

function createHashMap(obj) {
    return new HashMap(obj);
}

function noop() {}


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__matrix__ = __webpack_require__(21);
/**
 * @module echarts/core/BoundingRect
 */




var v2ApplyTransform = __WEBPACK_IMPORTED_MODULE_0__vector__["a" /* applyTransform */];
var mathMin = Math.min;
var mathMax = Math.max;

/**
 * @alias module:echarts/core/BoundingRect
 */
function BoundingRect(x, y, width, height) {

    if (width < 0) {
        x = x + width;
        width = -width;
    }
    if (height < 0) {
        y = y + height;
        height = -height;
    }

    /**
     * @type {number}
     */
    this.x = x;
    /**
     * @type {number}
     */
    this.y = y;
    /**
     * @type {number}
     */
    this.width = width;
    /**
     * @type {number}
     */
    this.height = height;
}

BoundingRect.prototype = {

    constructor: BoundingRect,

    /**
     * @param {module:echarts/core/BoundingRect} other
     */
    union: function (other) {
        var x = mathMin(other.x, this.x);
        var y = mathMin(other.y, this.y);

        this.width = mathMax(
                other.x + other.width,
                this.x + this.width
            ) - x;
        this.height = mathMax(
                other.y + other.height,
                this.y + this.height
            ) - y;
        this.x = x;
        this.y = y;
    },

    /**
     * @param {Array.<number>} m
     * @methods
     */
    applyTransform: (function () {
        var lt = [];
        var rb = [];
        var lb = [];
        var rt = [];
        return function (m) {
            // In case usage like this
            // el.getBoundingRect().applyTransform(el.transform)
            // And element has no transform
            if (!m) {
                return;
            }
            lt[0] = lb[0] = this.x;
            lt[1] = rt[1] = this.y;
            rb[0] = rt[0] = this.x + this.width;
            rb[1] = lb[1] = this.y + this.height;

            v2ApplyTransform(lt, lt, m);
            v2ApplyTransform(rb, rb, m);
            v2ApplyTransform(lb, lb, m);
            v2ApplyTransform(rt, rt, m);

            this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
            this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
            var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
            var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
            this.width = maxX - this.x;
            this.height = maxY - this.y;
        };
    })(),

    /**
     * Calculate matrix of transforming from self to target rect
     * @param  {module:zrender/core/BoundingRect} b
     * @return {Array.<number>}
     */
    calculateTransform: function (b) {
        var a = this;
        var sx = b.width / a.width;
        var sy = b.height / a.height;

        var m = __WEBPACK_IMPORTED_MODULE_1__matrix__["a" /* create */]();

        // 矩阵右乘
        __WEBPACK_IMPORTED_MODULE_1__matrix__["b" /* translate */](m, m, [-a.x, -a.y]);
        __WEBPACK_IMPORTED_MODULE_1__matrix__["c" /* scale */](m, m, [sx, sy]);
        __WEBPACK_IMPORTED_MODULE_1__matrix__["b" /* translate */](m, m, [b.x, b.y]);

        return m;
    },

    /**
     * @param {(module:echarts/core/BoundingRect|Object)} b
     * @return {boolean}
     */
    intersect: function (b) {
        if (!b) {
            return false;
        }

        if (!(b instanceof BoundingRect)) {
            // Normalize negative width/height.
            b = BoundingRect.create(b);
        }

        var a = this;
        var ax0 = a.x;
        var ax1 = a.x + a.width;
        var ay0 = a.y;
        var ay1 = a.y + a.height;

        var bx0 = b.x;
        var bx1 = b.x + b.width;
        var by0 = b.y;
        var by1 = b.y + b.height;

        return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
    },

    contain: function (x, y) {
        var rect = this;
        return x >= rect.x
            && x <= (rect.x + rect.width)
            && y >= rect.y
            && y <= (rect.y + rect.height);
    },

    /**
     * @return {module:echarts/core/BoundingRect}
     */
    clone: function () {
        return new BoundingRect(this.x, this.y, this.width, this.height);
    },

    /**
     * Copy from another rect
     */
    copy: function (other) {
        this.x = other.x;
        this.y = other.y;
        this.width = other.width;
        this.height = other.height;
    },

    plain: function () {
        return {
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height
        };
    }
};

/**
 * @param {Object|module:zrender/core/BoundingRect} rect
 * @param {number} rect.x
 * @param {number} rect.y
 * @param {number} rect.width
 * @param {number} rect.height
 * @return {module:zrender/core/BoundingRect}
 */
BoundingRect.create = function (rect) {
    return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
};

/* harmony default export */ __webpack_exports__["a"] = (BoundingRect);

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = create;
/* unused harmony export copy */
/* unused harmony export clone */
/* unused harmony export set */
/* unused harmony export add */
/* unused harmony export scaleAndAdd */
/* unused harmony export sub */
/* unused harmony export len */
/* unused harmony export length */
/* unused harmony export lenSquare */
/* unused harmony export lengthSquare */
/* unused harmony export mul */
/* unused harmony export div */
/* unused harmony export dot */
/* unused harmony export scale */
/* unused harmony export normalize */
/* unused harmony export distance */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return dist; });
/* unused harmony export distanceSquare */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return distSquare; });
/* unused harmony export negate */
/* unused harmony export lerp */
/* harmony export (immutable) */ __webpack_exports__["a"] = applyTransform;
/* harmony export (immutable) */ __webpack_exports__["d"] = min;
/* harmony export (immutable) */ __webpack_exports__["e"] = max;

var ArrayCtor = typeof Float32Array === 'undefined'
    ? Array
    : Float32Array;

/**
 * 创建一个向量
 * @param {number} [x=0]
 * @param {number} [y=0]
 * @return {Vector2}
 */
function create(x, y) {
    var out = new ArrayCtor(2);
    if (x == null) {
        x = 0;
    }
    if (y == null) {
        y = 0;
    }
    out[0] = x;
    out[1] = y;
    return out;
}

/**
 * 复制向量数据
 * @param {Vector2} out
 * @param {Vector2} v
 * @return {Vector2}
 */
function copy(out, v) {
    out[0] = v[0];
    out[1] = v[1];
    return out;
}

/**
 * 克隆一个向量
 * @param {Vector2} v
 * @return {Vector2}
 */
function clone(v) {
    var out = new ArrayCtor(2);
    out[0] = v[0];
    out[1] = v[1];
    return out;
}

/**
 * 设置向量的两个项
 * @param {Vector2} out
 * @param {number} a
 * @param {number} b
 * @return {Vector2} 结果
 */
function set(out, a, b) {
    out[0] = a;
    out[1] = b;
    return out;
}

/**
 * 向量相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */
function add(out, v1, v2) {
    out[0] = v1[0] + v2[0];
    out[1] = v1[1] + v2[1];
    return out;
}

/**
 * 向量缩放后相加
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} a
 */
function scaleAndAdd(out, v1, v2, a) {
    out[0] = v1[0] + v2[0] * a;
    out[1] = v1[1] + v2[1] * a;
    return out;
}

/**
 * 向量相减
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */
function sub(out, v1, v2) {
    out[0] = v1[0] - v2[0];
    out[1] = v1[1] - v2[1];
    return out;
}

/**
 * 向量长度
 * @param {Vector2} v
 * @return {number}
 */
function len(v) {
    return Math.sqrt(lenSquare(v));
}
var length = len; // jshint ignore:line

/**
 * 向量长度平方
 * @param {Vector2} v
 * @return {number}
 */
function lenSquare(v) {
    return v[0] * v[0] + v[1] * v[1];
}
var lengthSquare = lenSquare;

/**
 * 向量乘法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */
function mul(out, v1, v2) {
    out[0] = v1[0] * v2[0];
    out[1] = v1[1] * v2[1];
    return out;
}

/**
 * 向量除法
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 */
function div(out, v1, v2) {
    out[0] = v1[0] / v2[0];
    out[1] = v1[1] / v2[1];
    return out;
}

/**
 * 向量点乘
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */
function dot(v1, v2) {
    return v1[0] * v2[0] + v1[1] * v2[1];
}

/**
 * 向量缩放
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {number} s
 */
function scale(out, v, s) {
    out[0] = v[0] * s;
    out[1] = v[1] * s;
    return out;
}

/**
 * 向量归一化
 * @param {Vector2} out
 * @param {Vector2} v
 */
function normalize(out, v) {
    var d = len(v);
    if (d === 0) {
        out[0] = 0;
        out[1] = 0;
    }
    else {
        out[0] = v[0] / d;
        out[1] = v[1] / d;
    }
    return out;
}

/**
 * 计算向量间距离
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */
function distance(v1, v2) {
    return Math.sqrt(
        (v1[0] - v2[0]) * (v1[0] - v2[0])
        + (v1[1] - v2[1]) * (v1[1] - v2[1])
    );
}
var dist = distance;

/**
 * 向量距离平方
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @return {number}
 */
function distanceSquare(v1, v2) {
    return (v1[0] - v2[0]) * (v1[0] - v2[0])
        + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}
var distSquare = distanceSquare;

/**
 * 求负向量
 * @param {Vector2} out
 * @param {Vector2} v
 */
function negate(out, v) {
    out[0] = -v[0];
    out[1] = -v[1];
    return out;
}

/**
 * 插值两个点
 * @param {Vector2} out
 * @param {Vector2} v1
 * @param {Vector2} v2
 * @param {number} t
 */
function lerp(out, v1, v2, t) {
    out[0] = v1[0] + t * (v2[0] - v1[0]);
    out[1] = v1[1] + t * (v2[1] - v1[1]);
    return out;
}

/**
 * 矩阵左乘向量
 * @param {Vector2} out
 * @param {Vector2} v
 * @param {Vector2} m
 */
function applyTransform(out, v, m) {
    var x = v[0];
    var y = v[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
}

/**
 * 求两个向量最小值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */
function min(out, v1, v2) {
    out[0] = Math.min(v1[0], v2[0]);
    out[1] = Math.min(v1[1], v2[1]);
    return out;
}

/**
 * 求两个向量最大值
 * @param  {Vector2} out
 * @param  {Vector2} v1
 * @param  {Vector2} v2
 */
function max(out, v1, v2) {
    out[0] = Math.max(v1[0], v2[0]);
    out[1] = Math.max(v1[1], v2[1]);
    return out;
}


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = cubicAt;
/* unused harmony export cubicDerivativeAt */
/* harmony export (immutable) */ __webpack_exports__["a"] = cubicRootAt;
/* harmony export (immutable) */ __webpack_exports__["c"] = cubicExtrema;
/* unused harmony export cubicSubdivide */
/* harmony export (immutable) */ __webpack_exports__["h"] = cubicProjectPoint;
/* harmony export (immutable) */ __webpack_exports__["f"] = quadraticAt;
/* unused harmony export quadraticDerivativeAt */
/* harmony export (immutable) */ __webpack_exports__["d"] = quadraticRootAt;
/* harmony export (immutable) */ __webpack_exports__["e"] = quadraticExtremum;
/* unused harmony export quadraticSubdivide */
/* harmony export (immutable) */ __webpack_exports__["g"] = quadraticProjectPoint;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector__ = __webpack_require__(2);
/**
 * 曲线辅助模块
 * @module zrender/core/curve
 * @author pissang(https://www.github.com/pissang)
 */



var mathPow = Math.pow;
var mathSqrt = Math.sqrt;

var EPSILON = 1e-8;
var EPSILON_NUMERIC = 1e-4;

var THREE_SQRT = mathSqrt(3);
var ONE_THIRD = 1 / 3;

// 临时变量
var _v0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__vector__["b" /* create */])();
var _v1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__vector__["b" /* create */])();
var _v2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__vector__["b" /* create */])();

function isAroundZero(val) {
    return val > -EPSILON && val < EPSILON;
}
function isNotAroundZero(val) {
    return val > EPSILON || val < -EPSILON;
}
/**
 * 计算三次贝塞尔值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */
function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return onet * onet * (onet * p0 + 3 * t * p1)
            + t * t * (t * p3 + 3 * onet * p2);
}

/**
 * 计算三次贝塞尔导数值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @return {number}
 */
function cubicDerivativeAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return 3 * (
        ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet
        + (p3 - p2) * t * t
    );
}

/**
 * 计算三次贝塞尔方程根，使用盛金公式
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} val
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */
function cubicRootAt(p0, p1, p2, p3, val, roots) {
    // Evaluate roots of cubic functions
    var a = p3 + 3 * (p1 - p2) - p0;
    var b = 3 * (p2 - p1 * 2 + p0);
    var c = 3 * (p1  - p0);
    var d = p0 - val;

    var A = b * b - 3 * a * c;
    var B = b * c - 9 * a * d;
    var C = c * c - 3 * b * d;

    var n = 0;

    if (isAroundZero(A) && isAroundZero(B)) {
        if (isAroundZero(b)) {
            roots[0] = 0;
        }
        else {
            var t1 = -c / b;  //t1, t2, t3, b is not zero
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
    }
    else {
        var disc = B * B - 4 * A * C;

        if (isAroundZero(disc)) {
            var K = B / A;
            var t1 = -b / a + K;  // t1, a is not zero
            var t2 = -K / 2;  // t2, t3
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                roots[n++] = t2;
            }
        }
        else if (disc > 0) {
            var discSqrt = mathSqrt(disc);
            var Y1 = A * b + 1.5 * a * (-B + discSqrt);
            var Y2 = A * b + 1.5 * a * (-B - discSqrt);
            if (Y1 < 0) {
                Y1 = -mathPow(-Y1, ONE_THIRD);
            }
            else {
                Y1 = mathPow(Y1, ONE_THIRD);
            }
            if (Y2 < 0) {
                Y2 = -mathPow(-Y2, ONE_THIRD);
            }
            else {
                Y2 = mathPow(Y2, ONE_THIRD);
            }
            var t1 = (-b - (Y1 + Y2)) / (3 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
        else {
            var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
            var theta = Math.acos(T) / 3;
            var ASqrt = mathSqrt(A);
            var tmp = Math.cos(theta);

            var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
            var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
            var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                roots[n++] = t2;
            }
            if (t3 >= 0 && t3 <= 1) {
                roots[n++] = t3;
            }
        }
    }
    return n;
}

/**
 * 计算三次贝塞尔方程极限值的位置
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {Array.<number>} extrema
 * @return {number} 有效数目
 */
function cubicExtrema(p0, p1, p2, p3, extrema) {
    var b = 6 * p2 - 12 * p1 + 6 * p0;
    var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
    var c = 3 * p1 - 3 * p0;

    var n = 0;
    if (isAroundZero(a)) {
        if (isNotAroundZero(b)) {
            var t1 = -c / b;
            if (t1 >= 0 && t1 <=1) {
                extrema[n++] = t1;
            }
        }
    }
    else {
        var disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) {
            extrema[0] = -b / (2 * a);
        }
        else if (disc > 0) {
            var discSqrt = mathSqrt(disc);
            var t1 = (-b + discSqrt) / (2 * a);
            var t2 = (-b - discSqrt) / (2 * a);
            if (t1 >= 0 && t1 <= 1) {
                extrema[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                extrema[n++] = t2;
            }
        }
    }
    return n;
}

/**
 * 细分三次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {Array.<number>} out
 */
function cubicSubdivide(p0, p1, p2, p3, t, out) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p23 = (p3 - p2) * t + p2;

    var p012 = (p12 - p01) * t + p01;
    var p123 = (p23 - p12) * t + p12;

    var p0123 = (p123 - p012) * t + p012;
    // Seg0
    out[0] = p0;
    out[1] = p01;
    out[2] = p012;
    out[3] = p0123;
    // Seg1
    out[4] = p0123;
    out[5] = p123;
    out[6] = p23;
    out[7] = p3;
}

/**
 * 投射点到三次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} [out] 投射点
 * @return {number}
 */
function cubicProjectPoint(
    x0, y0, x1, y1, x2, y2, x3, y3,
    x, y, out
) {
    // http://pomax.github.io/bezierinfo/#projections
    var t;
    var interval = 0.005;
    var d = Infinity;
    var prev;
    var next;
    var d1;
    var d2;

    _v0[0] = x;
    _v0[1] = y;

    // 先粗略估计一下可能的最小距离的 t 值
    // PENDING
    for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = cubicAt(x0, x1, x2, x3, _t);
        _v1[1] = cubicAt(y0, y1, y2, y3, _t);
        d1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__vector__["c" /* distSquare */])(_v0, _v1);
        if (d1 < d) {
            t = _t;
            d = d1;
        }
    }
    d = Infinity;

    // At most 32 iteration
    for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
            break;
        }
        prev = t - interval;
        next = t + interval;
        // t - interval
        _v1[0] = cubicAt(x0, x1, x2, x3, prev);
        _v1[1] = cubicAt(y0, y1, y2, y3, prev);

        d1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__vector__["c" /* distSquare */])(_v1, _v0);

        if (prev >= 0 && d1 < d) {
            t = prev;
            d = d1;
        }
        else {
            // t + interval
            _v2[0] = cubicAt(x0, x1, x2, x3, next);
            _v2[1] = cubicAt(y0, y1, y2, y3, next);
            d2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__vector__["c" /* distSquare */])(_v2, _v0);

            if (next <= 1 && d2 < d) {
                t = next;
                d = d2;
            }
            else {
                interval *= 0.5;
            }
        }
    }
    // t
    if (out) {
        out[0] = cubicAt(x0, x1, x2, x3, t);
        out[1] = cubicAt(y0, y1, y2, y3, t);
    }
    // console.log(interval, i);
    return mathSqrt(d);
}

/**
 * 计算二次方贝塞尔值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */
function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}

/**
 * 计算二次方贝塞尔导数值
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @return {number}
 */
function quadraticDerivativeAt(p0, p1, p2, t) {
    return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
}

/**
 * 计算二次方贝塞尔方程根
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} roots
 * @return {number} 有效根数目
 */
function quadraticRootAt(p0, p1, p2, val, roots) {
    var a = p0 - 2 * p1 + p2;
    var b = 2 * (p1 - p0);
    var c = p0 - val;

    var n = 0;
    if (isAroundZero(a)) {
        if (isNotAroundZero(b)) {
            var t1 = -c / b;
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
    }
    else {
        var disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) {
            var t1 = -b / (2 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
        else if (disc > 0) {
            var discSqrt = mathSqrt(disc);
            var t1 = (-b + discSqrt) / (2 * a);
            var t2 = (-b - discSqrt) / (2 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                roots[n++] = t2;
            }
        }
    }
    return n;
}

/**
 * 计算二次贝塞尔方程极限值
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @return {number}
 */
function quadraticExtremum(p0, p1, p2) {
    var divider = p0 + p2 - 2 * p1;
    if (divider === 0) {
        // p1 is center of p0 and p2
        return 0.5;
    }
    else {
        return (p0 - p1) / divider;
    }
}

/**
 * 细分二次贝塞尔曲线
 * @memberOf module:zrender/core/curve
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} t
 * @param  {Array.<number>} out
 */
function quadraticSubdivide(p0, p1, p2, t, out) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p012 = (p12 - p01) * t + p01;

    // Seg0
    out[0] = p0;
    out[1] = p01;
    out[2] = p012;

    // Seg1
    out[3] = p012;
    out[4] = p12;
    out[5] = p2;
}

/**
 * 投射点到二次贝塞尔曲线上，返回投射距离。
 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x
 * @param {number} y
 * @param {Array.<number>} out 投射点
 * @return {number}
 */
function quadraticProjectPoint(
    x0, y0, x1, y1, x2, y2,
    x, y, out
) {
    // http://pomax.github.io/bezierinfo/#projections
    var t;
    var interval = 0.005;
    var d = Infinity;

    _v0[0] = x;
    _v0[1] = y;

    // 先粗略估计一下可能的最小距离的 t 值
    // PENDING
    for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = quadraticAt(x0, x1, x2, _t);
        _v1[1] = quadraticAt(y0, y1, y2, _t);
        var d1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__vector__["c" /* distSquare */])(_v0, _v1);
        if (d1 < d) {
            t = _t;
            d = d1;
        }
    }
    d = Infinity;

    // At most 32 iteration
    for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
            break;
        }
        var prev = t - interval;
        var next = t + interval;
        // t - interval
        _v1[0] = quadraticAt(x0, x1, x2, prev);
        _v1[1] = quadraticAt(y0, y1, y2, prev);

        var d1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__vector__["c" /* distSquare */])(_v1, _v0);

        if (prev >= 0 && d1 < d) {
            t = prev;
            d = d1;
        }
        else {
            // t + interval
            _v2[0] = quadraticAt(x0, x1, x2, next);
            _v2[1] = quadraticAt(y0, y1, y2, next);
            var d2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__vector__["c" /* distSquare */])(_v2, _v0);
            if (next <= 1 && d2 < d) {
                t = next;
                d = d2;
            }
            else {
                interval *= 0.5;
            }
        }
    }
    // t
    if (out) {
        out[0] = quadraticAt(x0, x1, x2, t);
        out[1] = quadraticAt(y0, y1, y2, t);
    }
    // console.log(interval, i);
    return mathSqrt(d);
}


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return debugMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return devicePixelRatio; });
var dpr = 1;

// If in browser environment
if (typeof window !== 'undefined') {
    dpr = Math.max(window.devicePixelRatio || 1, 1);
}

/**
 * config默认配置项
 * @exports zrender/config
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 */

/**
 * debug日志选项：catchBrushException为true下有效
 * 0 : 不生成debug数据，发布用
 * 1 : 异常抛出，调试用
 * 2 : 控制台输出，调试用
 */
var debugMode = 0;

// retina 屏幕优化
var devicePixelRatio = dpr;


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * echarts设备环境识别
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author firede[firede@firede.us]
 * @desc thanks zepto.
 */

var env = {};

if (typeof navigator === 'undefined') {
    // In node
    env = {
        browser: {},
        os: {},
        node: true,
        // Assume canvas is supported
        canvasSupported: true,
        svgSupported: true
    };
}
else {
    env = detect(navigator.userAgent);
}

/* harmony default export */ __webpack_exports__["a"] = (env);

// Zepto.js
// (c) 2010-2013 Thomas Fuchs
// Zepto.js may be freely distributed under the MIT license.

function detect(ua) {
    var os = {};
    var browser = {};
    // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
    // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
    // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
    // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
    // var touchpad = webos && ua.match(/TouchPad/);
    // var kindle = ua.match(/Kindle\/([\d.]+)/);
    // var silk = ua.match(/Silk\/([\d._]+)/);
    // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
    // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
    // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
    // var playbook = ua.match(/PlayBook/);
    // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
    var firefox = ua.match(/Firefox\/([\d.]+)/);
    // var safari = webkit && ua.match(/Mobile\//) && !chrome;
    // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
    var ie = ua.match(/MSIE\s([\d.]+)/)
        // IE 11 Trident/7.0; rv:11.0
        || ua.match(/Trident\/.+?rv:(([\d.]+))/);
    var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+

    var weChat = (/micromessenger/i).test(ua);

    // Todo: clean this up with a better OS/browser seperation:
    // - discern (more) between multiple browsers on android
    // - decide if kindle fire in silk mode is android or not
    // - Firefox on Android doesn't specify the Android version
    // - possibly devide in os, device and browser hashes

    // if (browser.webkit = !!webkit) browser.version = webkit[1];

    // if (android) os.android = true, os.version = android[2];
    // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
    // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
    // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
    // if (webos) os.webos = true, os.version = webos[2];
    // if (touchpad) os.touchpad = true;
    // if (blackberry) os.blackberry = true, os.version = blackberry[2];
    // if (bb10) os.bb10 = true, os.version = bb10[2];
    // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
    // if (playbook) browser.playbook = true;
    // if (kindle) os.kindle = true, os.version = kindle[1];
    // if (silk) browser.silk = true, browser.version = silk[1];
    // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
    // if (chrome) browser.chrome = true, browser.version = chrome[1];
    if (firefox) {
        browser.firefox = true;
        browser.version = firefox[1];
    }
    // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
    // if (webview) browser.webview = true;

    if (ie) {
        browser.ie = true;
        browser.version = ie[1];
    }

    if (edge) {
        browser.edge = true;
        browser.version = edge[1];
    }

    // It is difficult to detect WeChat in Win Phone precisely, because ua can
    // not be set on win phone. So we do not consider Win Phone.
    if (weChat) {
        browser.weChat = true;
    }

    // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
    //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
    // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
    //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
    //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));

    return {
        browser: browser,
        os: os,
        node: false,
        // 原生canvas支持，改极端点了
        // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
        canvasSupported: !!document.createElement('canvas').getContext,
        svgSupported: typeof SVGRect !== 'undefined',
        // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
        // works on most browsers
        // IE10/11 does not support touch event, and MS Edge supports them but not by
        // default, so we dont check navigator.maxTouchPoints for them here.
        touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
        // <http://caniuse.com/#search=pointer%20event>.
        pointerEventsSupported: 'onpointerdown' in window
            // Firefox supports pointer but not by default, only MS browsers are reliable on pointer
            // events currently. So we dont use that on other browsers unless tested sufficiently.
            // Although IE 10 supports pointer event, it use old style and is different from the
            // standard. So we exclude that. (IE 10 is hardly used on touch device)
            && (browser.edge || (browser.ie && browser.version >= 11))
    };
}

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * 事件扩展
 * @module zrender/mixin/Eventful
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         pissang (https://www.github.com/pissang)
 */

var arrySlice = Array.prototype.slice;

/**
 * 事件分发器
 * @alias module:zrender/mixin/Eventful
 * @constructor
 */
var Eventful = function () {
    this._$handlers = {};
};

Eventful.prototype = {

    constructor: Eventful,

    /**
     * 单次触发绑定，trigger后销毁
     *
     * @param {string} event 事件名
     * @param {Function} handler 响应函数
     * @param {Object} context
     */
    one: function (event, handler, context) {
        var _h = this._$handlers;

        if (!handler || !event) {
            return this;
        }

        if (!_h[event]) {
            _h[event] = [];
        }

        for (var i = 0; i < _h[event].length; i++) {
            if (_h[event][i].h === handler) {
                return this;
            }
        }

        _h[event].push({
            h: handler,
            one: true,
            ctx: context || this
        });

        return this;
    },

    /**
     * 绑定事件
     * @param {string} event 事件名
     * @param {Function} handler 事件处理函数
     * @param {Object} [context]
     */
    on: function (event, handler, context) {
        var _h = this._$handlers;

        if (!handler || !event) {
            return this;
        }

        if (!_h[event]) {
            _h[event] = [];
        }

        for (var i = 0; i < _h[event].length; i++) {
            if (_h[event][i].h === handler) {
                return this;
            }
        }

        _h[event].push({
            h: handler,
            one: false,
            ctx: context || this
        });

        return this;
    },

    /**
     * 是否绑定了事件
     * @param  {string}  event
     * @return {boolean}
     */
    isSilent: function (event) {
        var _h = this._$handlers;
        return _h[event] && _h[event].length;
    },

    /**
     * 解绑事件
     * @param {string} event 事件名
     * @param {Function} [handler] 事件处理函数
     */
    off: function (event, handler) {
        var _h = this._$handlers;

        if (!event) {
            this._$handlers = {};
            return this;
        }

        if (handler) {
            if (_h[event]) {
                var newList = [];
                for (var i = 0, l = _h[event].length; i < l; i++) {
                    if (_h[event][i]['h'] != handler) {
                        newList.push(_h[event][i]);
                    }
                }
                _h[event] = newList;
            }

            if (_h[event] && _h[event].length === 0) {
                delete _h[event];
            }
        }
        else {
            delete _h[event];
        }

        return this;
    },

    /**
     * 事件分发
     *
     * @param {string} type 事件类型
     */
    trigger: function (type) {
        if (this._$handlers[type]) {
            var args = arguments;
            var argLen = args.length;

            if (argLen > 3) {
                args = arrySlice.call(args, 1);
            }

            var _h = this._$handlers[type];
            var len = _h.length;
            for (var i = 0; i < len;) {
                // Optimize advise from backbone
                switch (argLen) {
                    case 1:
                        _h[i]['h'].call(_h[i]['ctx']);
                        break;
                    case 2:
                        _h[i]['h'].call(_h[i]['ctx'], args[1]);
                        break;
                    case 3:
                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
                        break;
                    default:
                        // have more than 2 given arguments
                        _h[i]['h'].apply(_h[i]['ctx'], args);
                        break;
                }

                if (_h[i]['one']) {
                    _h.splice(i, 1);
                    len--;
                }
                else {
                    i++;
                }
            }
        }

        return this;
    },

    /**
     * 带有context的事件分发, 最后一个参数是事件回调的context
     * @param {string} type 事件类型
     */
    triggerWithContext: function (type) {
        if (this._$handlers[type]) {
            var args = arguments;
            var argLen = args.length;

            if (argLen > 4) {
                args = arrySlice.call(args, 1, args.length - 1);
            }
            var ctx = args[args.length - 1];

            var _h = this._$handlers[type];
            var len = _h.length;
            for (var i = 0; i < len;) {
                // Optimize advise from backbone
                switch (argLen) {
                    case 1:
                        _h[i]['h'].call(ctx);
                        break;
                    case 2:
                        _h[i]['h'].call(ctx, args[1]);
                        break;
                    case 3:
                        _h[i]['h'].call(ctx, args[1], args[2]);
                        break;
                    default:
                        // have more than 2 given arguments
                        _h[i]['h'].apply(ctx, args);
                        break;
                }

                if (_h[i]['one']) {
                    _h.splice(i, 1);
                    len--;
                }
                else {
                    i++;
                }
            }
        }

        return this;
    }
};

// 对象可以通过 onxxxx 绑定事件
/**
 * @event module:zrender/mixin/Eventful#onclick
 * @type {Function}
 * @default null
 */
/**
 * @event module:zrender/mixin/Eventful#onmouseover
 * @type {Function}
 * @default null
 */
/**
 * @event module:zrender/mixin/Eventful#onmouseout
 * @type {Function}
 * @default null
 */
/**
 * @event module:zrender/mixin/Eventful#onmousemove
 * @type {Function}
 * @default null
 */
/**
 * @event module:zrender/mixin/Eventful#onmousewheel
 * @type {Function}
 * @default null
 */
/**
 * @event module:zrender/mixin/Eventful#onmousedown
 * @type {Function}
 * @default null
 */
/**
 * @event module:zrender/mixin/Eventful#onmouseup
 * @type {Function}
 * @default null
 */
/**
 * @event module:zrender/mixin/Eventful#ondrag
 * @type {Function}
 * @default null
 */
/**
 * @event module:zrender/mixin/Eventful#ondragstart
 * @type {Function}
 * @default null
 */
/**
 * @event module:zrender/mixin/Eventful#ondragend
 * @type {Function}
 * @default null
 */
/**
 * @event module:zrender/mixin/Eventful#ondragenter
 * @type {Function}
 * @default null
 */
/**
 * @event module:zrender/mixin/Eventful#ondragleave
 * @type {Function}
 * @default null
 */
/**
 * @event module:zrender/mixin/Eventful#ondragover
 * @type {Function}
 * @default null
 */
/**
 * @event module:zrender/mixin/Eventful#ondrop
 * @type {Function}
 * @default null
 */

/* harmony default export */ __webpack_exports__["a"] = (Eventful);

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Element__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_BoundingRect__ = __webpack_require__(1);
/**
 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
 * @module zrender/graphic/Group
 * @example
 *     var Group = require('zrender/container/Group');
 *     var Circle = require('zrender/graphic/shape/Circle');
 *     var g = new Group();
 *     g.position[0] = 100;
 *     g.position[1] = 100;
 *     g.add(new Circle({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 20,
 *         }
 *     }));
 *     zr.add(g);
 */





/**
 * @alias module:zrender/graphic/Group
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @extends module:zrender/mixin/Eventful
 */
var Group = function (opts) {

    opts = opts || {};

    __WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */].call(this, opts);

    for (var key in opts) {
        if (opts.hasOwnProperty(key)) {
            this[key] = opts[key];
        }
    }

    this._children = [];

    this.__storage = null;

    this.__dirty = true;
};

Group.prototype = {

    constructor: Group,

    isGroup: true,

    /**
     * @type {string}
     */
    type: 'group',

    /**
     * 所有子孙元素是否响应鼠标事件
     * @name module:/zrender/container/Group#silent
     * @type {boolean}
     * @default false
     */
    silent: false,

    /**
     * @return {Array.<module:zrender/Element>}
     */
    children: function () {
        return this._children.slice();
    },

    /**
     * 获取指定 index 的儿子节点
     * @param  {number} idx
     * @return {module:zrender/Element}
     */
    childAt: function (idx) {
        return this._children[idx];
    },

    /**
     * 获取指定名字的儿子节点
     * @param  {string} name
     * @return {module:zrender/Element}
     */
    childOfName: function (name) {
        var children = this._children;
        for (var i = 0; i < children.length; i++) {
            if (children[i].name === name) {
                return children[i];
            }
            }
    },

    /**
     * @return {number}
     */
    childCount: function () {
        return this._children.length;
    },

    /**
     * 添加子节点到最后
     * @param {module:zrender/Element} child
     */
    add: function (child) {
        if (child && child !== this && child.parent !== this) {

            this._children.push(child);

            this._doAdd(child);
        }

        return this;
    },

    /**
     * 添加子节点在 nextSibling 之前
     * @param {module:zrender/Element} child
     * @param {module:zrender/Element} nextSibling
     */
    addBefore: function (child, nextSibling) {
        if (child && child !== this && child.parent !== this
            && nextSibling && nextSibling.parent === this) {

            var children = this._children;
            var idx = children.indexOf(nextSibling);

            if (idx >= 0) {
                children.splice(idx, 0, child);
                this._doAdd(child);
            }
        }

        return this;
    },

    _doAdd: function (child) {
        if (child.parent) {
            child.parent.remove(child);
        }

        child.parent = this;

        var storage = this.__storage;
        var zr = this.__zr;
        if (storage && storage !== child.__storage) {

            storage.addToStorage(child);

            if (child instanceof Group) {
                child.addChildrenToStorage(storage);
            }
        }

        zr && zr.refresh();
    },

    /**
     * 移除子节点
     * @param {module:zrender/Element} child
     */
    remove: function (child) {
        var zr = this.__zr;
        var storage = this.__storage;
        var children = this._children;

        var idx = __WEBPACK_IMPORTED_MODULE_0__core_util__["k" /* indexOf */](children, child);
        if (idx < 0) {
            return this;
        }
        children.splice(idx, 1);

        child.parent = null;

        if (storage) {

            storage.delFromStorage(child);

            if (child instanceof Group) {
                child.delChildrenFromStorage(storage);
            }
        }

        zr && zr.refresh();

        return this;
    },

    /**
     * 移除所有子节点
     */
    removeAll: function () {
        var children = this._children;
        var storage = this.__storage;
        var child;
        var i;
        for (i = 0; i < children.length; i++) {
            child = children[i];
            if (storage) {
                storage.delFromStorage(child);
                if (child instanceof Group) {
                    child.delChildrenFromStorage(storage);
                }
            }
            child.parent = null;
        }
        children.length = 0;

        return this;
    },

    /**
     * 遍历所有子节点
     * @param  {Function} cb
     * @param  {}   context
     */
    eachChild: function (cb, context) {
        var children = this._children;
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            cb.call(context, child, i);
        }
        return this;
    },

    /**
     * 深度优先遍历所有子孙节点
     * @param  {Function} cb
     * @param  {}   context
     */
    traverse: function (cb, context) {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            cb.call(context, child);

            if (child.type === 'group') {
                child.traverse(cb, context);
            }
        }
        return this;
    },

    addChildrenToStorage: function (storage) {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            storage.addToStorage(child);
            if (child instanceof Group) {
                child.addChildrenToStorage(storage);
            }
        }
    },

    delChildrenFromStorage: function (storage) {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            storage.delFromStorage(child);
            if (child instanceof Group) {
                child.delChildrenFromStorage(storage);
            }
        }
    },

    dirty: function () {
        this.__dirty = true;
        this.__zr && this.__zr.refresh();
        return this;
    },

    /**
     * @return {module:zrender/core/BoundingRect}
     */
    getBoundingRect: function (includeChildren) {
        // TODO Caching
        var rect = null;
        var tmpRect = new __WEBPACK_IMPORTED_MODULE_2__core_BoundingRect__["a" /* default */](0, 0, 0, 0);
        var children = includeChildren || this._children;
        var tmpMat = [];

        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (child.ignore || child.invisible) {
                continue;
            }

            var childRect = child.getBoundingRect();
            var transform = child.getLocalTransform(tmpMat);
            // TODO
            // The boundingRect cacluated by transforming original
            // rect may be bigger than the actual bundingRect when rotation
            // is used. (Consider a circle rotated aginst its center, where
            // the actual boundingRect should be the same as that not be
            // rotated.) But we can not find better approach to calculate
            // actual boundingRect yet, considering performance.
            if (transform) {
                tmpRect.copy(childRect);
                tmpRect.applyTransform(transform);
                rect = rect || tmpRect.clone();
                rect.union(tmpRect);
            }
            else {
                rect = rect || childRect.clone();
                rect.union(childRect);
            }
        }
        return rect || tmpRect;
    }
};

__WEBPACK_IMPORTED_MODULE_0__core_util__["a" /* inherits */](Group, __WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Group);

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["e"] = clientToLocal;
/* harmony export (immutable) */ __webpack_exports__["b"] = normalizeEvent;
/* harmony export (immutable) */ __webpack_exports__["c"] = addEventListener;
/* harmony export (immutable) */ __webpack_exports__["d"] = removeEventListener;
/* unused harmony export stop */
/* unused harmony export notLeftMouse */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixin_Eventful__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__env__ = __webpack_require__(5);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__mixin_Eventful__["a"]; });
/**
 * 事件辅助类
 * @module zrender/core/event
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 */




var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;

var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;

function getBoundingClientRect(el) {
    // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
    return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};
}

// `calculate` is optional, default false
function clientToLocal(el, e, out, calculate) {
    out = out || {};

    // According to the W3C Working Draft, offsetX and offsetY should be relative
    // to the padding edge of the target element. The only browser using this convention
    // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
    // not support the properties.
    // (see http://www.jacklmoore.com/notes/mouse-position/)
    // In zr painter.dom, padding edge equals to border edge.

    // FIXME
    // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
    // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
    // is too complex. So css-transfrom dont support in this case temporarily.
    if (calculate || !__WEBPACK_IMPORTED_MODULE_1__env__["a" /* default */].canvasSupported) {
        defaultGetZrXY(el, e, out);
    }
    // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
    // ancestor element, so we should make sure el is positioned (e.g., not position:static).
    // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
    // zoom-factor, overflow / opacity layers, transforms ...)
    // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
    // <https://bugs.jquery.com/ticket/8523#comment:14>
    // BTW3, In ff, offsetX/offsetY is always 0.
    else if (__WEBPACK_IMPORTED_MODULE_1__env__["a" /* default */].browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
        out.zrX = e.layerX;
        out.zrY = e.layerY;
    }
    // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
    else if (e.offsetX != null) {
        out.zrX = e.offsetX;
        out.zrY = e.offsetY;
    }
    // For some other device, e.g., IOS safari.
    else {
        defaultGetZrXY(el, e, out);
    }

    return out;
}

function defaultGetZrXY(el, e, out) {
    // This well-known method below does not support css transform.
    var box = getBoundingClientRect(el);
    out.zrX = e.clientX - box.left;
    out.zrY = e.clientY - box.top;
}

/**
 * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
 * `calculate` is optional, default false.
 */
function normalizeEvent(el, e, calculate) {

    e = e || window.event;

    if (e.zrX != null) {
        return e;
    }

    var eventType = e.type;
    var isTouch = eventType && eventType.indexOf('touch') >= 0;

    if (!isTouch) {
        clientToLocal(el, e, e, calculate);
        e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
    }
    else {
        var touch = eventType != 'touchend'
            ? e.targetTouches[0]
            : e.changedTouches[0];
        touch && clientToLocal(el, touch, e, calculate);
    }

    // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
    // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
    // If e.which has been defined, if may be readonly,
    // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
    var button = e.button;
    if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
        e.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
    }

    return e;
}

function addEventListener(el, name, handler) {
    if (isDomLevel2) {
        el.addEventListener(name, handler);
    }
    else {
        el.attachEvent('on' + name, handler);
    }
}

function removeEventListener(el, name, handler) {
    if (isDomLevel2) {
        el.removeEventListener(name, handler);
    }
    else {
        el.detachEvent('on' + name, handler);
    }
}

/**
 * preventDefault and stopPropagation.
 * Notice: do not do that in zrender. Upper application
 * do that if necessary.
 *
 * @memberOf module:zrender/core/event
 * @method
 * @param {Event} e : event对象
 */
var stop = isDomLevel2
    ? function (e) {
        e.preventDefault();
        e.stopPropagation();
        e.cancelBubble = true;
    }
    : function (e) {
        e.returnValue = false;
        e.cancelBubble = true;
    };

function notLeftMouse(e) {
    // If e.which is undefined, considered as left mouse event.
    return e.which > 1;
}

// 做向上兼容



/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Style__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Element__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mixin_RectText__ = __webpack_require__(53);
/**
 * 可绘制的图形基类
 * Base class of all displayable graphic objects
 * @module zrender/graphic/Displayable
 */







/**
 * @alias module:zrender/graphic/Displayable
 * @extends module:zrender/Element
 * @extends module:zrender/graphic/mixin/RectText
 */
function Displayable(opts) {

    opts = opts || {};

    __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].call(this, opts);

    // Extend properties
    for (var name in opts) {
        if (
            opts.hasOwnProperty(name) &&
            name !== 'style'
        ) {
            this[name] = opts[name];
        }
    }

    /**
     * @type {module:zrender/graphic/Style}
     */
    this.style = new __WEBPACK_IMPORTED_MODULE_1__Style__["a" /* default */](opts.style, this);

    this._rect = null;
    // Shapes for cascade clipping.
    this.__clipPaths = [];

    // FIXME Stateful must be mixined after style is setted
    // Stateful.call(this, opts);
}

Displayable.prototype = {

    constructor: Displayable,

    type: 'displayable',

    /**
     * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
     * Dirty flag. From which painter will determine if this displayable object needs brush
     * @name module:zrender/graphic/Displayable#__dirty
     * @type {boolean}
     */
    __dirty: true,

    /**
     * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
     * If ignore drawing of the displayable object. Mouse event will still be triggered
     * @name module:/zrender/graphic/Displayable#invisible
     * @type {boolean}
     * @default false
     */
    invisible: false,

    /**
     * @name module:/zrender/graphic/Displayable#z
     * @type {number}
     * @default 0
     */
    z: 0,

    /**
     * @name module:/zrender/graphic/Displayable#z
     * @type {number}
     * @default 0
     */
    z2: 0,

    /**
     * z层level，决定绘画在哪层canvas中
     * @name module:/zrender/graphic/Displayable#zlevel
     * @type {number}
     * @default 0
     */
    zlevel: 0,

    /**
     * 是否可拖拽
     * @name module:/zrender/graphic/Displayable#draggable
     * @type {boolean}
     * @default false
     */
    draggable: false,

    /**
     * 是否正在拖拽
     * @name module:/zrender/graphic/Displayable#draggable
     * @type {boolean}
     * @default false
     */
    dragging: false,

    /**
     * 是否相应鼠标事件
     * @name module:/zrender/graphic/Displayable#silent
     * @type {boolean}
     * @default false
     */
    silent: false,

    /**
     * If enable culling
     * @type {boolean}
     * @default false
     */
    culling: false,

    /**
     * Mouse cursor when hovered
     * @name module:/zrender/graphic/Displayable#cursor
     * @type {string}
     */
    cursor: 'pointer',

    /**
     * If hover area is bounding rect
     * @name module:/zrender/graphic/Displayable#rectHover
     * @type {string}
     */
    rectHover: false,

    /**
     * Render the element progressively when the value >= 0,
     * usefull for large data.
     * @type {number}
     */
    progressive: -1,

    beforeBrush: function (ctx) {},

    afterBrush: function (ctx) {},

    /**
     * 图形绘制方法
     * @param {CanvasRenderingContext2D} ctx
     */
    // Interface
    brush: function (ctx, prevEl) {},

    /**
     * 获取最小包围盒
     * @return {module:zrender/core/BoundingRect}
     */
    // Interface
    getBoundingRect: function () {},

    /**
     * 判断坐标 x, y 是否在图形上
     * If displayable element contain coord x, y
     * @param  {number} x
     * @param  {number} y
     * @return {boolean}
     */
    contain: function (x, y) {
        return this.rectContain(x, y);
    },

    /**
     * @param  {Function} cb
     * @param  {}   context
     */
    traverse: function (cb, context) {
        cb.call(context, this);
    },

    /**
     * 判断坐标 x, y 是否在图形的包围盒上
     * If bounding rect of element contain coord x, y
     * @param  {number} x
     * @param  {number} y
     * @return {boolean}
     */
    rectContain: function (x, y) {
        var coord = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        return rect.contain(coord[0], coord[1]);
    },

    /**
     * 标记图形元素为脏，并且在下一帧重绘
     * Mark displayable element dirty and refresh next frame
     */
    dirty: function () {
        this.__dirty = true;

        this._rect = null;

        this.__zr && this.__zr.refresh();
    },

    /**
     * 图形是否会触发事件
     * If displayable object binded any event
     * @return {boolean}
     */
    // TODO, 通过 bind 绑定的事件
    // isSilent: function () {
    //     return !(
    //         this.hoverable || this.draggable
    //         || this.onmousemove || this.onmouseover || this.onmouseout
    //         || this.onmousedown || this.onmouseup || this.onclick
    //         || this.ondragenter || this.ondragover || this.ondragleave
    //         || this.ondrop
    //     );
    // },
    /**
     * Alias for animate('style')
     * @param {boolean} loop
     */
    animateStyle: function (loop) {
        return this.animate('style', loop);
    },

    attrKV: function (key, value) {
        if (key !== 'style') {
            __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].prototype.attrKV.call(this, key, value);
        }
        else {
            this.style.set(value);
        }
    },

    /**
     * @param {Object|string} key
     * @param {*} value
     */
    setStyle: function (key, value) {
        this.style.set(key, value);
        this.dirty(false);
        return this;
    },

    /**
     * Use given style object
     * @param  {Object} obj
     */
    useStyle: function (obj) {
        this.style = new __WEBPACK_IMPORTED_MODULE_1__Style__["a" /* default */](obj, this);
        this.dirty(false);
        return this;
    }
};

__WEBPACK_IMPORTED_MODULE_0__core_util__["a" /* inherits */](Displayable, __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */]);

__WEBPACK_IMPORTED_MODULE_0__core_util__["j" /* mixin */](Displayable, __WEBPACK_IMPORTED_MODULE_3__mixin_RectText__["a" /* default */]);
// zrUtil.mixin(Displayable, Stateful);

/* harmony default export */ __webpack_exports__["a"] = (Displayable);

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = findExistImage;
/* harmony export (immutable) */ __webpack_exports__["a"] = createOrUpdateImage;
/* harmony export (immutable) */ __webpack_exports__["b"] = isImageReady;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_LRU__ = __webpack_require__(17);



var globalImageCache = new __WEBPACK_IMPORTED_MODULE_0__core_LRU__["a" /* default */](50);

/**
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */
function findExistImage(newImageOrSrc) {
    if (typeof newImageOrSrc === 'string') {
        var cachedImgObj = globalImageCache.get(newImageOrSrc);
        return cachedImgObj && cachedImgObj.image;
    }
    else {
        return newImageOrSrc;
    }
}

/**
 * Caution: User should cache loaded images, but not just count on LRU.
 * Consider if required images more than LRU size, will dead loop occur?
 *
 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
 * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
 * @param {module:zrender/Element} [hostEl] For calling `dirty`.
 * @param {Function} [cb] params: (image, cbPayload)
 * @param {Object} [cbPayload] Payload on cb calling.
 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
 */
function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
    if (!newImageOrSrc) {
        return image;
    }
    else if (typeof newImageOrSrc === 'string') {

        // Image should not be loaded repeatly.
        if ((image && image.__zrImageSrc === newImageOrSrc) || !hostEl) {
            return image;
        }

        // Only when there is no existent image or existent image src
        // is different, this method is responsible for load.
        var cachedImgObj = globalImageCache.get(newImageOrSrc);

        var pendingWrap = {hostEl: hostEl, cb: cb, cbPayload: cbPayload};

        if (cachedImgObj) {
            image = cachedImgObj.image;
            !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
        }
        else {
            !image && (image = new Image());
            image.onload = imageOnLoad;

            globalImageCache.put(
                newImageOrSrc,
                image.__cachedImgObj = {
                    image: image,
                    pending: [pendingWrap]
                }
            );

            image.src = image.__zrImageSrc = newImageOrSrc;
        }

        return image;
    }
    // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
    else {
        return newImageOrSrc;
    }
}

function imageOnLoad() {
    var cachedImgObj = this.__cachedImgObj;
    this.onload = this.__cachedImgObj = null;

    for (var i = 0; i < cachedImgObj.pending.length; i++) {
        var pendingWrap = cachedImgObj.pending[i];
        var cb = pendingWrap.cb;
        cb && cb(this, pendingWrap.cbPayload);
        pendingWrap.hostEl.dirty();
    }
    cachedImgObj.pending.length = 0;
}

function isImageReady(image) {
    return image && image.width && image.height;
}



/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Point; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_zrender_src_graphic_shape_Circle__ = __webpack_require__(54);


function Point(model) {
    __WEBPACK_IMPORTED_MODULE_0_zrender_src_graphic_shape_Circle__["a" /* default */].call(this);
    this.shape.r = 5;
    this.shape.cx = model.x;
    this.shape.cy = model.y;
    this.draggable = true;
    this.ondragend = evt => {
        model.x = evt.offsetX;
        model.y = evt.offsetY;
        this.parent.cross();
    };
}
Point.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0_zrender_src_graphic_shape_Circle__["a" /* default */].prototype);



/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_guid__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixin_Eventful__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mixin_Transformable__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mixin_Animatable__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_util__ = __webpack_require__(0);






/**
 * @alias module:zrender/Element
 * @constructor
 * @extends {module:zrender/mixin/Animatable}
 * @extends {module:zrender/mixin/Transformable}
 * @extends {module:zrender/mixin/Eventful}
 */
var Element = function (opts) { // jshint ignore:line

    __WEBPACK_IMPORTED_MODULE_2__mixin_Transformable__["a" /* default */].call(this, opts);
    __WEBPACK_IMPORTED_MODULE_1__mixin_Eventful__["a" /* default */].call(this, opts);
    __WEBPACK_IMPORTED_MODULE_3__mixin_Animatable__["a" /* default */].call(this, opts);

    /**
     * 画布元素ID
     * @type {string}
     */
    this.id = opts.id || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_guid__["a" /* default */])();
};

Element.prototype = {

    /**
     * 元素类型
     * Element type
     * @type {string}
     */
    type: 'element',

    /**
     * 元素名字
     * Element name
     * @type {string}
     */
    name: '',

    /**
     * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
     * ZRender instance will be assigned when element is associated with zrender
     * @name module:/zrender/Element#__zr
     * @type {module:zrender/ZRender}
     */
    __zr: null,

    /**
     * 图形是否忽略，为true时忽略图形的绘制以及事件触发
     * If ignore drawing and events of the element object
     * @name module:/zrender/Element#ignore
     * @type {boolean}
     * @default false
     */
    ignore: false,

    /**
     * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
     * 该路径会继承被裁减对象的变换
     * @type {module:zrender/graphic/Path}
     * @see http://www.w3.org/TR/2dcontext/#clipping-region
     * @readOnly
     */
    clipPath: null,

    /**
     * Drift element
     * @param  {number} dx dx on the global space
     * @param  {number} dy dy on the global space
     */
    drift: function (dx, dy) {
        switch (this.draggable) {
            case 'horizontal':
                dy = 0;
                break;
            case 'vertical':
                dx = 0;
                break;
        }

        var m = this.transform;
        if (!m) {
            m = this.transform = [1, 0, 0, 1, 0, 0];
        }
        m[4] += dx;
        m[5] += dy;

        this.decomposeTransform();
        this.dirty(false);
    },

    /**
     * Hook before update
     */
    beforeUpdate: function () {},
    /**
     * Hook after update
     */
    afterUpdate: function () {},
    /**
     * Update each frame
     */
    update: function () {
        this.updateTransform();
    },

    /**
     * @param  {Function} cb
     * @param  {}   context
     */
    traverse: function (cb, context) {},

    /**
     * @protected
     */
    attrKV: function (key, value) {
        if (key === 'position' || key === 'scale' || key === 'origin') {
            // Copy the array
            if (value) {
                var target = this[key];
                if (!target) {
                    target = this[key] = [];
                }
                target[0] = value[0];
                target[1] = value[1];
            }
        }
        else {
            this[key] = value;
        }
    },

    /**
     * Hide the element
     */
    hide: function () {
        this.ignore = true;
        this.__zr && this.__zr.refresh();
    },

    /**
     * Show the element
     */
    show: function () {
        this.ignore = false;
        this.__zr && this.__zr.refresh();
    },

    /**
     * @param {string|Object} key
     * @param {*} value
     */
    attr: function (key, value) {
        if (typeof key === 'string') {
            this.attrKV(key, value);
        }
        else if (__WEBPACK_IMPORTED_MODULE_4__core_util__["g" /* isObject */](key)) {
            for (var name in key) {
                if (key.hasOwnProperty(name)) {
                    this.attrKV(name, key[name]);
                }
            }
        }

        this.dirty(false);

        return this;
    },

    /**
     * @param {module:zrender/graphic/Path} clipPath
     */
    setClipPath: function (clipPath) {
        var zr = this.__zr;
        if (zr) {
            clipPath.addSelfToZr(zr);
        }

        // Remove previous clip path
        if (this.clipPath && this.clipPath !== clipPath) {
            this.removeClipPath();
        }

        this.clipPath = clipPath;
        clipPath.__zr = zr;
        clipPath.__clipTarget = this;

        this.dirty(false);
    },

    /**
     */
    removeClipPath: function () {
        var clipPath = this.clipPath;
        if (clipPath) {
            if (clipPath.__zr) {
                clipPath.removeSelfFromZr(clipPath.__zr);
            }

            clipPath.__zr = null;
            clipPath.__clipTarget = null;
            this.clipPath = null;

            this.dirty(false);
        }
    },

    /**
     * Add self from zrender instance.
     * Not recursively because it will be invoked when element added to storage.
     * @param {module:zrender/ZRender} zr
     */
    addSelfToZr: function (zr) {
        this.__zr = zr;
        // 添加动画
        var animators = this.animators;
        if (animators) {
            for (var i = 0; i < animators.length; i++) {
                zr.animation.addAnimator(animators[i]);
            }
        }

        if (this.clipPath) {
            this.clipPath.addSelfToZr(zr);
        }
    },

    /**
     * Remove self from zrender instance.
     * Not recursively because it will be invoked when element added to storage.
     * @param {module:zrender/ZRender} zr
     */
    removeSelfFromZr: function (zr) {
        this.__zr = null;
        // 移除动画
        var animators = this.animators;
        if (animators) {
            for (var i = 0; i < animators.length; i++) {
                zr.animation.removeAnimator(animators[i]);
            }
        }

        if (this.clipPath) {
            this.clipPath.removeSelfFromZr(zr);
        }
    }
};

__WEBPACK_IMPORTED_MODULE_4__core_util__["j" /* mixin */](Element, __WEBPACK_IMPORTED_MODULE_3__mixin_Animatable__["a" /* default */]);
__WEBPACK_IMPORTED_MODULE_4__core_util__["j" /* mixin */](Element, __WEBPACK_IMPORTED_MODULE_2__mixin_Transformable__["a" /* default */]);
__WEBPACK_IMPORTED_MODULE_4__core_util__["j" /* mixin */](Element, __WEBPACK_IMPORTED_MODULE_1__mixin_Eventful__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Element);

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Clip__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tool_color__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_util__ = __webpack_require__(0);
/**
 * @module echarts/animation/Animator
 */





var arraySlice = Array.prototype.slice;

function defaultGetter(target, key) {
    return target[key];
}

function defaultSetter(target, key, value) {
    target[key] = value;
}

/**
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} percent
 * @return {number}
 */
function interpolateNumber(p0, p1, percent) {
    return (p1 - p0) * percent + p0;
}

/**
 * @param  {string} p0
 * @param  {string} p1
 * @param  {number} percent
 * @return {string}
 */
function interpolateString(p0, p1, percent) {
    return percent > 0.5 ? p1 : p0;
}

/**
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {number} percent
 * @param  {Array} out
 * @param  {number} arrDim
 */
function interpolateArray(p0, p1, percent, out, arrDim) {
    var len = p0.length;
    if (arrDim == 1) {
        for (var i = 0; i < len; i++) {
            out[i] = interpolateNumber(p0[i], p1[i], percent);
        }
    }
    else {
        var len2 = len && p0[0].length;
        for (var i = 0; i < len; i++) {
            for (var j = 0; j < len2; j++) {
                out[i][j] = interpolateNumber(
                    p0[i][j], p1[i][j], percent
                );
            }
        }
    }
}

// arr0 is source array, arr1 is target array.
// Do some preprocess to avoid error happened when interpolating from arr0 to arr1
function fillArr(arr0, arr1, arrDim) {
    var arr0Len = arr0.length;
    var arr1Len = arr1.length;
    if (arr0Len !== arr1Len) {
        // FIXME Not work for TypedArray
        var isPreviousLarger = arr0Len > arr1Len;
        if (isPreviousLarger) {
            // Cut the previous
            arr0.length = arr1Len;
        }
        else {
            // Fill the previous
            for (var i = arr0Len; i < arr1Len; i++) {
                arr0.push(
                    arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])
                );
            }
        }
    }
    // Handling NaN value
    var len2 = arr0[0] && arr0[0].length;
    for (var i = 0; i < arr0.length; i++) {
        if (arrDim === 1) {
            if (isNaN(arr0[i])) {
                arr0[i] = arr1[i];
            }
        }
        else {
            for (var j = 0; j < len2; j++) {
                if (isNaN(arr0[i][j])) {
                    arr0[i][j] = arr1[i][j];
                }
            }
        }
    }
}

/**
 * @param  {Array} arr0
 * @param  {Array} arr1
 * @param  {number} arrDim
 * @return {boolean}
 */
function isArraySame(arr0, arr1, arrDim) {
    if (arr0 === arr1) {
        return true;
    }
    var len = arr0.length;
    if (len !== arr1.length) {
        return false;
    }
    if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
            if (arr0[i] !== arr1[i]) {
                return false;
            }
        }
    }
    else {
        var len2 = arr0[0].length;
        for (var i = 0; i < len; i++) {
            for (var j = 0; j < len2; j++) {
                if (arr0[i][j] !== arr1[i][j]) {
                    return false;
                }
            }
        }
    }
    return true;
}

/**
 * Catmull Rom interpolate array
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {Array} p2
 * @param  {Array} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @param  {Array} out
 * @param  {number} arrDim
 */
function catmullRomInterpolateArray(
    p0, p1, p2, p3, t, t2, t3, out, arrDim
) {
    var len = p0.length;
    if (arrDim == 1) {
        for (var i = 0; i < len; i++) {
            out[i] = catmullRomInterpolate(
                p0[i], p1[i], p2[i], p3[i], t, t2, t3
            );
        }
    }
    else {
        var len2 = p0[0].length;
        for (var i = 0; i < len; i++) {
            for (var j = 0; j < len2; j++) {
                out[i][j] = catmullRomInterpolate(
                    p0[i][j], p1[i][j], p2[i][j], p3[i][j],
                    t, t2, t3
                );
            }
        }
    }
}

/**
 * Catmull Rom interpolate number
 * @param  {number} p0
 * @param  {number} p1
 * @param  {number} p2
 * @param  {number} p3
 * @param  {number} t
 * @param  {number} t2
 * @param  {number} t3
 * @return {number}
 */
function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    return (2 * (p1 - p2) + v0 + v1) * t3
            + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
            + v0 * t + p1;
}

function cloneValue(value) {
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["m" /* isArrayLike */])(value)) {
        var len = value.length;
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["m" /* isArrayLike */])(value[0])) {
            var ret = [];
            for (var i = 0; i < len; i++) {
                ret.push(arraySlice.call(value[i]));
            }
            return ret;
        }

        return arraySlice.call(value);
    }

    return value;
}

function rgba2String(rgba) {
    rgba[0] = Math.floor(rgba[0]);
    rgba[1] = Math.floor(rgba[1]);
    rgba[2] = Math.floor(rgba[2]);

    return 'rgba(' + rgba.join(',') + ')';
}

function getArrayDim(keyframes) {
    var lastValue = keyframes[keyframes.length - 1].value;
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["m" /* isArrayLike */])(lastValue && lastValue[0]) ? 2 : 1;
}

function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
    var getter = animator._getter;
    var setter = animator._setter;
    var useSpline = easing === 'spline';

    var trackLen = keyframes.length;
    if (!trackLen) {
        return;
    }
    // Guess data type
    var firstVal = keyframes[0].value;
    var isValueArray = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["m" /* isArrayLike */])(firstVal);
    var isValueColor = false;
    var isValueString = false;

    // For vertices morphing
    var arrDim = isValueArray ? getArrayDim(keyframes) : 0;

    var trackMaxTime;
    // Sort keyframe as ascending
    keyframes.sort(function(a, b) {
        return a.time - b.time;
    });

    trackMaxTime = keyframes[trackLen - 1].time;
    // Percents of each keyframe
    var kfPercents = [];
    // Value of each keyframe
    var kfValues = [];
    var prevValue = keyframes[0].value;
    var isAllValueEqual = true;
    for (var i = 0; i < trackLen; i++) {
        kfPercents.push(keyframes[i].time / trackMaxTime);
        // Assume value is a color when it is a string
        var value = keyframes[i].value;

        // Check if value is equal, deep check if value is array
        if (!((isValueArray && isArraySame(value, prevValue, arrDim))
            || (!isValueArray && value === prevValue))) {
            isAllValueEqual = false;
        }
        prevValue = value;

        // Try converting a string to a color array
        if (typeof value == 'string') {
            var colorArray = __WEBPACK_IMPORTED_MODULE_1__tool_color__["a" /* parse */](value);
            if (colorArray) {
                value = colorArray;
                isValueColor = true;
            }
            else {
                isValueString = true;
            }
        }
        kfValues.push(value);
    }
    if (!forceAnimate && isAllValueEqual) {
        return;
    }

    var lastValue = kfValues[trackLen - 1];
    // Polyfill array and NaN value
    for (var i = 0; i < trackLen - 1; i++) {
        if (isValueArray) {
            fillArr(kfValues[i], lastValue, arrDim);
        }
        else {
            if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
                kfValues[i] = lastValue;
            }
        }
    }
    isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);

    // Cache the key of last frame to speed up when
    // animation playback is sequency
    var lastFrame = 0;
    var lastFramePercent = 0;
    var start;
    var w;
    var p0;
    var p1;
    var p2;
    var p3;

    if (isValueColor) {
        var rgba = [0, 0, 0, 0];
    }

    var onframe = function (target, percent) {
        // Find the range keyframes
        // kf1-----kf2---------current--------kf3
        // find kf2 and kf3 and do interpolation
        var frame;
        // In the easing function like elasticOut, percent may less than 0
        if (percent < 0) {
            frame = 0;
        }
        else if (percent < lastFramePercent) {
            // Start from next key
            // PENDING start from lastFrame ?
            start = Math.min(lastFrame + 1, trackLen - 1);
            for (frame = start; frame >= 0; frame--) {
                if (kfPercents[frame] <= percent) {
                    break;
                }
            }
            // PENDING really need to do this ?
            frame = Math.min(frame, trackLen - 2);
        }
        else {
            for (frame = lastFrame; frame < trackLen; frame++) {
                if (kfPercents[frame] > percent) {
                    break;
                }
            }
            frame = Math.min(frame - 1, trackLen - 2);
        }
        lastFrame = frame;
        lastFramePercent = percent;

        var range = (kfPercents[frame + 1] - kfPercents[frame]);
        if (range === 0) {
            return;
        }
        else {
            w = (percent - kfPercents[frame]) / range;
        }
        if (useSpline) {
            p1 = kfValues[frame];
            p0 = kfValues[frame === 0 ? frame : frame - 1];
            p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
            p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
            if (isValueArray) {
                catmullRomInterpolateArray(
                    p0, p1, p2, p3, w, w * w, w * w * w,
                    getter(target, propName),
                    arrDim
                );
            }
            else {
                var value;
                if (isValueColor) {
                    value = catmullRomInterpolateArray(
                        p0, p1, p2, p3, w, w * w, w * w * w,
                        rgba, 1
                    );
                    value = rgba2String(rgba);
                }
                else if (isValueString) {
                    // String is step(0.5)
                    return interpolateString(p1, p2, w);
                }
                else {
                    value = catmullRomInterpolate(
                        p0, p1, p2, p3, w, w * w, w * w * w
                    );
                }
                setter(
                    target,
                    propName,
                    value
                );
            }
        }
        else {
            if (isValueArray) {
                interpolateArray(
                    kfValues[frame], kfValues[frame + 1], w,
                    getter(target, propName),
                    arrDim
                );
            }
            else {
                var value;
                if (isValueColor) {
                    interpolateArray(
                        kfValues[frame], kfValues[frame + 1], w,
                        rgba, 1
                    );
                    value = rgba2String(rgba);
                }
                else if (isValueString) {
                    // String is step(0.5)
                    return interpolateString(kfValues[frame], kfValues[frame + 1], w);
                }
                else {
                    value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
                }
                setter(
                    target,
                    propName,
                    value
                );
            }
        }
    };

    var clip = new __WEBPACK_IMPORTED_MODULE_0__Clip__["a" /* default */]({
        target: animator._target,
        life: trackMaxTime,
        loop: animator._loop,
        delay: animator._delay,
        onframe: onframe,
        ondestroy: oneTrackDone
    });

    if (easing && easing !== 'spline') {
        clip.easing = easing;
    }

    return clip;
}

/**
 * @alias module:zrender/animation/Animator
 * @constructor
 * @param {Object} target
 * @param {boolean} loop
 * @param {Function} getter
 * @param {Function} setter
 */
var Animator = function(target, loop, getter, setter) {
    this._tracks = {};
    this._target = target;

    this._loop = loop || false;

    this._getter = getter || defaultGetter;
    this._setter = setter || defaultSetter;

    this._clipCount = 0;

    this._delay = 0;

    this._doneList = [];

    this._onframeList = [];

    this._clipList = [];
};

Animator.prototype = {
    /**
     * 设置动画关键帧
     * @param  {number} time 关键帧时间，单位是ms
     * @param  {Object} props 关键帧的属性值，key-value表示
     * @return {module:zrender/animation/Animator}
     */
    when: function(time /* ms */, props) {
        var tracks = this._tracks;
        for (var propName in props) {
            if (!props.hasOwnProperty(propName)) {
                continue;
            }

            if (!tracks[propName]) {
                tracks[propName] = [];
                // Invalid value
                var value = this._getter(this._target, propName);
                if (value == null) {
                    // zrLog('Invalid property ' + propName);
                    continue;
                }
                // If time is 0
                //  Then props is given initialize value
                // Else
                //  Initialize value from current prop value
                if (time !== 0) {
                    tracks[propName].push({
                        time: 0,
                        value: cloneValue(value)
                    });
                }
            }
            tracks[propName].push({
                time: time,
                value: props[propName]
            });
        }
        return this;
    },
    /**
     * 添加动画每一帧的回调函数
     * @param  {Function} callback
     * @return {module:zrender/animation/Animator}
     */
    during: function (callback) {
        this._onframeList.push(callback);
        return this;
    },

    pause: function () {
        for (var i = 0; i < this._clipList.length; i++) {
            this._clipList[i].pause();
        }
        this._paused = true;
    },

    resume: function () {
        for (var i = 0; i < this._clipList.length; i++) {
            this._clipList[i].resume();
        }
        this._paused = false;
    },

    isPaused: function () {
        return !!this._paused;
    },

    _doneCallback: function () {
        // Clear all tracks
        this._tracks = {};
        // Clear all clips
        this._clipList.length = 0;

        var doneList = this._doneList;
        var len = doneList.length;
        for (var i = 0; i < len; i++) {
            doneList[i].call(this);
        }
    },
    /**
     * 开始执行动画
     * @param  {string|Function} [easing]
     *         动画缓动函数，详见{@link module:zrender/animation/easing}
     * @param  {boolean} forceAnimate
     * @return {module:zrender/animation/Animator}
     */
    start: function (easing, forceAnimate) {

        var self = this;
        var clipCount = 0;

        var oneTrackDone = function() {
            clipCount--;
            if (!clipCount) {
                self._doneCallback();
            }
        };

        var lastClip;
        for (var propName in this._tracks) {
            if (!this._tracks.hasOwnProperty(propName)) {
                continue;
            }
            var clip = createTrackClip(
                this, easing, oneTrackDone,
                this._tracks[propName], propName, forceAnimate
            );
            if (clip) {
                this._clipList.push(clip);
                clipCount++;

                // If start after added to animation
                if (this.animation) {
                    this.animation.addClip(clip);
                }

                lastClip = clip;
            }
        }

        // Add during callback on the last clip
        if (lastClip) {
            var oldOnFrame = lastClip.onframe;
            lastClip.onframe = function (target, percent) {
                oldOnFrame(target, percent);

                for (var i = 0; i < self._onframeList.length; i++) {
                    self._onframeList[i](target, percent);
                }
            };
        }

        // This optimization will help the case that in the upper application
        // the view may be refreshed frequently, where animation will be
        // called repeatly but nothing changed.
        if (!clipCount) {
            this._doneCallback();
        }
        return this;
    },
    /**
     * 停止动画
     * @param {boolean} forwardToLast If move to last frame before stop
     */
    stop: function (forwardToLast) {
        var clipList = this._clipList;
        var animation = this.animation;
        for (var i = 0; i < clipList.length; i++) {
            var clip = clipList[i];
            if (forwardToLast) {
                // Move to last frame before stop
                clip.onframe(this._target, 1);
            }
            animation && animation.removeClip(clip);
        }
        clipList.length = 0;
    },
    /**
     * 设置动画延迟开始的时间
     * @param  {number} time 单位ms
     * @return {module:zrender/animation/Animator}
     */
    delay: function (time) {
        this._delay = time;
        return this;
    },
    /**
     * 添加动画结束的回调
     * @param  {Function} cb
     * @return {module:zrender/animation/Animator}
     */
    done: function(cb) {
        if (cb) {
            this._doneList.push(cb);
        }
        return this;
    },

    /**
     * @return {Array.<module:zrender/animation/Clip>}
     */
    getClips: function () {
        return this._clipList;
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Animator);

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

/* harmony default export */ __webpack_exports__["a"] = ((
    typeof window !== 'undefined'
    && (
        (window.requestAnimationFrame && window.requestAnimationFrame.bind(window))
        // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
        || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))
        || window.mozRequestAnimationFrame
        || window.webkitRequestAnimationFrame
    )
) || function (func) {
    setTimeout(func, 16);
});

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return DEFAULT_FONT; });
/* unused harmony export $override */
/* harmony export (immutable) */ __webpack_exports__["f"] = getWidth;
/* harmony export (immutable) */ __webpack_exports__["a"] = getBoundingRect;
/* harmony export (immutable) */ __webpack_exports__["g"] = adjustTextX;
/* harmony export (immutable) */ __webpack_exports__["e"] = adjustTextY;
/* harmony export (immutable) */ __webpack_exports__["i"] = adjustTextPositionOnRect;
/* unused harmony export truncateText */
/* unused harmony export getLineHeight */
/* unused harmony export measureText */
/* harmony export (immutable) */ __webpack_exports__["d"] = parsePlainText;
/* harmony export (immutable) */ __webpack_exports__["h"] = parseRichText;
/* harmony export (immutable) */ __webpack_exports__["b"] = makeFont;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_BoundingRect__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__graphic_helper_image__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_util__ = __webpack_require__(0);




var textWidthCache = {};
var textWidthCacheCounter = 0;

var TEXT_CACHE_MAX = 5000;
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;

var DEFAULT_FONT = '12px sans-serif';

// Avoid assign to an exported variable, for transforming to cjs.
var methods = {};

function $override(name, fn) {
    methods[name] = fn;
}

/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {number} width
 */
function getWidth(text, font) {
    font = font || DEFAULT_FONT;
    var key = text + ':' + font;
    if (textWidthCache[key]) {
        return textWidthCache[key];
    }

    var textLines = (text + '').split('\n');
    var width = 0;

    for (var i = 0, l = textLines.length; i < l; i++) {
        // textContain.measureText may be overrided in SVG or VML
        width = Math.max(measureText(textLines[i], font).width, width);
    }

    if (textWidthCacheCounter > TEXT_CACHE_MAX) {
        textWidthCacheCounter = 0;
        textWidthCache = {};
    }
    textWidthCacheCounter++;
    textWidthCache[key] = width;

    return width;
}

/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {string} [textAlign='left']
 * @param {string} [textVerticalAlign='top']
 * @param {Array.<number>} [textPadding]
 * @param {Object} [rich]
 * @param {Object} [truncate]
 * @return {Object} {x, y, width, height, lineHeight}
 */
function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
    return rich
        ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate)
        : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);
}

function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {
    var contentBlock = parsePlainText(text, font, textPadding, truncate);
    var outerWidth = getWidth(text, font);
    if (textPadding) {
        outerWidth += textPadding[1] + textPadding[3];
    }
    var outerHeight = contentBlock.outerHeight;

    var x = adjustTextX(0, outerWidth, textAlign);
    var y = adjustTextY(0, outerHeight, textVerticalAlign);

    var rect = new __WEBPACK_IMPORTED_MODULE_0__core_BoundingRect__["a" /* default */](x, y, outerWidth, outerHeight);
    rect.lineHeight = contentBlock.lineHeight;

    return rect;
}

function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
    var contentBlock = parseRichText(text, {
        rich: rich,
        truncate: truncate,
        font: font,
        textAlign: textAlign,
        textPadding: textPadding
    });
    var outerWidth = contentBlock.outerWidth;
    var outerHeight = contentBlock.outerHeight;

    var x = adjustTextX(0, outerWidth, textAlign);
    var y = adjustTextY(0, outerHeight, textVerticalAlign);

    return new __WEBPACK_IMPORTED_MODULE_0__core_BoundingRect__["a" /* default */](x, y, outerWidth, outerHeight);
}

/**
 * @public
 * @param {number} x
 * @param {number} width
 * @param {string} [textAlign='left']
 * @return {number} Adjusted x.
 */
function adjustTextX(x, width, textAlign) {
    // FIXME Right to left language
    if (textAlign === 'right') {
        x -= width;
    }
    else if (textAlign === 'center') {
        x -= width / 2;
    }
    return x;
}

/**
 * @public
 * @param {number} y
 * @param {number} height
 * @param {string} [textVerticalAlign='top']
 * @return {number} Adjusted y.
 */
function adjustTextY(y, height, textVerticalAlign) {
    if (textVerticalAlign === 'middle') {
        y -= height / 2;
    }
    else if (textVerticalAlign === 'bottom') {
        y -= height;
    }
    return y;
}

/**
 * @public
 * @param {stirng} textPosition
 * @param {Object} rect {x, y, width, height}
 * @param {number} distance
 * @return {Object} {x, y, textAlign, textVerticalAlign}
 */
function adjustTextPositionOnRect(textPosition, rect, distance) {

    var x = rect.x;
    var y = rect.y;

    var height = rect.height;
    var width = rect.width;
    var halfHeight = height / 2;

    var textAlign = 'left';
    var textVerticalAlign = 'top';

    switch (textPosition) {
        case 'left':
            x -= distance;
            y += halfHeight;
            textAlign = 'right';
            textVerticalAlign = 'middle';
            break;
        case 'right':
            x += distance + width;
            y += halfHeight;
            textVerticalAlign = 'middle';
            break;
        case 'top':
            x += width / 2;
            y -= distance;
            textAlign = 'center';
            textVerticalAlign = 'bottom';
            break;
        case 'bottom':
            x += width / 2;
            y += height + distance;
            textAlign = 'center';
            break;
        case 'inside':
            x += width / 2;
            y += halfHeight;
            textAlign = 'center';
            textVerticalAlign = 'middle';
            break;
        case 'insideLeft':
            x += distance;
            y += halfHeight;
            textVerticalAlign = 'middle';
            break;
        case 'insideRight':
            x += width - distance;
            y += halfHeight;
            textAlign = 'right';
            textVerticalAlign = 'middle';
            break;
        case 'insideTop':
            x += width / 2;
            y += distance;
            textAlign = 'center';
            break;
        case 'insideBottom':
            x += width / 2;
            y += height - distance;
            textAlign = 'center';
            textVerticalAlign = 'bottom';
            break;
        case 'insideTopLeft':
            x += distance;
            y += distance;
            break;
        case 'insideTopRight':
            x += width - distance;
            y += distance;
            textAlign = 'right';
            break;
        case 'insideBottomLeft':
            x += distance;
            y += height - distance;
            textVerticalAlign = 'bottom';
            break;
        case 'insideBottomRight':
            x += width - distance;
            y += height - distance;
            textAlign = 'right';
            textVerticalAlign = 'bottom';
            break;
    }

    return {
        x: x,
        y: y,
        textAlign: textAlign,
        textVerticalAlign: textVerticalAlign
    };
}

/**
 * Show ellipsis if overflow.
 *
 * @public
 * @param  {string} text
 * @param  {string} containerWidth
 * @param  {string} font
 * @param  {number} [ellipsis='...']
 * @param  {Object} [options]
 * @param  {number} [options.maxIterations=3]
 * @param  {number} [options.minChar=0] If truncate result are less
 *                  then minChar, ellipsis will not show, which is
 *                  better for user hint in some cases.
 * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
 * @return {string}
 */
function truncateText(text, containerWidth, font, ellipsis, options) {
    if (!containerWidth) {
        return '';
    }

    var textLines = (text + '').split('\n');
    options = prepareTruncateOptions(containerWidth, font, ellipsis, options);

    // FIXME
    // It is not appropriate that every line has '...' when truncate multiple lines.
    for (var i = 0, len = textLines.length; i < len; i++) {
        textLines[i] = truncateSingleLine(textLines[i], options);
    }

    return textLines.join('\n');
}

function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
    options = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["h" /* extend */])({}, options);

    options.font = font;
    var ellipsis = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["e" /* retrieve2 */])(ellipsis, '...');
    options.maxIterations = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["e" /* retrieve2 */])(options.maxIterations, 2);
    var minChar = options.minChar = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["e" /* retrieve2 */])(options.minChar, 0);
    // FIXME
    // Other languages?
    options.cnCharWidth = getWidth('国', font);
    // FIXME
    // Consider proportional font?
    var ascCharWidth = options.ascCharWidth = getWidth('a', font);
    options.placeholder = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["e" /* retrieve2 */])(options.placeholder, '');

    // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
    // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
    var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.
    for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
        contentWidth -= ascCharWidth;
    }

    var ellipsisWidth = getWidth(ellipsis);
    if (ellipsisWidth > contentWidth) {
        ellipsis = '';
        ellipsisWidth = 0;
    }

    contentWidth = containerWidth - ellipsisWidth;

    options.ellipsis = ellipsis;
    options.ellipsisWidth = ellipsisWidth;
    options.contentWidth = contentWidth;
    options.containerWidth = containerWidth;

    return options;
}

function truncateSingleLine(textLine, options) {
    var containerWidth = options.containerWidth;
    var font = options.font;
    var contentWidth = options.contentWidth;

    if (!containerWidth) {
        return '';
    }

    var lineWidth = getWidth(textLine, font);

    if (lineWidth <= containerWidth) {
        return textLine;
    }

    for (var j = 0;; j++) {
        if (lineWidth <= contentWidth || j >= options.maxIterations) {
            textLine += options.ellipsis;
            break;
        }

        var subLength = j === 0
            ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth)
            : lineWidth > 0
            ? Math.floor(textLine.length * contentWidth / lineWidth)
            : 0;

        textLine = textLine.substr(0, subLength);
        lineWidth = getWidth(textLine, font);
    }

    if (textLine === '') {
        textLine = options.placeholder;
    }

    return textLine;
}

function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
    var width = 0;
    var i = 0;
    for (var len = text.length; i < len && width < contentWidth; i++) {
        var charCode = text.charCodeAt(i);
        width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;
    }
    return i;
}

/**
 * @public
 * @param {string} font
 * @return {number} line height
 */
function getLineHeight(font) {
    // FIXME A rough approach.
    return getWidth('国', font);
}

/**
 * @public
 * @param {string} text
 * @param {string} font
 * @return {Object} width
 */
function measureText(text, font) {
    return methods.measureText(text, font);
}

// Avoid assign to an exported variable, for transforming to cjs.
methods.measureText = function (text, font) {
    var ctx = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["i" /* getContext */])();
    ctx.font = font || DEFAULT_FONT;
    return ctx.measureText(text);
};

/**
 * @public
 * @param {string} text
 * @param {string} font
 * @param {Object} [truncate]
 * @return {Object} block: {lineHeight, lines, height, outerHeight}
 *  Notice: for performance, do not calculate outerWidth util needed.
 */
function parsePlainText(text, font, padding, truncate) {
    text != null && (text += '');

    var lineHeight = getLineHeight(font);
    var lines = text ? text.split('\n') : [];
    var height = lines.length * lineHeight;
    var outerHeight = height;

    if (padding) {
        outerHeight += padding[0] + padding[2];
    }

    if (text && truncate) {
        var truncOuterHeight = truncate.outerHeight;
        var truncOuterWidth = truncate.outerWidth;
        if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
            text = '';
            lines = [];
        }
        else if (truncOuterWidth != null) {
            var options = prepareTruncateOptions(
                truncOuterWidth - (padding ? padding[1] + padding[3] : 0),
                font,
                truncate.ellipsis,
                {minChar: truncate.minChar, placeholder: truncate.placeholder}
            );

            // FIXME
            // It is not appropriate that every line has '...' when truncate multiple lines.
            for (var i = 0, len = lines.length; i < len; i++) {
                lines[i] = truncateSingleLine(lines[i], options);
            }
        }
    }

    return {
        lines: lines,
        height: height,
        outerHeight: outerHeight,
        lineHeight: lineHeight
    };
}

/**
 * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
 * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
 *
 * @public
 * @param {string} text
 * @param {Object} style
 * @return {Object} block
 * {
 *      width,
 *      height,
 *      lines: [{
 *          lineHeight,
 *          width,
 *          tokens: [[{
 *              styleName,
 *              text,
 *              width,      // include textPadding
 *              height,     // include textPadding
 *              textWidth, // pure text width
 *              textHeight, // pure text height
 *              lineHeihgt,
 *              font,
 *              textAlign,
 *              textVerticalAlign
 *          }], [...], ...]
 *      }, ...]
 * }
 * If styleName is undefined, it is plain text.
 */
function parseRichText(text, style) {
    var contentBlock = {lines: [], width: 0, height: 0};

    text != null && (text += '');
    if (!text) {
        return contentBlock;
    }

    var lastIndex = STYLE_REG.lastIndex = 0;
    var result;
    while ((result = STYLE_REG.exec(text)) != null) {
        var matchedIndex = result.index;
        if (matchedIndex > lastIndex) {
            pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
        }
        pushTokens(contentBlock, result[2], result[1]);
        lastIndex = STYLE_REG.lastIndex;
    }

    if (lastIndex < text.length) {
        pushTokens(contentBlock, text.substring(lastIndex, text.length));
    }

    var lines = contentBlock.lines;
    var contentHeight = 0;
    var contentWidth = 0;
    // For `textWidth: 100%`
    var pendingList = [];

    var stlPadding = style.textPadding;

    var truncate = style.truncate;
    var truncateWidth = truncate && truncate.outerWidth;
    var truncateHeight = truncate && truncate.outerHeight;
    if (stlPadding) {
        truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
        truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
    }

    // Calculate layout info of tokens.
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        var lineHeight = 0;
        var lineWidth = 0;

        for (var j = 0; j < line.tokens.length; j++) {
            var token = line.tokens[j];
            var tokenStyle = token.styleName && style.rich[token.styleName] || {};
            // textPadding should not inherit from style.
            var textPadding = token.textPadding = tokenStyle.textPadding;

            // textFont has been asigned to font by `normalizeStyle`.
            var font = token.font = tokenStyle.font || style.font;

            // textHeight can be used when textVerticalAlign is specified in token.
            var tokenHeight = token.textHeight = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["e" /* retrieve2 */])(
                // textHeight should not be inherited, consider it can be specified
                // as box height of the block.
                tokenStyle.textHeight, getLineHeight(font)
            );
            textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
            token.height = tokenHeight;
            token.lineHeight = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["d" /* retrieve3 */])(
                tokenStyle.textLineHeight, style.textLineHeight, tokenHeight
            );

            token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
            token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';

            if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
                return {lines: [], width: 0, height: 0};
            }

            token.textWidth = getWidth(token.text, font);
            var tokenWidth = tokenStyle.textWidth;
            var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto';

            // Percent width, can be `100%`, can be used in drawing separate
            // line when box width is needed to be auto.
            if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
                token.percentWidth = tokenWidth;
                pendingList.push(token);
                tokenWidth = 0;
                // Do not truncate in this case, because there is no user case
                // and it is too complicated.
            }
            else {
                if (tokenWidthNotSpecified) {
                    tokenWidth = token.textWidth;

                    // FIXME: If image is not loaded and textWidth is not specified, calling
                    // `getBoundingRect()` will not get correct result.
                    var textBackgroundColor = tokenStyle.textBackgroundColor;
                    var bgImg = textBackgroundColor && textBackgroundColor.image;

                    // Use cases:
                    // (1) If image is not loaded, it will be loaded at render phase and call
                    // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
                    // image, and then the right size will be calculated here at the next tick.
                    // See `graphic/helper/text.js`.
                    // (2) If image loaded, and `textBackgroundColor.image` is image src string,
                    // use `imageHelper.findExistImage` to find cached image.
                    // `imageHelper.findExistImage` will always be called here before
                    // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
                    // which ensures that image will not be rendered before correct size calcualted.
                    if (bgImg) {
                        bgImg = __WEBPACK_IMPORTED_MODULE_1__graphic_helper_image__["c" /* findExistImage */](bgImg);
                        if (__WEBPACK_IMPORTED_MODULE_1__graphic_helper_image__["b" /* isImageReady */](bgImg)) {
                            tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
                        }
                    }
                }

                var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
                tokenWidth += paddingW;

                var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;

                if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
                    if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
                        token.text = '';
                        token.textWidth = tokenWidth = 0;
                    }
                    else {
                        token.text = truncateText(
                            token.text, remianTruncWidth - paddingW, font, truncate.ellipsis,
                            {minChar: truncate.minChar}
                        );
                        token.textWidth = getWidth(token.text, font);
                        tokenWidth = token.textWidth + paddingW;
                    }
                }
            }

            lineWidth += (token.width = tokenWidth);
            tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
        }

        line.width = lineWidth;
        line.lineHeight = lineHeight;
        contentHeight += lineHeight;
        contentWidth = Math.max(contentWidth, lineWidth);
    }

    contentBlock.outerWidth = contentBlock.width = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["e" /* retrieve2 */])(style.textWidth, contentWidth);
    contentBlock.outerHeight = contentBlock.height = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["e" /* retrieve2 */])(style.textHeight, contentHeight);

    if (stlPadding) {
        contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
        contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
    }

    for (var i = 0; i < pendingList.length; i++) {
        var token = pendingList[i];
        var percentWidth = token.percentWidth;
        // Should not base on outerWidth, because token can not be placed out of padding.
        token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
    }

    return contentBlock;
}

function pushTokens(block, str, styleName) {
    var isEmptyStr = str === '';
    var strs = str.split('\n');
    var lines = block.lines;

    for (var i = 0; i < strs.length; i++) {
        var text = strs[i];
        var token = {
            styleName: styleName,
            text: text,
            isLineHolder: !text && !isEmptyStr
        };

        // The first token should be appended to the last line.
        if (!i) {
            var tokens = (lines[lines.length - 1] || (lines[0] = {tokens: []})).tokens;

            // Consider cases:
            // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
            // (which is a placeholder) should be replaced by new token.
            // (2) A image backage, where token likes {a|}.
            // (3) A redundant '' will affect textAlign in line.
            // (4) tokens with the same tplName should not be merged, because
            // they should be displayed in different box (with border and padding).
            var tokensLen = tokens.length;
            (tokensLen === 1 && tokens[0].isLineHolder)
                ? (tokens[0] = token)
                // Consider text is '', only insert when it is the "lineHolder" or
                // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
                : ((text || !tokensLen || isEmptyStr) && tokens.push(token));
        }
        // Other tokens always start a new line.
        else {
            // If there is '', insert it as a placeholder.
            lines.push({tokens: [token]});
        }
    }
}

function makeFont(style) {
    // FIXME in node-canvas fontWeight is before fontStyle
    // Use `fontSize` `fontFamily` to check whether font properties are defined.
    return (style.fontSize || style.fontFamily) && [
        style.fontStyle,
        style.fontWeight,
        (style.fontSize || 12) + 'px',
        // If font properties are defined, `fontFamily` should not be ignored.
        style.fontFamily || 'sans-serif'
    ].join(' ') || style.textFont || style.font;
}


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = normalizeRadian;

var PI2 = Math.PI * 2;

function normalizeRadian(angle) {
    angle %= PI2;
    if (angle < 0) {
        angle += PI2;
    }
    return angle;
}

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Simple LRU cache use doubly linked list
// @module zrender/core/LRU

/**
 * Simple double linked list. Compared with array, it has O(1) remove operation.
 * @constructor
 */
var LinkedList = function () {

    /**
     * @type {module:zrender/core/LRU~Entry}
     */
    this.head = null;

    /**
     * @type {module:zrender/core/LRU~Entry}
     */
    this.tail = null;

    this._len = 0;
};

var linkedListProto = LinkedList.prototype;
/**
 * Insert a new value at the tail
 * @param  {} val
 * @return {module:zrender/core/LRU~Entry}
 */
linkedListProto.insert = function (val) {
    var entry = new Entry(val);
    this.insertEntry(entry);
    return entry;
};

/**
 * Insert an entry at the tail
 * @param  {module:zrender/core/LRU~Entry} entry
 */
linkedListProto.insertEntry = function (entry) {
    if (!this.head) {
        this.head = this.tail = entry;
    }
    else {
        this.tail.next = entry;
        entry.prev = this.tail;
        entry.next = null;
        this.tail = entry;
    }
    this._len++;
};

/**
 * Remove entry.
 * @param  {module:zrender/core/LRU~Entry} entry
 */
linkedListProto.remove = function (entry) {
    var prev = entry.prev;
    var next = entry.next;
    if (prev) {
        prev.next = next;
    }
    else {
        // Is head
        this.head = next;
    }
    if (next) {
        next.prev = prev;
    }
    else {
        // Is tail
        this.tail = prev;
    }
    entry.next = entry.prev = null;
    this._len--;
};

/**
 * @return {number}
 */
linkedListProto.len = function () {
    return this._len;
};

/**
 * Clear list
 */
linkedListProto.clear = function () {
    this.head = this.tail = null;
    this._len = 0;
};

/**
 * @constructor
 * @param {} val
 */
var Entry = function (val) {
    /**
     * @type {}
     */
    this.value = val;

    /**
     * @type {module:zrender/core/LRU~Entry}
     */
    this.next;

    /**
     * @type {module:zrender/core/LRU~Entry}
     */
    this.prev;
};

/**
 * LRU Cache
 * @constructor
 * @alias module:zrender/core/LRU
 */
var LRU = function (maxSize) {

    this._list = new LinkedList();

    this._map = {};

    this._maxSize = maxSize || 10;

    this._lastRemovedEntry = null;
};

var LRUProto = LRU.prototype;

/**
 * @param  {string} key
 * @param  {} value
 * @return {} Removed value
 */
LRUProto.put = function (key, value) {
    var list = this._list;
    var map = this._map;
    var removed = null;
    if (map[key] == null) {
        var len = list.len();
        // Reuse last removed entry
        var entry = this._lastRemovedEntry;

        if (len >= this._maxSize && len > 0) {
            // Remove the least recently used
            var leastUsedEntry = list.head;
            list.remove(leastUsedEntry);
            delete map[leastUsedEntry.key];

            removed = leastUsedEntry.value;
            this._lastRemovedEntry = leastUsedEntry;
        }

        if (entry) {
            entry.value = value;
        }
        else {
            entry = new Entry(value);
        }
        entry.key = key;
        list.insertEntry(entry);
        map[key] = entry;
    }

    return removed;
};

/**
 * @param  {string} key
 * @return {}
 */
LRUProto.get = function (key) {
    var entry = this._map[key];
    var list = this._list;
    if (entry != null) {
        // Put the latest used entry in the tail
        if (entry !== list.tail) {
            list.remove(entry);
            list.insertEntry(entry);
        }

        return entry.value;
    }
};

/**
 * Clear the cache
 */
LRUProto.clear = function () {
    this._list.clear();
    this._map = {};
};

/* harmony default export */ __webpack_exports__["a"] = (LRU);

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__curve__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vector__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__bbox__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__BoundingRect__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config__ = __webpack_require__(4);
/**
 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
 * 可以用于 isInsidePath 判断以及获取boundingRect
 *
 * @module zrender/core/PathProxy
 * @author Yi Shen (http://www.github.com/pissang)
 */

// TODO getTotalLength, getPointAtLength







var CMD = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,
    // Rect
    R: 7
};

// var CMD_MEM_SIZE = {
//     M: 3,
//     L: 3,
//     C: 7,
//     Q: 5,
//     A: 9,
//     R: 5,
//     Z: 1
// };

var min = [];
var max = [];
var min2 = [];
var max2 = [];
var mathMin = Math.min;
var mathMax = Math.max;
var mathCos = Math.cos;
var mathSin = Math.sin;
var mathSqrt = Math.sqrt;
var mathAbs = Math.abs;

var hasTypedArray = typeof Float32Array != 'undefined';

/**
 * @alias module:zrender/core/PathProxy
 * @constructor
 */
var PathProxy = function (notSaveData) {

    this._saveData = !(notSaveData || false);

    if (this._saveData) {
        /**
         * Path data. Stored as flat array
         * @type {Array.<Object>}
         */
        this.data = [];
    }

    this._ctx = null;
};

/**
 * 快速计算Path包围盒（并不是最小包围盒）
 * @return {Object}
 */
PathProxy.prototype = {

    constructor: PathProxy,

    _xi: 0,
    _yi: 0,

    _x0: 0,
    _y0: 0,
    // Unit x, Unit y. Provide for avoiding drawing that too short line segment
    _ux: 0,
    _uy: 0,

    _len: 0,

    _lineDash: null,

    _dashOffset: 0,

    _dashIdx: 0,

    _dashSum: 0,

    /**
     * @readOnly
     */
    setScale: function (sx, sy) {
        this._ux = mathAbs(1 / __WEBPACK_IMPORTED_MODULE_4__config__["b" /* devicePixelRatio */] / sx) || 0;
        this._uy = mathAbs(1 / __WEBPACK_IMPORTED_MODULE_4__config__["b" /* devicePixelRatio */] / sy) || 0;
    },

    getContext: function () {
        return this._ctx;
    },

    /**
     * @param  {CanvasRenderingContext2D} ctx
     * @return {module:zrender/core/PathProxy}
     */
    beginPath: function (ctx) {

        this._ctx = ctx;

        ctx && ctx.beginPath();

        ctx && (this.dpr = ctx.dpr);

        // Reset
        if (this._saveData) {
            this._len = 0;
        }

        if (this._lineDash) {
            this._lineDash = null;

            this._dashOffset = 0;
        }

        return this;
    },

    /**
     * @param  {number} x
     * @param  {number} y
     * @return {module:zrender/core/PathProxy}
     */
    moveTo: function (x, y) {
        this.addData(CMD.M, x, y);
        this._ctx && this._ctx.moveTo(x, y);

        // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
        // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
        // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
        // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
        this._x0 = x;
        this._y0 = y;

        this._xi = x;
        this._yi = y;

        return this;
    },

    /**
     * @param  {number} x
     * @param  {number} y
     * @return {module:zrender/core/PathProxy}
     */
    lineTo: function (x, y) {
        var exceedUnit = mathAbs(x - this._xi) > this._ux
            || mathAbs(y - this._yi) > this._uy
            // Force draw the first segment
            || this._len < 5;

        this.addData(CMD.L, x, y);

        if (this._ctx && exceedUnit) {
            this._needsDash() ? this._dashedLineTo(x, y)
                : this._ctx.lineTo(x, y);
        }
        if (exceedUnit) {
            this._xi = x;
            this._yi = y;
        }

        return this;
    },

    /**
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} x2
     * @param  {number} y2
     * @param  {number} x3
     * @param  {number} y3
     * @return {module:zrender/core/PathProxy}
     */
    bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
        this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
        if (this._ctx) {
            this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)
                : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        }
        this._xi = x3;
        this._yi = y3;
        return this;
    },

    /**
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} x2
     * @param  {number} y2
     * @return {module:zrender/core/PathProxy}
     */
    quadraticCurveTo: function (x1, y1, x2, y2) {
        this.addData(CMD.Q, x1, y1, x2, y2);
        if (this._ctx) {
            this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)
                : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
        }
        this._xi = x2;
        this._yi = y2;
        return this;
    },

    /**
     * @param  {number} cx
     * @param  {number} cy
     * @param  {number} r
     * @param  {number} startAngle
     * @param  {number} endAngle
     * @param  {boolean} anticlockwise
     * @return {module:zrender/core/PathProxy}
     */
    arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
        this.addData(
            CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1
        );
        this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);

        this._xi = mathCos(endAngle) * r + cx;
        this._yi = mathSin(endAngle) * r + cx;
        return this;
    },

    // TODO
    arcTo: function (x1, y1, x2, y2, radius) {
        if (this._ctx) {
            this._ctx.arcTo(x1, y1, x2, y2, radius);
        }
        return this;
    },

    // TODO
    rect: function (x, y, w, h) {
        this._ctx && this._ctx.rect(x, y, w, h);
        this.addData(CMD.R, x, y, w, h);
        return this;
    },

    /**
     * @return {module:zrender/core/PathProxy}
     */
    closePath: function () {
        this.addData(CMD.Z);

        var ctx = this._ctx;
        var x0 = this._x0;
        var y0 = this._y0;
        if (ctx) {
            this._needsDash() && this._dashedLineTo(x0, y0);
            ctx.closePath();
        }

        this._xi = x0;
        this._yi = y0;
        return this;
    },

    /**
     * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
     * stroke 同样
     * @param {CanvasRenderingContext2D} ctx
     * @return {module:zrender/core/PathProxy}
     */
    fill: function (ctx) {
        ctx && ctx.fill();
        this.toStatic();
    },

    /**
     * @param {CanvasRenderingContext2D} ctx
     * @return {module:zrender/core/PathProxy}
     */
    stroke: function (ctx) {
        ctx && ctx.stroke();
        this.toStatic();
    },

    /**
     * 必须在其它绘制命令前调用
     * Must be invoked before all other path drawing methods
     * @return {module:zrender/core/PathProxy}
     */
    setLineDash: function (lineDash) {
        if (lineDash instanceof Array) {
            this._lineDash = lineDash;

            this._dashIdx = 0;

            var lineDashSum = 0;
            for (var i = 0; i < lineDash.length; i++) {
                lineDashSum += lineDash[i];
            }
            this._dashSum = lineDashSum;
        }
        return this;
    },

    /**
     * 必须在其它绘制命令前调用
     * Must be invoked before all other path drawing methods
     * @return {module:zrender/core/PathProxy}
     */
    setLineDashOffset: function (offset) {
        this._dashOffset = offset;
        return this;
    },

    /**
     *
     * @return {boolean}
     */
    len: function () {
        return this._len;
    },

    /**
     * 直接设置 Path 数据
     */
    setData: function (data) {

        var len = data.length;

        if (! (this.data && this.data.length == len) && hasTypedArray) {
            this.data = new Float32Array(len);
        }

        for (var i = 0; i < len; i++) {
            this.data[i] = data[i];
        }

        this._len = len;
    },

    /**
     * 添加子路径
     * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
     */
    appendPath: function (path) {
        if (!(path instanceof Array)) {
            path = [path];
        }
        var len = path.length;
        var appendSize = 0;
        var offset = this._len;
        for (var i = 0; i < len; i++) {
            appendSize += path[i].len();
        }
        if (hasTypedArray && (this.data instanceof Float32Array)) {
            this.data = new Float32Array(offset + appendSize);
        }
        for (var i = 0; i < len; i++) {
            var appendPathData = path[i].data;
            for (var k = 0; k < appendPathData.length; k++) {
                this.data[offset++] = appendPathData[k];
            }
        }
        this._len = offset;
    },

    /**
     * 填充 Path 数据。
     * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
     */
    addData: function (cmd) {
        if (!this._saveData) {
            return;
        }

        var data = this.data;
        if (this._len + arguments.length > data.length) {
            // 因为之前的数组已经转换成静态的 Float32Array
            // 所以不够用时需要扩展一个新的动态数组
            this._expandData();
            data = this.data;
        }
        for (var i = 0; i < arguments.length; i++) {
            data[this._len++] = arguments[i];
        }

        this._prevCmd = cmd;
    },

    _expandData: function () {
        // Only if data is Float32Array
        if (!(this.data instanceof Array)) {
            var newData = [];
            for (var i = 0; i < this._len; i++) {
                newData[i] = this.data[i];
            }
            this.data = newData;
        }
    },

    /**
     * If needs js implemented dashed line
     * @return {boolean}
     * @private
     */
    _needsDash: function () {
        return this._lineDash;
    },

    _dashedLineTo: function (x1, y1) {
        var dashSum = this._dashSum;
        var offset = this._dashOffset;
        var lineDash = this._lineDash;
        var ctx = this._ctx;

        var x0 = this._xi;
        var y0 = this._yi;
        var dx = x1 - x0;
        var dy = y1 - y0;
        var dist = mathSqrt(dx * dx + dy * dy);
        var x = x0;
        var y = y0;
        var dash;
        var nDash = lineDash.length;
        var idx;
        dx /= dist;
        dy /= dist;

        if (offset < 0) {
            // Convert to positive offset
            offset = dashSum + offset;
        }
        offset %= dashSum;
        x -= offset * dx;
        y -= offset * dy;

        while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)
        || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {
            idx = this._dashIdx;
            dash = lineDash[idx];
            x += dx * dash;
            y += dy * dash;
            this._dashIdx = (idx + 1) % nDash;
            // Skip positive offset
            if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {
                continue;
            }
            ctx[idx % 2 ? 'moveTo' : 'lineTo'](
                dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),
                dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)
            );
        }
        // Offset for next lineTo
        dx = x - x1;
        dy = y - y1;
        this._dashOffset = -mathSqrt(dx * dx + dy * dy);
    },

    // Not accurate dashed line to
    _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
        var dashSum = this._dashSum;
        var offset = this._dashOffset;
        var lineDash = this._lineDash;
        var ctx = this._ctx;

        var x0 = this._xi;
        var y0 = this._yi;
        var t;
        var dx;
        var dy;
        var cubicAt = __WEBPACK_IMPORTED_MODULE_0__curve__["b" /* cubicAt */];
        var bezierLen = 0;
        var idx = this._dashIdx;
        var nDash = lineDash.length;

        var x;
        var y;

        var tmpLen = 0;

        if (offset < 0) {
            // Convert to positive offset
            offset = dashSum + offset;
        }
        offset %= dashSum;
        // Bezier approx length
        for (t = 0; t < 1; t += 0.1) {
            dx = cubicAt(x0, x1, x2, x3, t + 0.1)
                - cubicAt(x0, x1, x2, x3, t);
            dy = cubicAt(y0, y1, y2, y3, t + 0.1)
                - cubicAt(y0, y1, y2, y3, t);
            bezierLen += mathSqrt(dx * dx + dy * dy);
        }

        // Find idx after add offset
        for (; idx < nDash; idx++) {
            tmpLen += lineDash[idx];
            if (tmpLen > offset) {
                break;
            }
        }
        t = (tmpLen - offset) / bezierLen;

        while (t <= 1) {

            x = cubicAt(x0, x1, x2, x3, t);
            y = cubicAt(y0, y1, y2, y3, t);

            // Use line to approximate dashed bezier
            // Bad result if dash is long
            idx % 2 ? ctx.moveTo(x, y)
                : ctx.lineTo(x, y);

            t += lineDash[idx] / bezierLen;

            idx = (idx + 1) % nDash;
        }

        // Finish the last segment and calculate the new offset
        (idx % 2 !== 0) && ctx.lineTo(x3, y3);
        dx = x3 - x;
        dy = y3 - y;
        this._dashOffset = -mathSqrt(dx * dx + dy * dy);
    },

    _dashedQuadraticTo: function (x1, y1, x2, y2) {
        // Convert quadratic to cubic using degree elevation
        var x3 = x2;
        var y3 = y2;
        x2 = (x2 + 2 * x1) / 3;
        y2 = (y2 + 2 * y1) / 3;
        x1 = (this._xi + 2 * x1) / 3;
        y1 = (this._yi + 2 * y1) / 3;

        this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
    },

    /**
     * 转成静态的 Float32Array 减少堆内存占用
     * Convert dynamic array to static Float32Array
     */
    toStatic: function () {
        var data = this.data;
        if (data instanceof Array) {
            data.length = this._len;
            if (hasTypedArray) {
                this.data = new Float32Array(data);
            }
        }
    },

    /**
     * @return {module:zrender/core/BoundingRect}
     */
    getBoundingRect: function () {
        min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
        max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;

        var data = this.data;
        var xi = 0;
        var yi = 0;
        var x0 = 0;
        var y0 = 0;

        for (var i = 0; i < data.length;) {
            var cmd = data[i++];

            if (i == 1) {
                // 如果第一个命令是 L, C, Q
                // 则 previous point 同绘制命令的第一个 point
                //
                // 第一个命令为 Arc 的情况下会在后面特殊处理
                xi = data[i];
                yi = data[i + 1];

                x0 = xi;
                y0 = yi;
            }

            switch (cmd) {
                case CMD.M:
                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
                    // 在 closePath 的时候使用
                    x0 = data[i++];
                    y0 = data[i++];
                    xi = x0;
                    yi = y0;
                    min2[0] = x0;
                    min2[1] = y0;
                    max2[0] = x0;
                    max2[1] = y0;
                    break;
                case CMD.L:
                    __WEBPACK_IMPORTED_MODULE_2__bbox__["a" /* fromLine */](xi, yi, data[i], data[i + 1], min2, max2);
                    xi = data[i++];
                    yi = data[i++];
                    break;
                case CMD.C:
                    __WEBPACK_IMPORTED_MODULE_2__bbox__["b" /* fromCubic */](
                        xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
                        min2, max2
                    );
                    xi = data[i++];
                    yi = data[i++];
                    break;
                case CMD.Q:
                    __WEBPACK_IMPORTED_MODULE_2__bbox__["c" /* fromQuadratic */](
                        xi, yi, data[i++], data[i++], data[i], data[i + 1],
                        min2, max2
                    );
                    xi = data[i++];
                    yi = data[i++];
                    break;
                case CMD.A:
                    // TODO Arc 判断的开销比较大
                    var cx = data[i++];
                    var cy = data[i++];
                    var rx = data[i++];
                    var ry = data[i++];
                    var startAngle = data[i++];
                    var endAngle = data[i++] + startAngle;
                    // TODO Arc 旋转
                    var psi = data[i++];
                    var anticlockwise = 1 - data[i++];

                    if (i == 1) {
                        // 直接使用 arc 命令
                        // 第一个命令起点还未定义
                        x0 = mathCos(startAngle) * rx + cx;
                        y0 = mathSin(startAngle) * ry + cy;
                    }

                    __WEBPACK_IMPORTED_MODULE_2__bbox__["d" /* fromArc */](
                        cx, cy, rx, ry, startAngle, endAngle,
                        anticlockwise, min2, max2
                    );

                    xi = mathCos(endAngle) * rx + cx;
                    yi = mathSin(endAngle) * ry + cy;
                    break;
                case CMD.R:
                    x0 = xi = data[i++];
                    y0 = yi = data[i++];
                    var width = data[i++];
                    var height = data[i++];
                    // Use fromLine
                    __WEBPACK_IMPORTED_MODULE_2__bbox__["a" /* fromLine */](x0, y0, x0 + width, y0 + height, min2, max2);
                    break;
                case CMD.Z:
                    xi = x0;
                    yi = y0;
                    break;
            }

            // Union
            __WEBPACK_IMPORTED_MODULE_1__vector__["d" /* min */](min, min, min2);
            __WEBPACK_IMPORTED_MODULE_1__vector__["e" /* max */](max, max, max2);
        }

        // No data
        if (i === 0) {
            min[0] = min[1] = max[0] = max[1] = 0;
        }

        return new __WEBPACK_IMPORTED_MODULE_3__BoundingRect__["a" /* default */](
            min[0], min[1], max[0] - min[0], max[1] - min[1]
        );
    },

    /**
     * Rebuild path from current data
     * Rebuild path will not consider javascript implemented line dash.
     * @param {CanvasRenderingContext2D} ctx
     */
    rebuildPath: function (ctx) {
        var d = this.data;
        var x0, y0;
        var xi, yi;
        var x, y;
        var ux = this._ux;
        var uy = this._uy;
        var len = this._len;
        for (var i = 0; i < len;) {
            var cmd = d[i++];

            if (i == 1) {
                // 如果第一个命令是 L, C, Q
                // 则 previous point 同绘制命令的第一个 point
                //
                // 第一个命令为 Arc 的情况下会在后面特殊处理
                xi = d[i];
                yi = d[i + 1];

                x0 = xi;
                y0 = yi;
            }
            switch (cmd) {
                case CMD.M:
                    x0 = xi = d[i++];
                    y0 = yi = d[i++];
                    ctx.moveTo(xi, yi);
                    break;
                case CMD.L:
                    x = d[i++];
                    y = d[i++];
                    // Not draw too small seg between
                    if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
                        ctx.lineTo(x, y);
                        xi = x;
                        yi = y;
                    }
                    break;
                case CMD.C:
                    ctx.bezierCurveTo(
                        d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]
                    );
                    xi = d[i - 2];
                    yi = d[i - 1];
                    break;
                case CMD.Q:
                    ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
                    xi = d[i - 2];
                    yi = d[i - 1];
                    break;
                case CMD.A:
                    var cx = d[i++];
                    var cy = d[i++];
                    var rx = d[i++];
                    var ry = d[i++];
                    var theta = d[i++];
                    var dTheta = d[i++];
                    var psi = d[i++];
                    var fs = d[i++];
                    var r = (rx > ry) ? rx : ry;
                    var scaleX = (rx > ry) ? 1 : rx / ry;
                    var scaleY = (rx > ry) ? ry / rx : 1;
                    var isEllipse = Math.abs(rx - ry) > 1e-3;
                    var endAngle = theta + dTheta;
                    if (isEllipse) {
                        ctx.translate(cx, cy);
                        ctx.rotate(psi);
                        ctx.scale(scaleX, scaleY);
                        ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
                        ctx.scale(1 / scaleX, 1 / scaleY);
                        ctx.rotate(-psi);
                        ctx.translate(-cx, -cy);
                    }
                    else {
                        ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
                    }

                    if (i == 1) {
                        // 直接使用 arc 命令
                        // 第一个命令起点还未定义
                        x0 = mathCos(theta) * rx + cx;
                        y0 = mathSin(theta) * ry + cy;
                    }
                    xi = mathCos(endAngle) * rx + cx;
                    yi = mathSin(endAngle) * ry + cy;
                    break;
                case CMD.R:
                    x0 = xi = d[i];
                    y0 = yi = d[i + 1];
                    ctx.rect(d[i++], d[i++], d[i++], d[i++]);
                    break;
                case CMD.Z:
                    ctx.closePath();
                    xi = x0;
                    yi = y0;
            }
        }
    }
};

PathProxy.CMD = CMD;

/* harmony default export */ __webpack_exports__["a"] = (PathProxy);

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * zrender: 生成唯一id
 *
 * @author errorrik (errorrik@gmail.com)
 */

var idStart = 0x0907;

/* harmony default export */ __webpack_exports__["a"] = (function () {
    return idStart++;
});

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(4);


var log = function () {
};

if (__WEBPACK_IMPORTED_MODULE_0__config__["a" /* debugMode */] === 1) {
    log = function () {
        for (var k in arguments) {
            throw new Error(arguments[k]);
        }
    };
}
else if (__WEBPACK_IMPORTED_MODULE_0__config__["a" /* debugMode */] > 1) {
    log = function () {
        for (var k in arguments) {
            console.log(arguments[k]);
        }
    };
}

/* harmony default export */ __webpack_exports__["a"] = (log);

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = create;
/* harmony export (immutable) */ __webpack_exports__["d"] = identity;
/* harmony export (immutable) */ __webpack_exports__["f"] = copy;
/* harmony export (immutable) */ __webpack_exports__["e"] = mul;
/* harmony export (immutable) */ __webpack_exports__["b"] = translate;
/* harmony export (immutable) */ __webpack_exports__["h"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["c"] = scale;
/* harmony export (immutable) */ __webpack_exports__["g"] = invert;
/**
 * 3x2矩阵操作类
 * @exports zrender/tool/matrix
 */

var ArrayCtor = typeof Float32Array === 'undefined'
    ? Array
   : Float32Array;

/**
 * 创建一个单位矩阵
 * @return {Float32Array|Array.<number>}
 */
function create() {
    var out = new ArrayCtor(6);
    identity(out);

    return out;
}

/**
 * 设置矩阵为单位矩阵
 * @param {Float32Array|Array.<number>} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * 复制矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m
 */
function copy(out, m) {
    out[0] = m[0];
    out[1] = m[1];
    out[2] = m[2];
    out[3] = m[3];
    out[4] = m[4];
    out[5] = m[5];
    return out;
}

/**
 * 矩阵相乘
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} m1
 * @param {Float32Array|Array.<number>} m2
 */
function mul(out, m1, m2) {
    // Consider matrix.mul(m, m2, m);
    // where out is the same as m2.
    // So use temp variable to escape error.
    var out0 = m1[0] * m2[0] + m1[2] * m2[1];
    var out1 = m1[1] * m2[0] + m1[3] * m2[1];
    var out2 = m1[0] * m2[2] + m1[2] * m2[3];
    var out3 = m1[1] * m2[2] + m1[3] * m2[3];
    var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
    var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = out3;
    out[4] = out4;
    out[5] = out5;
    return out;
}

/**
 * 平移变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */
function translate(out, a, v) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4] + v[0];
    out[5] = a[5] + v[1];
    return out;
}

/**
 * 旋转变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {number} rad
 */
function rotate(out, a, rad) {
    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];
    var st = Math.sin(rad);
    var ct = Math.cos(rad);

    out[0] = aa * ct + ab * st;
    out[1] = -aa * st + ab * ct;
    out[2] = ac * ct + ad * st;
    out[3] = -ac * st + ct * ad;
    out[4] = ct * atx + st * aty;
    out[5] = ct * aty - st * atx;
    return out;
}

/**
 * 缩放变换
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 * @param {Float32Array|Array.<number>} v
 */
function scale(out, a, v) {
    var vx = v[0];
    var vy = v[1];
    out[0] = a[0] * vx;
    out[1] = a[1] * vy;
    out[2] = a[2] * vx;
    out[3] = a[3] * vy;
    out[4] = a[4] * vx;
    out[5] = a[5] * vy;
    return out;
}

/**
 * 求逆矩阵
 * @param {Float32Array|Array.<number>} out
 * @param {Float32Array|Array.<number>} a
 */
function invert(out, a) {

    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];

    var det = aa * ad - ab * ac;
    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
}


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = sort;
// https://github.com/mziccard/node-timsort
var DEFAULT_MIN_MERGE = 32;

var DEFAULT_MIN_GALLOPING = 7;

var DEFAULT_TMP_STORAGE_LENGTH = 256;

function minRunLength(n) {
    var r = 0;

    while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
    }

    return n + r;
}

function makeAscendingRun(array, lo, hi, compare) {
    var runHi = lo + 1;

    if (runHi === hi) {
        return 1;
    }

    if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
            runHi++;
        }

        reverseRun(array, lo, runHi);
    }
    else {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
            runHi++;
        }
    }

    return runHi - lo;
}

function reverseRun(array, lo, hi) {
    hi--;

    while (lo < hi) {
        var t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
    }
}

function binaryInsertionSort(array, lo, hi, start, compare) {
    if (start === lo) {
        start++;
    }

    for (; start < hi; start++) {
        var pivot = array[start];

        var left = lo;
        var right = start;
        var mid;

        while (left < right) {
            mid = left + right >>> 1;

            if (compare(pivot, array[mid]) < 0) {
                right = mid;
            }
            else {
                left = mid + 1;
            }
        }

        var n = start - left;

        switch (n) {
            case 3:
                array[left + 3] = array[left + 2];

            case 2:
                array[left + 2] = array[left + 1];

            case 1:
                array[left + 1] = array[left];
                break;
            default:
                while (n > 0) {
                    array[left + n] = array[left + n - 1];
                    n--;
                }
        }

        array[left] = pivot;
    }
}

function gallopLeft(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;

            if (offset <= 0) {
                offset = maxOffset;
            }
        }

        if (offset > maxOffset) {
            offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
    }
    else {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;

            if (offset <= 0) {
                offset = maxOffset;
            }
        }
        if (offset > maxOffset) {
            offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
    }

    lastOffset++;
    while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) > 0) {
            lastOffset = m + 1;
        }
        else {
            offset = m;
        }
    }
    return offset;
}

function gallopRight(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;

        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;

            if (offset <= 0) {
                offset = maxOffset;
            }
        }

        if (offset > maxOffset) {
            offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
    }
    else {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;

            if (offset <= 0) {
                offset = maxOffset;
            }
        }

        if (offset > maxOffset) {
            offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
    }

    lastOffset++;

    while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) < 0) {
            offset = m;
        }
        else {
            lastOffset = m + 1;
        }
    }

    return offset;
}

function TimSort(array, compare) {
    var minGallop = DEFAULT_MIN_GALLOPING;
    var length = 0;
    var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
    var stackLength = 0;
    var runStart;
    var runLength;
    var stackSize = 0;

    length = array.length;

    if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
        tmpStorageLength = length >>> 1;
    }

    var tmp = [];

    stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;

    runStart = [];
    runLength = [];

    function pushRun(_runStart, _runLength) {
        runStart[stackSize] = _runStart;
        runLength[stackSize] = _runLength;
        stackSize += 1;
    }

    function mergeRuns() {
        while (stackSize > 1) {
            var n = stackSize - 2;

            if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
                if (runLength[n - 1] < runLength[n + 1]) {
                    n--;
                }
            }
            else if (runLength[n] > runLength[n + 1]) {
                break;
            }
            mergeAt(n);
        }
    }

    function forceMergeRuns() {
        while (stackSize > 1) {
            var n = stackSize - 2;

            if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
                n--;
            }

            mergeAt(n);
        }
    }

    function mergeAt(i) {
        var start1 = runStart[i];
        var length1 = runLength[i];
        var start2 = runStart[i + 1];
        var length2 = runLength[i + 1];

        runLength[i] = length1 + length2;

        if (i === stackSize - 3) {
            runStart[i + 1] = runStart[i + 2];
            runLength[i + 1] = runLength[i + 2];
        }

        stackSize--;

        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
        start1 += k;
        length1 -= k;

        if (length1 === 0) {
            return;
        }

        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

        if (length2 === 0) {
            return;
        }

        if (length1 <= length2) {
            mergeLow(start1, length1, start2, length2);
        }
        else {
            mergeHigh(start1, length1, start2, length2);
        }
    }

    function mergeLow(start1, length1, start2, length2) {
        var i = 0;

        for (i = 0; i < length1; i++) {
            tmp[i] = array[start1 + i];
        }

        var cursor1 = 0;
        var cursor2 = start2;
        var dest = start1;

        array[dest++] = array[cursor2++];

        if (--length2 === 0) {
            for (i = 0; i < length1; i++) {
                array[dest + i] = tmp[cursor1 + i];
            }
            return;
        }

        if (length1 === 1) {
            for (i = 0; i < length2; i++) {
                array[dest + i] = array[cursor2 + i];
            }
            array[dest + length2] = tmp[cursor1];
            return;
        }

        var _minGallop = minGallop;
        var count1, count2, exit;

        while (1) {
            count1 = 0;
            count2 = 0;
            exit = false;

            do {
                if (compare(array[cursor2], tmp[cursor1]) < 0) {
                    array[dest++] = array[cursor2++];
                    count2++;
                    count1 = 0;

                    if (--length2 === 0) {
                        exit = true;
                        break;
                    }
                }
                else {
                    array[dest++] = tmp[cursor1++];
                    count1++;
                    count2 = 0;
                    if (--length1 === 1) {
                        exit = true;
                        break;
                    }
                }
            } while ((count1 | count2) < _minGallop);

            if (exit) {
                break;
            }

            do {
                count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

                if (count1 !== 0) {
                    for (i = 0; i < count1; i++) {
                        array[dest + i] = tmp[cursor1 + i];
                    }

                    dest += count1;
                    cursor1 += count1;
                    length1 -= count1;
                    if (length1 <= 1) {
                        exit = true;
                        break;
                    }
                }

                array[dest++] = array[cursor2++];

                if (--length2 === 0) {
                    exit = true;
                    break;
                }

                count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

                if (count2 !== 0) {
                    for (i = 0; i < count2; i++) {
                        array[dest + i] = array[cursor2 + i];
                    }

                    dest += count2;
                    cursor2 += count2;
                    length2 -= count2;

                    if (length2 === 0) {
                        exit = true;
                        break;
                    }
                }
                array[dest++] = tmp[cursor1++];

                if (--length1 === 1) {
                    exit = true;
                    break;
                }

                _minGallop--;
            } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

            if (exit) {
                break;
            }

            if (_minGallop < 0) {
                _minGallop = 0;
            }

            _minGallop += 2;
        }

        minGallop = _minGallop;

        minGallop < 1 && (minGallop = 1);

        if (length1 === 1) {
            for (i = 0; i < length2; i++) {
                array[dest + i] = array[cursor2 + i];
            }
            array[dest + length2] = tmp[cursor1];
        }
        else if (length1 === 0) {
            throw new Error();
            // throw new Error('mergeLow preconditions were not respected');
        }
        else {
            for (i = 0; i < length1; i++) {
                array[dest + i] = tmp[cursor1 + i];
            }
        }
    }

    function mergeHigh (start1, length1, start2, length2) {
        var i = 0;

        for (i = 0; i < length2; i++) {
            tmp[i] = array[start2 + i];
        }

        var cursor1 = start1 + length1 - 1;
        var cursor2 = length2 - 1;
        var dest = start2 + length2 - 1;
        var customCursor = 0;
        var customDest = 0;

        array[dest--] = array[cursor1--];

        if (--length1 === 0) {
            customCursor = dest - (length2 - 1);

            for (i = 0; i < length2; i++) {
                array[customCursor + i] = tmp[i];
            }

            return;
        }

        if (length2 === 1) {
            dest -= length1;
            cursor1 -= length1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;

            for (i = length1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
            }

            array[dest] = tmp[cursor2];
            return;
        }

        var _minGallop = minGallop;

        while (true) {
            var count1 = 0;
            var count2 = 0;
            var exit = false;

            do {
                if (compare(tmp[cursor2], array[cursor1]) < 0) {
                    array[dest--] = array[cursor1--];
                    count1++;
                    count2 = 0;
                    if (--length1 === 0) {
                        exit = true;
                        break;
                    }
                }
                else {
                    array[dest--] = tmp[cursor2--];
                    count2++;
                    count1 = 0;
                    if (--length2 === 1) {
                        exit = true;
                        break;
                    }
                }
            } while ((count1 | count2) < _minGallop);

            if (exit) {
                break;
            }

            do {
                count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

                if (count1 !== 0) {
                    dest -= count1;
                    cursor1 -= count1;
                    length1 -= count1;
                    customDest = dest + 1;
                    customCursor = cursor1 + 1;

                    for (i = count1 - 1; i >= 0; i--) {
                        array[customDest + i] = array[customCursor + i];
                    }

                    if (length1 === 0) {
                        exit = true;
                        break;
                    }
                }

                array[dest--] = tmp[cursor2--];

                if (--length2 === 1) {
                    exit = true;
                    break;
                }

                count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

                if (count2 !== 0) {
                    dest -= count2;
                    cursor2 -= count2;
                    length2 -= count2;
                    customDest = dest + 1;
                    customCursor = cursor2 + 1;

                    for (i = 0; i < count2; i++) {
                        array[customDest + i] = tmp[customCursor + i];
                    }

                    if (length2 <= 1) {
                        exit = true;
                        break;
                    }
                }

                array[dest--] = array[cursor1--];

                if (--length1 === 0) {
                    exit = true;
                    break;
                }

                _minGallop--;
            } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

            if (exit) {
                break;
            }

            if (_minGallop < 0) {
                _minGallop = 0;
            }

            _minGallop += 2;
        }

        minGallop = _minGallop;

        if (minGallop < 1) {
            minGallop = 1;
        }

        if (length2 === 1) {
            dest -= length1;
            cursor1 -= length1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;

            for (i = length1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
            }

            array[dest] = tmp[cursor2];
        }
        else if (length2 === 0) {
            throw new Error();
            // throw new Error('mergeHigh preconditions were not respected');
        }
        else {
            customCursor = dest - (length2 - 1);
            for (i = 0; i < length2; i++) {
                array[customCursor + i] = tmp[i];
            }
        }
    }

    this.mergeRuns = mergeRuns;
    this.forceMergeRuns = forceMergeRuns;
    this.pushRun = pushRun;
}

function sort(array, compare, lo, hi) {
    if (!lo) {
        lo = 0;
    }
    if (!hi) {
        hi = array.length;
    }

    var remaining = hi - lo;

    if (remaining < 2) {
        return;
    }

    var runLength = 0;

    if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return;
    }

    var ts = new TimSort(array, compare);

    var minRun = minRunLength(remaining);

    do {
        runLength = makeAscendingRun(array, lo, hi, compare);
        if (runLength < minRun) {
            var force = remaining;
            if (force > minRun) {
                force = minRun;
            }

            binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
            runLength = force;
        }

        ts.pushRun(lo, runLength);
        ts.mergeRuns();

        remaining -= runLength;
        lo += runLength;
    } while (remaining !== 0);

    ts.forceMergeRuns();
}


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Displayable__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_PathProxy__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__contain_path__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Pattern__ = __webpack_require__(24);






var getCanvasPattern = __WEBPACK_IMPORTED_MODULE_4__Pattern__["a" /* default */].prototype.getCanvasPattern;

var abs = Math.abs;

var pathProxyForDraw = new __WEBPACK_IMPORTED_MODULE_2__core_PathProxy__["a" /* default */](true);
/**
 * @alias module:zrender/graphic/Path
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */
function Path(opts) {
    __WEBPACK_IMPORTED_MODULE_0__Displayable__["a" /* default */].call(this, opts);

    /**
     * @type {module:zrender/core/PathProxy}
     * @readOnly
     */
    this.path = null;
}

Path.prototype = {

    constructor: Path,

    type: 'path',

    __dirtyPath: true,

    strokeContainThreshold: 5,

    brush: function (ctx, prevEl) {
        var style = this.style;
        var path = this.path || pathProxyForDraw;
        var hasStroke = style.hasStroke();
        var hasFill = style.hasFill();
        var fill = style.fill;
        var stroke = style.stroke;
        var hasFillGradient = hasFill && !!(fill.colorStops);
        var hasStrokeGradient = hasStroke && !!(stroke.colorStops);
        var hasFillPattern = hasFill && !!(fill.image);
        var hasStrokePattern = hasStroke && !!(stroke.image);

        style.bind(ctx, this, prevEl);
        this.setTransform(ctx);

        if (this.__dirty) {
            var rect;
            // Update gradient because bounding rect may changed
            if (hasFillGradient) {
                rect = rect || this.getBoundingRect();
                this._fillGradient = style.getGradient(ctx, fill, rect);
            }
            if (hasStrokeGradient) {
                rect = rect || this.getBoundingRect();
                this._strokeGradient = style.getGradient(ctx, stroke, rect);
            }
        }
        // Use the gradient or pattern
        if (hasFillGradient) {
            // PENDING If may have affect the state
            ctx.fillStyle = this._fillGradient;
        }
        else if (hasFillPattern) {
            ctx.fillStyle = getCanvasPattern.call(fill, ctx);
        }
        if (hasStrokeGradient) {
            ctx.strokeStyle = this._strokeGradient;
        }
        else if (hasStrokePattern) {
            ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
        }

        var lineDash = style.lineDash;
        var lineDashOffset = style.lineDashOffset;

        var ctxLineDash = !!ctx.setLineDash;

        // Update path sx, sy
        var scale = this.getGlobalScale();
        path.setScale(scale[0], scale[1]);

        // Proxy context
        // Rebuild path in following 2 cases
        // 1. Path is dirty
        // 2. Path needs javascript implemented lineDash stroking.
        //    In this case, lineDash information will not be saved in PathProxy
        if (this.__dirtyPath
            || (lineDash && !ctxLineDash && hasStroke)
        ) {
            path.beginPath(ctx);

            // Setting line dash before build path
            if (lineDash && !ctxLineDash) {
                path.setLineDash(lineDash);
                path.setLineDashOffset(lineDashOffset);
            }

            this.buildPath(path, this.shape, false);

            // Clear path dirty flag
            if (this.path) {
                this.__dirtyPath = false;
            }
        }
        else {
            // Replay path building
            ctx.beginPath();
            this.path.rebuildPath(ctx);
        }

        hasFill && path.fill(ctx);

        if (lineDash && ctxLineDash) {
            ctx.setLineDash(lineDash);
            ctx.lineDashOffset = lineDashOffset;
        }

        hasStroke && path.stroke(ctx);

        if (lineDash && ctxLineDash) {
            // PENDING
            // Remove lineDash
            ctx.setLineDash([]);
        }

        this.restoreTransform(ctx);

        // Draw rect text
        if (style.text != null) {
            this.drawRectText(ctx, this.getBoundingRect());
        }
    },

    // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
    // Like in circle
    buildPath: function (ctx, shapeCfg, inBundle) {},

    createPathProxy: function () {
        this.path = new __WEBPACK_IMPORTED_MODULE_2__core_PathProxy__["a" /* default */]();
    },

    getBoundingRect: function () {
        var rect = this._rect;
        var style = this.style;
        var needsUpdateRect = !rect;
        if (needsUpdateRect) {
            var path = this.path;
            if (!path) {
                // Create path on demand.
                path = this.path = new __WEBPACK_IMPORTED_MODULE_2__core_PathProxy__["a" /* default */]();
            }
            if (this.__dirtyPath) {
                path.beginPath();
                this.buildPath(path, this.shape, false);
            }
            rect = path.getBoundingRect();
        }
        this._rect = rect;

        if (style.hasStroke()) {
            // Needs update rect with stroke lineWidth when
            // 1. Element changes scale or lineWidth
            // 2. Shape is changed
            var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
            if (this.__dirty || needsUpdateRect) {
                rectWithStroke.copy(rect);
                // FIXME Must after updateTransform
                var w = style.lineWidth;
                // PENDING, Min line width is needed when line is horizontal or vertical
                var lineScale = style.strokeNoScale ? this.getLineScale() : 1;

                // Only add extra hover lineWidth when there are no fill
                if (!style.hasFill()) {
                    w = Math.max(w, this.strokeContainThreshold || 4);
                }
                // Consider line width
                // Line scale can't be 0;
                if (lineScale > 1e-10) {
                    rectWithStroke.width += w / lineScale;
                    rectWithStroke.height += w / lineScale;
                    rectWithStroke.x -= w / lineScale / 2;
                    rectWithStroke.y -= w / lineScale / 2;
                }
            }

            // Return rect with stroke
            return rectWithStroke;
        }

        return rect;
    },

    contain: function (x, y) {
        var localPos = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        var style = this.style;
        x = localPos[0];
        y = localPos[1];

        if (rect.contain(x, y)) {
            var pathData = this.path.data;
            if (style.hasStroke()) {
                var lineWidth = style.lineWidth;
                var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
                // Line scale can't be 0;
                if (lineScale > 1e-10) {
                    // Only add extra hover lineWidth when there are no fill
                    if (!style.hasFill()) {
                        lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
                    }
                    if (__WEBPACK_IMPORTED_MODULE_3__contain_path__["a" /* containStroke */](
                        pathData, lineWidth / lineScale, x, y
                    )) {
                        return true;
                    }
                }
            }
            if (style.hasFill()) {
                return __WEBPACK_IMPORTED_MODULE_3__contain_path__["b" /* contain */](pathData, x, y);
            }
        }
        return false;
    },

    /**
     * @param  {boolean} dirtyPath
     */
    dirty: function (dirtyPath) {
        if (dirtyPath == null) {
            dirtyPath = true;
        }
        // Only mark dirty, not mark clean
        if (dirtyPath) {
            this.__dirtyPath = dirtyPath;
            this._rect = null;
        }

        this.__dirty = true;

        this.__zr && this.__zr.refresh();

        // Used as a clipping path
        if (this.__clipTarget) {
            this.__clipTarget.dirty();
        }
    },

    /**
     * Alias for animate('shape')
     * @param {boolean} loop
     */
    animateShape: function (loop) {
        return this.animate('shape', loop);
    },

    // Overwrite attrKV
    attrKV: function (key, value) {
        // FIXME
        if (key === 'shape') {
            this.setShape(value);
            this.__dirtyPath = true;
            this._rect = null;
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0__Displayable__["a" /* default */].prototype.attrKV.call(this, key, value);
        }
    },

    /**
     * @param {Object|string} key
     * @param {*} value
     */
    setShape: function (key, value) {
        var shape = this.shape;
        // Path from string may not have shape
        if (shape) {
            if (__WEBPACK_IMPORTED_MODULE_1__core_util__["g" /* isObject */](key)) {
                for (var name in key) {
                    if (key.hasOwnProperty(name)) {
                        shape[name] = key[name];
                    }
                }
            }
            else {
                shape[key] = value;
            }
            this.dirty(true);
        }
        return this;
    },

    getLineScale: function () {
        var m = this.transform;
        // Get the line scale.
        // Determinant of `m` means how much the area is enlarged by the
        // transformation. So its square root can be used as a scale factor
        // for width.
        return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10
            ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))
            : 1;
    }
};

/**
 * 扩展一个 Path element, 比如星形，圆等。
 * Extend a path element
 * @param {Object} props
 * @param {string} props.type Path type
 * @param {Function} props.init Initialize
 * @param {Function} props.buildPath Overwrite buildPath method
 * @param {Object} [props.style] Extended default style config
 * @param {Object} [props.shape] Extended default shape config
 */
Path.extend = function (defaults) {
    var Sub = function (opts) {
        Path.call(this, opts);

        if (defaults.style) {
            // Extend default style
            this.style.extendFrom(defaults.style, false);
        }

        // Extend default shape
        var defaultShape = defaults.shape;
        if (defaultShape) {
            this.shape = this.shape || {};
            var thisShape = this.shape;
            for (var name in defaultShape) {
                if (
                    ! thisShape.hasOwnProperty(name)
                    && defaultShape.hasOwnProperty(name)
                ) {
                    thisShape[name] = defaultShape[name];
                }
            }
        }

        defaults.init && defaults.init.call(this, opts);
    };

    __WEBPACK_IMPORTED_MODULE_1__core_util__["a" /* inherits */](Sub, Path);

    // FIXME 不能 extend position, rotation 等引用对象
    for (var name in defaults) {
        // Extending prototype values and methods
        if (name !== 'style' && name !== 'shape') {
            Sub.prototype[name] = defaults[name];
        }
    }

    return Sub;
};

__WEBPACK_IMPORTED_MODULE_1__core_util__["a" /* inherits */](Path, __WEBPACK_IMPORTED_MODULE_0__Displayable__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Path);

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var Pattern = function (image, repeat) {
    // Should do nothing more in this constructor. Because gradient can be
    // declard by `color: {image: ...}`, where this constructor will not be called.

    this.image = image;
    this.repeat = repeat;

    // Can be cloned
    this.type = 'pattern';
};

Pattern.prototype.getCanvasPattern = function (ctx) {
    return ctx.createPattern(this.image, this.repeat || 'repeat');
};

/* harmony default export */ __webpack_exports__["a"] = (Pattern);

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var STYLE_COMMON_PROPS = [
    ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],
    ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]
];

// var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);

var Style = function (opts, host) {
    this.extendFrom(opts, false);
    this.host = host;
};

function createLinearGradient(ctx, obj, rect) {
    var x = obj.x == null ? 0 : obj.x;
    var x2 = obj.x2 == null ? 1 : obj.x2;
    var y = obj.y == null ? 0 : obj.y;
    var y2 = obj.y2 == null ? 0 : obj.y2;

    if (!obj.global) {
        x = x * rect.width + rect.x;
        x2 = x2 * rect.width + rect.x;
        y = y * rect.height + rect.y;
        y2 = y2 * rect.height + rect.y;
    }

    var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);

    return canvasGradient;
}

function createRadialGradient(ctx, obj, rect) {
    var width = rect.width;
    var height = rect.height;
    var min = Math.min(width, height);

    var x = obj.x == null ? 0.5 : obj.x;
    var y = obj.y == null ? 0.5 : obj.y;
    var r = obj.r == null ? 0.5 : obj.r;
    if (!obj.global) {
        x = x * width + rect.x;
        y = y * height + rect.y;
        r = r * min;
    }

    var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);

    return canvasGradient;
}


Style.prototype = {

    constructor: Style,

    /**
     * @type {module:zrender/graphic/Displayable}
     */
    host: null,

    /**
     * @type {string}
     */
    fill: '#000',

    /**
     * @type {string}
     */
    stroke: null,

    /**
     * @type {number}
     */
    opacity: 1,

    /**
     * @type {Array.<number>}
     */
    lineDash: null,

    /**
     * @type {number}
     */
    lineDashOffset: 0,

    /**
     * @type {number}
     */
    shadowBlur: 0,

    /**
     * @type {number}
     */
    shadowOffsetX: 0,

    /**
     * @type {number}
     */
    shadowOffsetY: 0,

    /**
     * @type {number}
     */
    lineWidth: 1,

    /**
     * If stroke ignore scale
     * @type {Boolean}
     */
    strokeNoScale: false,

    // Bounding rect text configuration
    // Not affected by element transform
    /**
     * @type {string}
     */
    text: null,

    /**
     * If `fontSize` or `fontFamily` exists, `font` will be reset by
     * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
     * So do not visit it directly in upper application (like echarts),
     * but use `contain/text#makeFont` instead.
     * @type {string}
     */
    font: null,

    /**
     * The same as font. Use font please.
     * @deprecated
     * @type {string}
     */
    textFont: null,

    /**
     * It helps merging respectively, rather than parsing an entire font string.
     * @type {string}
     */
    fontStyle: null,

    /**
     * It helps merging respectively, rather than parsing an entire font string.
     * @type {string}
     */
    fontWeight: null,

    /**
     * It helps merging respectively, rather than parsing an entire font string.
     * Should be 12 but not '12px'.
     * @type {number}
     */
    fontSize: null,

    /**
     * It helps merging respectively, rather than parsing an entire font string.
     * @type {string}
     */
    fontFamily: null,

    /**
     * Reserved for special functinality, like 'hr'.
     * @type {string}
     */
    textTag: null,

    /**
     * @type {string}
     */
    textFill: '#000',

    /**
     * @type {string}
     */
    textStroke: null,

    /**
     * @type {number}
     */
    textWidth: null,

    /**
     * Only for textBackground.
     * @type {number}
     */
    textHeight: null,

    /**
     * textStroke may be set as some color as a default
     * value in upper applicaion, where the default value
     * of textStrokeWidth should be 0 to make sure that
     * user can choose to do not use text stroke.
     * @type {number}
     */
    textStrokeWidth: 0,

    /**
     * @type {number}
     */
    textLineHeight: null,

    /**
     * 'inside', 'left', 'right', 'top', 'bottom'
     * [x, y]
     * Based on x, y of rect.
     * @type {string|Array.<number>}
     * @default 'inside'
     */
    textPosition: 'inside',

    /**
     * If not specified, use the boundingRect of a `displayable`.
     * @type {Object}
     */
    textRect: null,

    /**
     * [x, y]
     * @type {Array.<number>}
     */
    textOffset: null,

    /**
     * @type {string}
     */
    textAlign: null,

    /**
     * @type {string}
     */
    textVerticalAlign: null,

    /**
     * @type {number}
     */
    textDistance: 5,

    /**
     * @type {string}
     */
    textShadowColor: 'transparent',

    /**
     * @type {number}
     */
    textShadowBlur: 0,

    /**
     * @type {number}
     */
    textShadowOffsetX: 0,

    /**
     * @type {number}
     */
    textShadowOffsetY: 0,

    /**
     * @type {string}
     */
    textBoxShadowColor: 'transparent',

    /**
     * @type {number}
     */
    textBoxShadowBlur: 0,

    /**
     * @type {number}
     */
    textBoxShadowOffsetX: 0,

    /**
     * @type {number}
     */
    textBoxShadowOffsetY: 0,

    /**
     * Whether transform text.
     * Only useful in Path and Image element
     * @type {boolean}
     */
    transformText: false,

    /**
     * Text rotate around position of Path or Image
     * Only useful in Path and Image element and transformText is false.
     */
    textRotation: 0,

    /**
     * Text origin of text rotation, like [10, 40].
     * Based on x, y of rect.
     * Useful in label rotation of circular symbol.
     * By default, this origin is textPosition.
     * Can be 'center'.
     * @type {string|Array.<number>}
     */
    textOrigin: null,

    /**
     * @type {string}
     */
    textBackgroundColor: null,

    /**
     * @type {string}
     */
    textBorderColor: null,

    /**
     * @type {number}
     */
    textBorderWidth: 0,

    /**
     * @type {number}
     */
    textBorderRadius: 0,

    /**
     * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
     * @type {number|Array.<number>}
     */
    textPadding: null,

    /**
     * Text styles for rich text.
     * @type {Object}
     */
    rich: null,

    /**
     * {outerWidth, outerHeight, ellipsis, placeholder}
     * @type {Object}
     */
    truncate: null,

    /**
     * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
     * @type {string}
     */
    blend: null,

    /**
     * @param {CanvasRenderingContext2D} ctx
     */
    bind: function (ctx, el, prevEl) {
        var style = this;
        var prevStyle = prevEl && prevEl.style;
        var firstDraw = !prevStyle;

        for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
            var prop = STYLE_COMMON_PROPS[i];
            var styleName = prop[0];

            if (firstDraw || style[styleName] !== prevStyle[styleName]) {
                // FIXME Invalid property value will cause style leak from previous element.
                ctx[styleName] = style[styleName] || prop[1];
            }
        }

        if ((firstDraw || style.fill !== prevStyle.fill)) {
            ctx.fillStyle = style.fill;
        }
        if ((firstDraw || style.stroke !== prevStyle.stroke)) {
            ctx.strokeStyle = style.stroke;
        }
        if ((firstDraw || style.opacity !== prevStyle.opacity)) {
            ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
        }

        if ((firstDraw || style.blend !== prevStyle.blend)) {
            ctx.globalCompositeOperation = style.blend || 'source-over';
        }
        if (this.hasStroke()) {
            var lineWidth = style.lineWidth;
            ctx.lineWidth = lineWidth / (
                (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1
            );
        }
    },

    hasFill: function () {
        var fill = this.fill;
        return fill != null && fill !== 'none';
    },

    hasStroke: function () {
        var stroke = this.stroke;
        return stroke != null && stroke !== 'none' && this.lineWidth > 0;
    },

    /**
     * Extend from other style
     * @param {zrender/graphic/Style} otherStyle
     * @param {boolean} overwrite true: overwrirte any way.
     *                            false: overwrite only when !target.hasOwnProperty
     *                            others: overwrite when property is not null/undefined.
     */
    extendFrom: function (otherStyle, overwrite) {
        if (otherStyle) {
            for (var name in otherStyle) {
                if (otherStyle.hasOwnProperty(name)
                    && (overwrite === true
                        || (
                            overwrite === false
                                ? !this.hasOwnProperty(name)
                                : otherStyle[name] != null
                        )
                    )
                ) {
                    this[name] = otherStyle[name];
                }
            }
        }
    },

    /**
     * Batch setting style with a given object
     * @param {Object|string} obj
     * @param {*} [obj]
     */
    set: function (obj, value) {
        if (typeof obj === 'string') {
            this[obj] = value;
        }
        else {
            this.extendFrom(obj, true);
        }
    },

    /**
     * Clone
     * @return {zrender/graphic/Style} [description]
     */
    clone: function () {
        var newStyle = new this.constructor();
        newStyle.extendFrom(this, true);
        return newStyle;
    },

    getGradient: function (ctx, obj, rect) {
        var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
        var canvasGradient = method(ctx, obj, rect);
        var colorStops = obj.colorStops;
        for (var i = 0; i < colorStops.length; i++) {
            canvasGradient.addColorStop(
                colorStops[i].offset, colorStops[i].color
            );
        }
        return canvasGradient;
    }

};

var styleProto = Style.prototype;
for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
    var prop = STYLE_COMMON_PROPS[i];
    if (!(prop[0] in styleProto)) {
        styleProto[prop[0]] = prop[1];
    }
}

// Provide for others
Style.getGradient = styleProto.getGradient;

/* harmony default export */ __webpack_exports__["a"] = (Style);

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = normalizeTextStyle;
/* harmony export (immutable) */ __webpack_exports__["c"] = renderText;
/* harmony export (immutable) */ __webpack_exports__["d"] = getStroke;
/* unused harmony export getFill */
/* harmony export (immutable) */ __webpack_exports__["b"] = needDrawText;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__contain_text__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__roundRect__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__image__ = __webpack_require__(10);






// TODO: Have not support 'start', 'end' yet.
var VALID_TEXT_ALIGN = {left: 1, right: 1, center: 1};
var VALID_TEXT_VERTICAL_ALIGN = {top: 1, bottom: 1, middle: 1};

/**
 * @param {module:zrender/graphic/Style} style
 * @return {module:zrender/graphic/Style} The input style.
 */
function normalizeTextStyle(style) {
    normalizeStyle(style);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util__["b" /* each */])(style.rich, normalizeStyle);
    return style;
}

function normalizeStyle(style) {
    if (style) {

        style.font = __WEBPACK_IMPORTED_MODULE_1__contain_text__["b" /* makeFont */](style);

        var textAlign = style.textAlign;
        textAlign === 'middle' && (textAlign = 'center');
        style.textAlign = (
            textAlign == null || VALID_TEXT_ALIGN[textAlign]
        ) ? textAlign : 'left';

        // Compatible with textBaseline.
        var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
        textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
        style.textVerticalAlign = (
            textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign]
        ) ? textVerticalAlign : 'top';

        var textPadding = style.textPadding;
        if (textPadding) {
            style.textPadding = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util__["c" /* normalizeCssArray */])(style.textPadding);
        }
    }
}

/**
 * @param {CanvasRenderingContext2D} ctx
 * @param {string} text
 * @param {module:zrender/graphic/Style} style
 * @param {Object|boolean} [rect] {x, y, width, height}
 *                  If set false, rect text is not used.
 */
function renderText(hostEl, ctx, text, style, rect) {
    style.rich
        ? renderRichText(hostEl, ctx, text, style, rect)
        : renderPlainText(hostEl, ctx, text, style, rect);
}

function renderPlainText(hostEl, ctx, text, style, rect) {
    var font = setCtx(ctx, 'font', style.font || __WEBPACK_IMPORTED_MODULE_1__contain_text__["c" /* DEFAULT_FONT */]);

    var textPadding = style.textPadding;

    var contentBlock = hostEl.__textCotentBlock;
    if (!contentBlock || hostEl.__dirty) {
        contentBlock = hostEl.__textCotentBlock = __WEBPACK_IMPORTED_MODULE_1__contain_text__["d" /* parsePlainText */](
            text, font, textPadding, style.truncate
        );
    }

    var outerHeight = contentBlock.outerHeight;

    var textLines = contentBlock.lines;
    var lineHeight = contentBlock.lineHeight;

    var boxPos = getBoxPosition(outerHeight, style, rect);
    var baseX = boxPos.baseX;
    var baseY = boxPos.baseY;
    var textAlign = boxPos.textAlign;
    var textVerticalAlign = boxPos.textVerticalAlign;

    // Origin of textRotation should be the base point of text drawing.
    applyTextRotation(ctx, style, rect, baseX, baseY);

    var boxY = __WEBPACK_IMPORTED_MODULE_1__contain_text__["e" /* adjustTextY */](baseY, outerHeight, textVerticalAlign);
    var textX = baseX;
    var textY = boxY;

    var needDrawBg = needDrawBackground(style);
    if (needDrawBg || textPadding) {
        // Consider performance, do not call getTextWidth util necessary.
        var textWidth = __WEBPACK_IMPORTED_MODULE_1__contain_text__["f" /* getWidth */](text, font);
        var outerWidth = textWidth;
        textPadding && (outerWidth += textPadding[1] + textPadding[3]);
        var boxX = __WEBPACK_IMPORTED_MODULE_1__contain_text__["g" /* adjustTextX */](baseX, outerWidth, textAlign);

        needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

        if (textPadding) {
            textX = getTextXForPadding(baseX, textAlign, textPadding);
            textY += textPadding[0];
        }
    }

    setCtx(ctx, 'textAlign', textAlign || 'left');
    // Force baseline to be "middle". Otherwise, if using "top", the
    // text will offset downward a little bit in font "Microsoft YaHei".
    setCtx(ctx, 'textBaseline', 'middle');

    // Always set shadowBlur and shadowOffset to avoid leak from displayable.
    setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);
    setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');
    setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);
    setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0);

    // `textBaseline` is set as 'middle'.
    textY += lineHeight / 2;

    var textStrokeWidth = style.textStrokeWidth;
    var textStroke = getStroke(style.textStroke, textStrokeWidth);
    var textFill = getFill(style.textFill);

    if (textStroke) {
        setCtx(ctx, 'lineWidth', textStrokeWidth);
        setCtx(ctx, 'strokeStyle', textStroke);
    }
    if (textFill) {
        setCtx(ctx, 'fillStyle', textFill);
    }

    for (var i = 0; i < textLines.length; i++) {
        // Fill after stroke so the outline will not cover the main part.
        textStroke && ctx.strokeText(textLines[i], textX, textY);
        textFill && ctx.fillText(textLines[i], textX, textY);
        textY += lineHeight;
    }
}

function renderRichText(hostEl, ctx, text, style, rect) {
    var contentBlock = hostEl.__textCotentBlock;

    if (!contentBlock || hostEl.__dirty) {
        contentBlock = hostEl.__textCotentBlock = __WEBPACK_IMPORTED_MODULE_1__contain_text__["h" /* parseRichText */](text, style);
    }

    drawRichText(hostEl, ctx, contentBlock, style, rect);
}

function drawRichText(hostEl, ctx, contentBlock, style, rect) {
    var contentWidth = contentBlock.width;
    var outerWidth = contentBlock.outerWidth;
    var outerHeight = contentBlock.outerHeight;
    var textPadding = style.textPadding;

    var boxPos = getBoxPosition(outerHeight, style, rect);
    var baseX = boxPos.baseX;
    var baseY = boxPos.baseY;
    var textAlign = boxPos.textAlign;
    var textVerticalAlign = boxPos.textVerticalAlign;

    // Origin of textRotation should be the base point of text drawing.
    applyTextRotation(ctx, style, rect, baseX, baseY);

    var boxX = __WEBPACK_IMPORTED_MODULE_1__contain_text__["g" /* adjustTextX */](baseX, outerWidth, textAlign);
    var boxY = __WEBPACK_IMPORTED_MODULE_1__contain_text__["e" /* adjustTextY */](baseY, outerHeight, textVerticalAlign);
    var xLeft = boxX;
    var lineTop = boxY;
    if (textPadding) {
        xLeft += textPadding[3];
        lineTop += textPadding[0];
    }
    var xRight = xLeft + contentWidth;

    needDrawBackground(style) && drawBackground(
        hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight
    );

    for (var i = 0; i < contentBlock.lines.length; i++) {
        var line = contentBlock.lines[i];
        var tokens = line.tokens;
        var tokenCount = tokens.length;
        var lineHeight = line.lineHeight;
        var usedWidth = line.width;

        var leftIndex = 0;
        var lineXLeft = xLeft;
        var lineXRight = xRight;
        var rightIndex = tokenCount - 1;
        var token;

        while (
            leftIndex < tokenCount
            && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')
        ) {
            placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
            usedWidth -= token.width;
            lineXLeft += token.width;
            leftIndex++;
        }

        while (
            rightIndex >= 0
            && (token = tokens[rightIndex], token.textAlign === 'right')
        ) {
            placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
            usedWidth -= token.width;
            lineXRight -= token.width;
            rightIndex--;
        }

        // The other tokens are placed as textAlign 'center' if there is enough space.
        lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;
        while (leftIndex <= rightIndex) {
            token = tokens[leftIndex];
            // Consider width specified by user, use 'center' rather than 'left'.
            placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
            lineXLeft += token.width;
            leftIndex++;
        }

        lineTop += lineHeight;
    }
}

function applyTextRotation(ctx, style, rect, x, y) {
    // textRotation only apply in RectText.
    if (rect && style.textRotation) {
        var origin = style.textOrigin;
        if (origin === 'center') {
            x = rect.width / 2 + rect.x;
            y = rect.height / 2 + rect.y;
        }
        else if (origin) {
            x = origin[0] + rect.x;
            y = origin[1] + rect.y;
        }

        ctx.translate(x, y);
        // Positive: anticlockwise
        ctx.rotate(-style.textRotation);
        ctx.translate(-x, -y);
    }
}

function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
    var tokenStyle = style.rich[token.styleName] || {};

    // 'ctx.textBaseline' is always set as 'middle', for sake of
    // the bias of "Microsoft YaHei".
    var textVerticalAlign = token.textVerticalAlign;
    var y = lineTop + lineHeight / 2;
    if (textVerticalAlign === 'top') {
        y = lineTop + token.height / 2;
    }
    else if (textVerticalAlign === 'bottom') {
        y = lineTop + lineHeight - token.height / 2;
    }

    !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(
        hostEl,
        ctx,
        tokenStyle,
        textAlign === 'right'
            ? x - token.width
            : textAlign === 'center'
            ? x - token.width / 2
            : x,
        y - token.height / 2,
        token.width,
        token.height
    );

    var textPadding = token.textPadding;
    if (textPadding) {
        x = getTextXForPadding(x, textAlign, textPadding);
        y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
    }

    setCtx(ctx, 'shadowBlur', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util__["d" /* retrieve3 */])(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
    setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
    setCtx(ctx, 'shadowOffsetX', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util__["d" /* retrieve3 */])(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
    setCtx(ctx, 'shadowOffsetY', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util__["d" /* retrieve3 */])(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));

    setCtx(ctx, 'textAlign', textAlign);
    // Force baseline to be "middle". Otherwise, if using "top", the
    // text will offset downward a little bit in font "Microsoft YaHei".
    setCtx(ctx, 'textBaseline', 'middle');

    setCtx(ctx, 'font', token.font || __WEBPACK_IMPORTED_MODULE_1__contain_text__["c" /* DEFAULT_FONT */]);

    var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
    var textFill = getFill(tokenStyle.textFill || style.textFill);
    var textStrokeWidth = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util__["e" /* retrieve2 */])(tokenStyle.textStrokeWidth, style.textStrokeWidth);

    // Fill after stroke so the outline will not cover the main part.
    if (textStroke) {
        setCtx(ctx, 'lineWidth', textStrokeWidth);
        setCtx(ctx, 'strokeStyle', textStroke);
        ctx.strokeText(token.text, x, y);
    }
    if (textFill) {
        setCtx(ctx, 'fillStyle', textFill);
        ctx.fillText(token.text, x, y);
    }
}

function needDrawBackground(style) {
    return style.textBackgroundColor
        || (style.textBorderWidth && style.textBorderColor);
}

// style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}
// shape: {x, y, width, height}
function drawBackground(hostEl, ctx, style, x, y, width, height) {
    var textBackgroundColor = style.textBackgroundColor;
    var textBorderWidth = style.textBorderWidth;
    var textBorderColor = style.textBorderColor;
    var isPlainBg = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util__["f" /* isString */])(textBackgroundColor);

    setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
    setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
    setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
    setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);

    if (isPlainBg || (textBorderWidth && textBorderColor)) {
        ctx.beginPath();
        var textBorderRadius = style.textBorderRadius;
        if (!textBorderRadius) {
            ctx.rect(x, y, width, height);
        }
        else {
            __WEBPACK_IMPORTED_MODULE_2__roundRect__["a" /* buildPath */](ctx, {
                x: x, y: y, width: width, height: height, r: textBorderRadius
            });
        }
        ctx.closePath();
    }

    if (isPlainBg) {
        setCtx(ctx, 'fillStyle', textBackgroundColor);
        ctx.fill();
    }
    else if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_util__["g" /* isObject */])(textBackgroundColor)) {
        var image = textBackgroundColor.image;

        image = __WEBPACK_IMPORTED_MODULE_3__image__["a" /* createOrUpdateImage */](
            image, null, hostEl, onBgImageLoaded, textBackgroundColor
        );
        if (image && __WEBPACK_IMPORTED_MODULE_3__image__["b" /* isImageReady */](image)) {
            ctx.drawImage(image, x, y, width, height);
        }
    }

    if (textBorderWidth && textBorderColor) {
        setCtx(ctx, 'lineWidth', textBorderWidth);
        setCtx(ctx, 'strokeStyle', textBorderColor);
        ctx.stroke();
    }
}

function onBgImageLoaded(image, textBackgroundColor) {
    // Replace image, so that `contain/text.js#parseRichText`
    // will get correct result in next tick.
    textBackgroundColor.image = image;
}

function getBoxPosition(blockHeiht, style, rect) {
    var baseX = style.x || 0;
    var baseY = style.y || 0;
    var textAlign = style.textAlign;
    var textVerticalAlign = style.textVerticalAlign;

    // Text position represented by coord
    if (rect) {
        var textPosition = style.textPosition;
        if (textPosition instanceof Array) {
            // Percent
            baseX = rect.x + parsePercent(textPosition[0], rect.width);
            baseY = rect.y + parsePercent(textPosition[1], rect.height);
        }
        else {
            var res = __WEBPACK_IMPORTED_MODULE_1__contain_text__["i" /* adjustTextPositionOnRect */](
                textPosition, rect, style.textDistance
            );
            baseX = res.x;
            baseY = res.y;
            // Default align and baseline when has textPosition
            textAlign = textAlign || res.textAlign;
            textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
        }

        // textOffset is only support in RectText, otherwise
        // we have to adjust boundingRect for textOffset.
        var textOffset = style.textOffset;
        if (textOffset) {
            baseX += textOffset[0];
            baseY += textOffset[1];
        }
    }

    return {
        baseX: baseX,
        baseY: baseY,
        textAlign: textAlign,
        textVerticalAlign: textVerticalAlign
    };
}

function setCtx(ctx, prop, value) {
    // FIXME ??? performance try
    // if (ctx.__currentValues[prop] !== value) {
        // ctx[prop] = ctx.__currentValues[prop] = value;
    ctx[prop] = value;
    // }
    return ctx[prop];
}

/**
 * @param {string} [stroke] If specified, do not check style.textStroke.
 * @param {string} [lineWidth] If specified, do not check style.textStroke.
 * @param {number} style
 */
function getStroke(stroke, lineWidth) {
    return (stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none')
        ? null
        // TODO pattern and gradient?
        : (stroke.image || stroke.colorStops)
        ? '#000'
        : stroke;
}

function getFill(fill) {
    return (fill == null || fill === 'none')
        ? null
        // TODO pattern and gradient?
        : (fill.image || fill.colorStops)
        ? '#000'
        : fill;
}

function parsePercent(value, maxValue) {
    if (typeof value === 'string') {
        if (value.lastIndexOf('%') >= 0) {
            return parseFloat(value) / 100 * maxValue;
        }
        return parseFloat(value);
    }
    return value;
}

function getTextXForPadding(x, textAlign, textPadding) {
    return textAlign === 'right'
        ? (x - textPadding[1])
        : textAlign === 'center'
        ? (x + textPadding[3] / 2 - textPadding[1] / 2)
        : (x + textPadding[3]);
}

/**
 * @param {string} text
 * @param {module:zrender/Style} style
 * @return {boolean}
 */
function needDrawText(text, style) {
    return text != null
        && (text
            || style.textBackgroundColor
            || (style.textBorderWidth && style.textBorderColor)
            || style.textPadding
        );
}


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RoadLine; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_zrender_src_container_Group__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_zrender_src_graphic_shape_Line__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Point__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_line_intersect__ = __webpack_require__(34);





function RoadLine(ops) {
    __WEBPACK_IMPORTED_MODULE_0_zrender_src_container_Group__["a" /* default */].call(this);
    this.type = "roadline";
    this.start = {
        x: ops.x1,
        y: ops.y1
    };
    this.end = {
        x: ops.x2,
        y: ops.y2
    };
    this.crossPoints = [];
    let line = new __WEBPACK_IMPORTED_MODULE_1_zrender_src_graphic_shape_Line__["a" /* default */]({
        shape: {
            x1: this.start.x,
            y1: this.start.y,
            x2: this.end.x,
            y2: this.end.y
        }
    });
    this.add(line);

    this.startPoint = new __WEBPACK_IMPORTED_MODULE_2__Point__["a" /* Point */](this.start);
    this.add(this.startPoint);
    this.endPoint = new __WEBPACK_IMPORTED_MODULE_2__Point__["a" /* Point */](this.end);
    this.add(this.endPoint);
    this.startPoint.ondrag = function (evt) {
        line.attr({
            shape: {
                x1: evt.offsetX,
                y1: evt.offsetY
            }
        });
    };
    this.endPoint.ondrag = function (evt) {
        line.attr({
            shape: {
                x2: evt.offsetX,
                y2: evt.offsetY
            }
        });
    };
    this.cross = () => {
        this.parent.cross();
    };
    this.crossLine = target => {
        let res = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_line_intersect__["a" /* checkIntersection */])(this.start.x, this.start.y, this.end.x, this.end.y, target.start.x, target.start.y, target.end.x, target.end.y);
        return res.point || null;
    };
    this.toData = function () {
        return {
            start: this.start,
            end: this.end
        };
    };
}

RoadLine.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0_zrender_src_container_Group__["a" /* default */].prototype);



/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Scene; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_zrender_src_container_Group__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Point__ = __webpack_require__(11);



function Scene() {
    __WEBPACK_IMPORTED_MODULE_0_zrender_src_container_Group__["a" /* default */].call(this);
    this.cross = () => {
        let children = this.children();
        let crossPoints = children.filter(item => {
            return item.type === "crosspoint";
        });
        crossPoints.forEach(cp => {
            this.remove(cp);
        });
        let lines = children.filter(item => {
            return item.type === "roadline";
        });
        for (let i = 0; i < lines.length; i++) {
            let line1 = lines[i];
            for (let j = 1; j < lines.length; j++) {
                let line2 = lines[j];
                let point = line1.crossLine(line2);
                if (!point) continue;
                let crpoint = new __WEBPACK_IMPORTED_MODULE_1__Point__["a" /* Point */](point);
                crpoint.draggable = false;
                crpoint.type = "crosspoint";
                this.add(crpoint);
            }
        }
    };
}

Scene.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0_zrender_src_container_Group__["a" /* default */].prototype);



/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Displayable__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__contain_text__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helper_text__ = __webpack_require__(26);





/**
 * @alias zrender/graphic/Text
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */
var Text = function (opts) { // jshint ignore:line
    __WEBPACK_IMPORTED_MODULE_0__Displayable__["a" /* default */].call(this, opts);
};

Text.prototype = {

    constructor: Text,

    type: 'text',

    brush: function (ctx, prevEl) {
        var style = this.style;

        // Optimize, avoid normalize every time.
        this.__dirty && __WEBPACK_IMPORTED_MODULE_3__helper_text__["a" /* normalizeTextStyle */](style, true);

        // Use props with prefix 'text'.
        style.fill = style.stroke = style.shadowBlur = style.shadowColor =
            style.shadowOffsetX = style.shadowOffsetY = null;

        var text = style.text;
        // Convert to string
        text != null && (text += '');

        // Always bind style
        style.bind(ctx, this, prevEl);

        if (!__WEBPACK_IMPORTED_MODULE_3__helper_text__["b" /* needDrawText */](text, style)) {
            return;
        }

        this.setTransform(ctx);

        __WEBPACK_IMPORTED_MODULE_3__helper_text__["c" /* renderText */](this, ctx, text, style);

        this.restoreTransform(ctx);
    },

    getBoundingRect: function () {
        var style = this.style;

        // Optimize, avoid normalize every time.
        this.__dirty && __WEBPACK_IMPORTED_MODULE_3__helper_text__["a" /* normalizeTextStyle */](style, true);

        if (!this._rect) {
            var text = style.text;
            text != null ? (text += '') : (text = '');

            var rect = __WEBPACK_IMPORTED_MODULE_2__contain_text__["a" /* getBoundingRect */](
                style.text + '',
                style.font,
                style.textAlign,
                style.textVerticalAlign,
                style.textPadding,
                style.rich
            );

            rect.x += style.x || 0;
            rect.y += style.y || 0;

            if (__WEBPACK_IMPORTED_MODULE_3__helper_text__["d" /* getStroke */](style.textStroke, style.textStrokeWidth)) {
                var w = style.textStrokeWidth;
                rect.x -= w / 2;
                rect.y -= w / 2;
                rect.width += w;
                rect.height += w;
            }

            this._rect = rect;
        }

        return this._rect;
    }
};

__WEBPACK_IMPORTED_MODULE_1__core_util__["a" /* inherits */](Text, __WEBPACK_IMPORTED_MODULE_0__Displayable__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Text);

/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export version */
/* harmony export (immutable) */ __webpack_exports__["a"] = init;
/* unused harmony export dispose */
/* unused harmony export getInstance */
/* unused harmony export registerPainter */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_guid__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_env__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Handler__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Storage__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Painter__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__animation_Animation__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__dom_HandlerProxy__ = __webpack_require__(50);
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/










var useVML = !__WEBPACK_IMPORTED_MODULE_1__core_env__["a" /* default */].canvasSupported;

var painterCtors = {
    canvas: __WEBPACK_IMPORTED_MODULE_5__Painter__["a" /* default */]
};

var instances = {};    // ZRender实例map索引

/**
 * @type {string}
 */
var version = '3.7.4';

/**
 * Initializing a zrender instance
 * @param {HTMLElement} dom
 * @param {Object} opts
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
 * @return {module:zrender/ZRender}
 */
function init(dom, opts) {
    var zr = new ZRender(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_guid__["a" /* default */])(), dom, opts);
    instances[zr.id] = zr;
    return zr;
}

/**
 * Dispose zrender instance
 * @param {module:zrender/ZRender} zr
 */
function dispose(zr) {
    if (zr) {
        zr.dispose();
    }
    else {
        for (var key in instances) {
            if (instances.hasOwnProperty(key)) {
                instances[key].dispose();
            }
        }
        instances = {};
    }

    return this;
}

/**
 * Get zrender instance by id
 * @param {string} id zrender instance id
 * @return {module:zrender/ZRender}
 */
function getInstance(id) {
    return instances[id];
}

function registerPainter(name, Ctor) {
    painterCtors[name] = Ctor;
}

function delInstance(id) {
    delete instances[id];
}

/**
 * @module zrender/ZRender
 */
/**
 * @constructor
 * @alias module:zrender/ZRender
 * @param {string} id
 * @param {HTMLElement} dom
 * @param {Object} opts
 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
 * @param {number} [opts.devicePixelRatio]
 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
 */
var ZRender = function (id, dom, opts) {

    opts = opts || {};

    /**
     * @type {HTMLDomElement}
     */
    this.dom = dom;

    /**
     * @type {string}
     */
    this.id = id;

    var self = this;
    var storage = new __WEBPACK_IMPORTED_MODULE_4__Storage__["a" /* default */]();

    var rendererType = opts.renderer;
    // TODO WebGL
    if (useVML) {
        if (!painterCtors.vml) {
            throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
        }
        rendererType = 'vml';
    }
    else if (!rendererType || !painterCtors[rendererType]) {
        rendererType = 'canvas';
    }
    var painter = new painterCtors[rendererType](dom, storage, opts);

    this.storage = storage;
    this.painter = painter;

    var handerProxy = !__WEBPACK_IMPORTED_MODULE_1__core_env__["a" /* default */].node ? new __WEBPACK_IMPORTED_MODULE_7__dom_HandlerProxy__["a" /* default */](painter.getViewportRoot()) : null;
    this.handler = new __WEBPACK_IMPORTED_MODULE_3__Handler__["a" /* default */](storage, painter, handerProxy, painter.root);

    /**
     * @type {module:zrender/animation/Animation}
     */
    this.animation = new __WEBPACK_IMPORTED_MODULE_6__animation_Animation__["a" /* default */]({
        stage: {
            update: __WEBPACK_IMPORTED_MODULE_2__core_util__["n" /* bind */](this.flush, this)
        }
    });
    this.animation.start();

    /**
     * @type {boolean}
     * @private
     */
    this._needsRefresh;

    // 修改 storage.delFromStorage, 每次删除元素之前删除动画
    // FIXME 有点ugly
    var oldDelFromStorage = storage.delFromStorage;
    var oldAddToStorage = storage.addToStorage;

    storage.delFromStorage = function (el) {
        oldDelFromStorage.call(storage, el);

        el && el.removeSelfFromZr(self);
    };

    storage.addToStorage = function (el) {
        oldAddToStorage.call(storage, el);

        el.addSelfToZr(self);
    };
};

ZRender.prototype = {

    constructor: ZRender,
    /**
     * 获取实例唯一标识
     * @return {string}
     */
    getId: function () {
        return this.id;
    },

    /**
     * 添加元素
     * @param  {module:zrender/Element} el
     */
    add: function (el) {
        this.storage.addRoot(el);
        this._needsRefresh = true;
    },

    /**
     * 删除元素
     * @param  {module:zrender/Element} el
     */
    remove: function (el) {
        this.storage.delRoot(el);
        this._needsRefresh = true;
    },

    /**
     * Change configuration of layer
     * @param {string} zLevel
     * @param {Object} config
     * @param {string} [config.clearColor=0] Clear color
     * @param {string} [config.motionBlur=false] If enable motion blur
     * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
    */
    configLayer: function (zLevel, config) {
        this.painter.configLayer(zLevel, config);
        this._needsRefresh = true;
    },

    /**
     * Repaint the canvas immediately
     */
    refreshImmediately: function () {
        // var start = new Date();
        // Clear needsRefresh ahead to avoid something wrong happens in refresh
        // Or it will cause zrender refreshes again and again.
        this._needsRefresh = false;
        this.painter.refresh();
        /**
         * Avoid trigger zr.refresh in Element#beforeUpdate hook
         */
        this._needsRefresh = false;
        // var end = new Date();

        // var log = document.getElementById('log');
        // if (log) {
        //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
        // }
    },

    /**
     * Mark and repaint the canvas in the next frame of browser
     */
    refresh: function() {
        this._needsRefresh = true;
    },

    /**
     * Perform all refresh
     */
    flush: function () {
        if (this._needsRefresh) {
            this.refreshImmediately();
        }
        if (this._needsRefreshHover) {
            this.refreshHoverImmediately();
        }
    },

    /**
     * Add element to hover layer
     * @param  {module:zrender/Element} el
     * @param {Object} style
     */
    addHover: function (el, style) {
        if (this.painter.addHover) {
            this.painter.addHover(el, style);
            this.refreshHover();
        }
    },

    /**
     * Add element from hover layer
     * @param  {module:zrender/Element} el
     */
    removeHover: function (el) {
        if (this.painter.removeHover) {
            this.painter.removeHover(el);
            this.refreshHover();
        }
    },

    /**
     * Clear all hover elements in hover layer
     * @param  {module:zrender/Element} el
     */
    clearHover: function () {
        if (this.painter.clearHover) {
            this.painter.clearHover();
            this.refreshHover();
        }
    },

    /**
     * Refresh hover in next frame
     */
    refreshHover: function () {
        this._needsRefreshHover = true;
    },

    /**
     * Refresh hover immediately
     */
    refreshHoverImmediately: function () {
        this._needsRefreshHover = false;
        this.painter.refreshHover && this.painter.refreshHover();
    },

    /**
     * Resize the canvas.
     * Should be invoked when container size is changed
     * @param {Object} [opts]
     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
     */
    resize: function(opts) {
        opts = opts || {};
        this.painter.resize(opts.width, opts.height);
        this.handler.resize();
    },

    /**
     * Stop and clear all animation immediately
     */
    clearAnimation: function () {
        this.animation.clear();
    },

    /**
     * Get container width
     */
    getWidth: function() {
        return this.painter.getWidth();
    },

    /**
     * Get container height
     */
    getHeight: function() {
        return this.painter.getHeight();
    },

    /**
     * Export the canvas as Base64 URL
     * @param {string} type
     * @param {string} [backgroundColor='#fff']
     * @return {string} Base64 URL
     */
    // toDataURL: function(type, backgroundColor) {
    //     return this.painter.getRenderedCanvas({
    //         backgroundColor: backgroundColor
    //     }).toDataURL(type);
    // },

    /**
     * Converting a path to image.
     * It has much better performance of drawing image rather than drawing a vector path.
     * @param {module:zrender/graphic/Path} e
     * @param {number} width
     * @param {number} height
     */
    pathToImage: function(e, dpr) {
        return this.painter.pathToImage(e, dpr);
    },

    /**
     * Set default cursor
     * @param {string} [cursorStyle='default'] 例如 crosshair
     */
    setCursorStyle: function (cursorStyle) {
        this.handler.setCursorStyle(cursorStyle);
    },

    /**
     * Find hovered element
     * @param {number} x
     * @param {number} y
     * @return {Object} {target, topTarget}
     */
    findHover: function (x, y) {
        return this.handler.findHover(x, y);
    },

    /**
     * Bind event
     *
     * @param {string} eventName Event name
     * @param {Function} eventHandler Handler function
     * @param {Object} [context] Context object
     */
    on: function(eventName, eventHandler, context) {
        this.handler.on(eventName, eventHandler, context);
    },

    /**
     * Unbind event
     * @param {string} eventName Event name
     * @param {Function} [eventHandler] Handler function
     */
    off: function(eventName, eventHandler) {
        this.handler.off(eventName, eventHandler);
    },

    /**
     * Trigger event manually
     *
     * @param {string} eventName Event name
     * @param {event=} event Event object
     */
    trigger: function (eventName, event) {
        this.handler.trigger(eventName, event);
    },


    /**
     * Clear all objects and the canvas.
     */
    clear: function () {
        this.storage.delRoot();
        this.painter.clear();
    },

    /**
     * Dispose self.
     */
    dispose: function () {
        this.animation.stop();

        this.clear();
        this.storage.dispose();
        this.painter.dispose();
        this.handler.dispose();

        this.animation =
        this.storage =
        this.painter =
        this.handler = null;

        delInstance(this.id);
    }
};



/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_zrender_src_zrender__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_zrender_src_graphic_Text__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__RoadLine__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Scene__ = __webpack_require__(28);





let container = document.querySelector("#canvas");
const zr = __WEBPACK_IMPORTED_MODULE_0_zrender_src_zrender__["a" /* init */](container);

const scene = new __WEBPACK_IMPORTED_MODULE_3__Scene__["a" /* Scene */]();
let line = new __WEBPACK_IMPORTED_MODULE_2__RoadLine__["a" /* RoadLine */]({
   x1: 160,
   y1: 10,
   x2: 700,
   y2: 640
});
scene.add(line);
let line1 = new __WEBPACK_IMPORTED_MODULE_2__RoadLine__["a" /* RoadLine */]({
   x1: 100,
   y1: 70,
   x2: 600,
   y2: 700
});
scene.add(line1);
let text = new __WEBPACK_IMPORTED_MODULE_1_zrender_src_graphic_Text__["a" /* default */]({
   style: {
      text: "导出当前配置"
   }
});
text.on("click", () => {
   let children = scene.children();
   let lines = children.filter(item => {
      return item.type === "roadline";
   });
   let datas = [];
   lines.forEach(item => {
      datas.push(item.toData());
   });
   console.debug(datas);
});
text.position = [10, 10];
scene.add(text);
zr.add(scene);
document.oncontextmenu = function () {
   return false;
};
zr.on("contextmenu", function (evt) {
   let line = new __WEBPACK_IMPORTED_MODULE_2__RoadLine__["a" /* RoadLine */]({
      x1: evt.offsetX,
      y1: evt.offsetY,
      x2: evt.offsetX + 100,
      y2: evt.offsetY + 100
   });
   scene.add(line);
});

window.addEventListener("resize", e => {
   zr.resize({
      width: container.clientWidth,
      height: container.clientHeight
   });
});

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = checkIntersection;
var COLINEAR = intersectResult('colinear');
var PARALLEL = intersectResult('parallel');
var NONE = intersectResult('none');
/**
* Check how two line segments intersect eachother. Line segments are represented
* as (x1, y1)-(x2, y2) and (x3, y3)-(x4, y4).
*
* @param {number} x1
* @param {number} y1
* @param {number} x2
* @param {number} y2
* @param {number} x3
* @param {number} y3
* @param {number} x4
* @param {number} y4
* @return {object} Object describing intersection that looks like
*    {
*      type: none|parallel|colinear|intersecting,
*      point: {x, y} - only defined when type == intersecting
*    }
*/

function checkIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
  var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
  var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
  var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);

  if (denom == 0) {
    if (numeA == 0 && numeB == 0) {
      return COLINEAR;
    }

    return PARALLEL;
  }

  var uA = numeA / denom;
  var uB = numeB / denom;

  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
    return intersecting({
      x: x1 + uA * (x2 - x1),
      y: y1 + uA * (y2 - y1)
    });
  }

  return NONE;
}

function intersecting(point) {
  var result = intersectResult('intersecting');
  result.point = point;
  return result;
}

function intersectResult(type) {
  return {
    type: type
  };
}

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export colinearPointWithinSegment */
/**
* Assuming a point is on same line as a line segment, tell if that point is
* on the line segment.
*
* @param {number} pointX - X of point
* @param {number} pointY - Y of point
* @param {number} startX - X of line segment start
* @param {number} startY - Y of line segment start
* @param {number} endX   - X of line segment end
* @param {number} endY   - Y of line segment end
* @return {boolean} true if point is within segment, false otherwise.
*/
function colinearPointWithinSegment(pointX, pointY, startX, startY, endX, endY) {
  if (startX != endX) {
    if (startX <= pointX && pointX <= endX) return true;
    if (startX >= pointX && pointX >= endX) return true;
  } else {
    if (startY <= pointY && pointY <= endY) return true;
    if (startY >= pointY && pointY >= endY) return true;
  }

  return false;
}

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__check_intersection__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__colinear_point_within_segment__ = __webpack_require__(33);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__check_intersection__["a"]; });
/* unused harmony reexport colinearPointWithinSegment */




/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_vector__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mixin_Draggable__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mixin_Eventful__ = __webpack_require__(6);
/**
 * Handler
 * @module zrender/Handler
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 *         pissang (shenyi.914@gmail.com)
 */






var SILENT = 'silent';

function makeEventPacket(eveType, targetInfo, event) {
    return {
        type: eveType,
        event: event,
        // target can only be an element that is not silent.
        target: targetInfo.target,
        // topTarget can be a silent element.
        topTarget: targetInfo.topTarget,
        cancelBubble: false,
        offsetX: event.zrX,
        offsetY: event.zrY,
        gestureEvent: event.gestureEvent,
        pinchX: event.pinchX,
        pinchY: event.pinchY,
        pinchScale: event.pinchScale,
        wheelDelta: event.zrDelta,
        zrByTouch: event.zrByTouch,
        which: event.which
    };
}

function EmptyProxy () {}
EmptyProxy.prototype.dispose = function () {};

var handlerNames = [
    'click', 'dblclick', 'mousewheel', 'mouseout',
    'mouseup', 'mousedown', 'mousemove', 'contextmenu'
];
/**
 * @alias module:zrender/Handler
 * @constructor
 * @extends module:zrender/mixin/Eventful
 * @param {module:zrender/Storage} storage Storage instance.
 * @param {module:zrender/Painter} painter Painter instance.
 * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
 * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
 */
var Handler = function(storage, painter, proxy, painterRoot) {
    __WEBPACK_IMPORTED_MODULE_3__mixin_Eventful__["a" /* default */].call(this);

    this.storage = storage;

    this.painter = painter;

    this.painterRoot = painterRoot;

    proxy = proxy || new EmptyProxy();

    /**
     * Proxy of event. can be Dom, WebGLSurface, etc.
     */
    this.proxy = proxy;

    // Attach handler
    proxy.handler = this;

    /**
     * {target, topTarget, x, y}
     * @private
     * @type {Object}
     */
    this._hovered = {};

    /**
     * @private
     * @type {Date}
     */
    this._lastTouchMoment;

    /**
     * @private
     * @type {number}
     */
    this._lastX;

    /**
     * @private
     * @type {number}
     */
    this._lastY;


    __WEBPACK_IMPORTED_MODULE_2__mixin_Draggable__["a" /* default */].call(this);

    __WEBPACK_IMPORTED_MODULE_0__core_util__["b" /* each */](handlerNames, function (name) {
        proxy.on && proxy.on(name, this[name], this);
    }, this);
};

Handler.prototype = {

    constructor: Handler,

    mousemove: function (event) {
        var x = event.zrX;
        var y = event.zrY;

        var lastHovered = this._hovered;
        var lastHoveredTarget = lastHovered.target;

        // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
        // (like 'setOption' or 'dispatchAction') in event handlers, we should find
        // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
        // See #6198.
        if (lastHoveredTarget && !lastHoveredTarget.__zr) {
            lastHovered = this.findHover(lastHovered.x, lastHovered.y);
            lastHoveredTarget = lastHovered.target;
        }

        var hovered = this._hovered = this.findHover(x, y);
        var hoveredTarget = hovered.target;

        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');

        // Mouse out on previous hovered element
        if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
            this.dispatchToElement(lastHovered, 'mouseout', event);
        }

        // Mouse moving on one element
        this.dispatchToElement(hovered, 'mousemove', event);

        // Mouse over on a new element
        if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
            this.dispatchToElement(hovered, 'mouseover', event);
        }
    },

    mouseout: function (event) {
        this.dispatchToElement(this._hovered, 'mouseout', event);

        // There might be some doms created by upper layer application
        // at the same level of painter.getViewportRoot() (e.g., tooltip
        // dom created by echarts), where 'globalout' event should not
        // be triggered when mouse enters these doms. (But 'mouseout'
        // should be triggered at the original hovered element as usual).
        var element = event.toElement || event.relatedTarget;
        var innerDom;
        do {
            element = element && element.parentNode;
        }
        while (element && element.nodeType != 9 && !(
            innerDom = element === this.painterRoot
        ));

        !innerDom && this.trigger('globalout', {event: event});
    },

    /**
     * Resize
     */
    resize: function (event) {
        this._hovered = {};
    },

    /**
     * Dispatch event
     * @param {string} eventName
     * @param {event=} eventArgs
     */
    dispatch: function (eventName, eventArgs) {
        var handler = this[eventName];
        handler && handler.call(this, eventArgs);
    },

    /**
     * Dispose
     */
    dispose: function () {

        this.proxy.dispose();

        this.storage =
        this.proxy =
        this.painter = null;
    },

    /**
     * 设置默认的cursor style
     * @param {string} [cursorStyle='default'] 例如 crosshair
     */
    setCursorStyle: function (cursorStyle) {
        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(cursorStyle);
    },

    /**
     * 事件分发代理
     *
     * @private
     * @param {Object} targetInfo {target, topTarget} 目标图形元素
     * @param {string} eventName 事件名称
     * @param {Object} event 事件对象
     */
    dispatchToElement: function (targetInfo, eventName, event) {
        targetInfo = targetInfo || {};
        var el = targetInfo.target;
        if (el && el.silent) {
            return;
        }
        var eventHandler = 'on' + eventName;
        var eventPacket = makeEventPacket(eventName, targetInfo, event);

        while (el) {
            el[eventHandler]
                && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));

            el.trigger(eventName, eventPacket);

            el = el.parent;

            if (eventPacket.cancelBubble) {
                break;
            }
        }

        if (!eventPacket.cancelBubble) {
            // 冒泡到顶级 zrender 对象
            this.trigger(eventName, eventPacket);
            // 分发事件到用户自定义层
            // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
            this.painter && this.painter.eachOtherLayer(function (layer) {
                if (typeof(layer[eventHandler]) == 'function') {
                    layer[eventHandler].call(layer, eventPacket);
                }
                if (layer.trigger) {
                    layer.trigger(eventName, eventPacket);
                }
            });
        }
    },

    /**
     * @private
     * @param {number} x
     * @param {number} y
     * @param {module:zrender/graphic/Displayable} exclude
     * @return {model:zrender/Element}
     * @method
     */
    findHover: function(x, y, exclude) {
        var list = this.storage.getDisplayList();
        var out = {x: x, y: y};

        for (var i = list.length - 1; i >= 0 ; i--) {
            var hoverCheckResult;
            if (list[i] !== exclude
                // getDisplayList may include ignored item in VML mode
                && !list[i].ignore
                && (hoverCheckResult = isHover(list[i], x, y))
            ) {
                !out.topTarget && (out.topTarget = list[i]);
                if (hoverCheckResult !== SILENT) {
                    out.target = list[i];
                    break;
                }
            }
        }

        return out;
    }
};

// Common handlers
__WEBPACK_IMPORTED_MODULE_0__core_util__["b" /* each */](['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
    Handler.prototype[name] = function (event) {
        // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
        var hovered = this.findHover(event.zrX, event.zrY);
        var hoveredTarget = hovered.target;

        if (name === 'mousedown') {
            this._downEl = hoveredTarget;
            this._downPoint = [event.zrX, event.zrY];
            // In case click triggered before mouseup
            this._upEl = hoveredTarget;
        }
        else if (name === 'mosueup') {
            this._upEl = hoveredTarget;
        }
        else if (name === 'click') {
            if (this._downEl !== this._upEl
                // Original click event is triggered on the whole canvas element,
                // including the case that `mousedown` - `mousemove` - `mouseup`,
                // which should be filtered, otherwise it will bring trouble to
                // pan and zoom.
                || !this._downPoint
                // Arbitrary value
                || __WEBPACK_IMPORTED_MODULE_1__core_vector__["f" /* dist */](this._downPoint, [event.zrX, event.zrY]) > 4
            ) {
                return;
            }
            this._downPoint = null;
        }

        this.dispatchToElement(hovered, name, event);
    };
});

function isHover(displayable, x, y) {
    if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
        var el = displayable;
        var isSilent;
        while (el) {
            // If clipped by ancestor.
            // FIXME: If clipPath has neither stroke nor fill,
            // el.clipPath.contain(x, y) will always return false.
            if (el.clipPath && !el.clipPath.contain(x, y))  {
                return false;
            }
            if (el.silent) {
                isSilent = true;
            }
            el = el.parent;
        }
        return isSilent ? SILENT : true;
    }

    return false;
}

__WEBPACK_IMPORTED_MODULE_0__core_util__["j" /* mixin */](Handler, __WEBPACK_IMPORTED_MODULE_3__mixin_Eventful__["a" /* default */]);
__WEBPACK_IMPORTED_MODULE_0__core_util__["j" /* mixin */](Handler, __WEBPACK_IMPORTED_MODULE_2__mixin_Draggable__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Handler);

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__config__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__graphic_Style__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__graphic_Pattern__ = __webpack_require__(24);
/**
 * @module zrender/Layer
 * @author pissang(https://www.github.com/pissang)
 */






function returnFalse() {
    return false;
}

/**
 * 创建dom
 *
 * @inner
 * @param {string} id dom id 待用
 * @param {Painter} painter painter instance
 * @param {number} number
 */
function createDom(id, painter, dpr) {
    var newDom = __WEBPACK_IMPORTED_MODULE_0__core_util__["q" /* createCanvas */]();
    var width = painter.getWidth();
    var height = painter.getHeight();

    var newDomStyle = newDom.style;
    // 没append呢，请原谅我这样写，清晰~
    newDomStyle.position = 'absolute';
    newDomStyle.left = 0;
    newDomStyle.top = 0;
    newDomStyle.width = width + 'px';
    newDomStyle.height = height + 'px';
    newDom.width = width * dpr;
    newDom.height = height * dpr;

    // id不作为索引用，避免可能造成的重名，定义为私有属性
    newDom.setAttribute('data-zr-dom-id', id);
    return newDom;
}

/**
 * @alias module:zrender/Layer
 * @constructor
 * @extends module:zrender/mixin/Transformable
 * @param {string} id
 * @param {module:zrender/Painter} painter
 * @param {number} [dpr]
 */
var Layer = function(id, painter, dpr) {
    var dom;
    dpr = dpr || __WEBPACK_IMPORTED_MODULE_1__config__["b" /* devicePixelRatio */];
    if (typeof id === 'string') {
        dom = createDom(id, painter, dpr);
    }
    // Not using isDom because in node it will return false
    else if (__WEBPACK_IMPORTED_MODULE_0__core_util__["g" /* isObject */](id)) {
        dom = id;
        id = dom.id;
    }
    this.id = id;
    this.dom = dom;

    var domStyle = dom.style;
    if (domStyle) { // Not in node
        dom.onselectstart = returnFalse; // 避免页面选中的尴尬
        domStyle['-webkit-user-select'] = 'none';
        domStyle['user-select'] = 'none';
        domStyle['-webkit-touch-callout'] = 'none';
        domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
        domStyle['padding'] = 0;
        domStyle['margin'] = 0;
        domStyle['border-width'] = 0;
    }

    this.domBack = null;
    this.ctxBack = null;

    this.painter = painter;

    this.config = null;

    // Configs
    /**
     * 每次清空画布的颜色
     * @type {string}
     * @default 0
     */
    this.clearColor = 0;
    /**
     * 是否开启动态模糊
     * @type {boolean}
     * @default false
     */
    this.motionBlur = false;
    /**
     * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
     * @type {number}
     * @default 0.7
     */
    this.lastFrameAlpha = 0.7;

    /**
     * Layer dpr
     * @type {number}
     */
    this.dpr = dpr;
};

Layer.prototype = {

    constructor: Layer,

    elCount: 0,

    __dirty: true,

    initContext: function () {
        this.ctx = this.dom.getContext('2d');
        this.ctx.__currentValues = {};
        this.ctx.dpr = this.dpr;
    },

    createBackBuffer: function () {
        var dpr = this.dpr;

        this.domBack = createDom('back-' + this.id, this.painter, dpr);
        this.ctxBack = this.domBack.getContext('2d');
        this.ctxBack.__currentValues = {};

        if (dpr != 1) {
            this.ctxBack.scale(dpr, dpr);
        }
    },

    /**
     * @param  {number} width
     * @param  {number} height
     */
    resize: function (width, height) {
        var dpr = this.dpr;

        var dom = this.dom;
        var domStyle = dom.style;
        var domBack = this.domBack;

        domStyle.width = width + 'px';
        domStyle.height = height + 'px';

        dom.width = width * dpr;
        dom.height = height * dpr;

        if (domBack) {
            domBack.width = width * dpr;
            domBack.height = height * dpr;

            if (dpr != 1) {
                this.ctxBack.scale(dpr, dpr);
            }
        }
    },

    /**
     * 清空该层画布
     * @param {boolean} clearAll Clear all with out motion blur
     */
    clear: function (clearAll) {
        var dom = this.dom;
        var ctx = this.ctx;
        var width = dom.width;
        var height = dom.height;

        var clearColor = this.clearColor;
        var haveMotionBLur = this.motionBlur && !clearAll;
        var lastFrameAlpha = this.lastFrameAlpha;

        var dpr = this.dpr;

        if (haveMotionBLur) {
            if (!this.domBack) {
                this.createBackBuffer();
            }

            this.ctxBack.globalCompositeOperation = 'copy';
            this.ctxBack.drawImage(
                dom, 0, 0,
                width / dpr,
                height / dpr
            );
        }

        ctx.clearRect(0, 0, width, height);
        if (clearColor) {
            var clearColorGradientOrPattern;
            // Gradient
            if (clearColor.colorStops) {
                // Cache canvas gradient
                clearColorGradientOrPattern = clearColor.__canvasGradient || __WEBPACK_IMPORTED_MODULE_2__graphic_Style__["a" /* default */].getGradient(ctx, clearColor, {
                    x: 0,
                    y: 0,
                    width: width,
                    height: height
                });

                clearColor.__canvasGradient = clearColorGradientOrPattern;
            }
            // Pattern
            else if (clearColor.image) {
                clearColorGradientOrPattern = __WEBPACK_IMPORTED_MODULE_3__graphic_Pattern__["a" /* default */].prototype.getCanvasPattern.call(clearColor, ctx);
            }
            ctx.save();
            ctx.fillStyle = clearColorGradientOrPattern || clearColor;
            ctx.fillRect(0, 0, width, height);
            ctx.restore();
        }

        if (haveMotionBLur) {
            var domBack = this.domBack;
            ctx.save();
            ctx.globalAlpha = lastFrameAlpha;
            ctx.drawImage(domBack, 0, 0, width, height);
            ctx.restore();
        }
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Layer);

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_log__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_BoundingRect__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_timsort__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Layer__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__animation_requestAnimationFrame__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__graphic_Image__ = __webpack_require__(51);
/**
 * Default canvas painter
 * @module zrender/Painter
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 *         errorrik (errorrik@gmail.com)
 *         pissang (https://www.github.com/pissang)
 */










// PENDIGN
// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
//
// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
var MAX_PROGRESSIVE_LAYER_NUMBER = 5;

function parseInt10(val) {
    return parseInt(val, 10);
}

function isLayerValid(layer) {
    if (!layer) {
        return false;
    }

    if (layer.__builtin__) {
        return true;
    }

    if (typeof(layer.resize) !== 'function'
        || typeof(layer.refresh) !== 'function'
    ) {
        return false;
    }

    return true;
}

function preProcessLayer(layer) {
    layer.__unusedCount++;
}

function postProcessLayer(layer) {
    if (layer.__unusedCount == 1) {
        layer.clear();
    }
}

var tmpRect = new __WEBPACK_IMPORTED_MODULE_3__core_BoundingRect__["a" /* default */](0, 0, 0, 0);
var viewRect = new __WEBPACK_IMPORTED_MODULE_3__core_BoundingRect__["a" /* default */](0, 0, 0, 0);
function isDisplayableCulled(el, width, height) {
    tmpRect.copy(el.getBoundingRect());
    if (el.transform) {
        tmpRect.applyTransform(el.transform);
    }
    viewRect.width = width;
    viewRect.height = height;
    return !tmpRect.intersect(viewRect);
}

function isClipPathChanged(clipPaths, prevClipPaths) {
    if (clipPaths == prevClipPaths) { // Can both be null or undefined
        return false;
    }

    if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {
        return true;
    }
    for (var i = 0; i < clipPaths.length; i++) {
        if (clipPaths[i] !== prevClipPaths[i]) {
            return true;
        }
    }
}

function doClip(clipPaths, ctx) {
    for (var i = 0; i < clipPaths.length; i++) {
        var clipPath = clipPaths[i];

        clipPath.setTransform(ctx);
        ctx.beginPath();
        clipPath.buildPath(ctx, clipPath.shape);
        ctx.clip();
        // Transform back
        clipPath.restoreTransform(ctx);
    }
}

function createRoot(width, height) {
    var domRoot = document.createElement('div');

    // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
    domRoot.style.cssText = [
        'position:relative',
        'overflow:hidden',
        'width:' + width + 'px',
        'height:' + height + 'px',
        'padding:0',
        'margin:0',
        'border-width:0'
    ].join(';') + ';';

    return domRoot;
}

/**
 * @alias module:zrender/Painter
 * @constructor
 * @param {HTMLElement} root 绘图容器
 * @param {module:zrender/Storage} storage
 * @param {Object} opts
 */
var Painter = function (root, storage, opts) {

    this.type = 'canvas';

    // In node environment using node-canvas
    var singleCanvas = !root.nodeName // In node ?
        || root.nodeName.toUpperCase() === 'CANVAS';

    this._opts = opts = __WEBPACK_IMPORTED_MODULE_1__core_util__["h" /* extend */]({}, opts || {});

    /**
     * @type {number}
     */
    this.dpr = opts.devicePixelRatio || __WEBPACK_IMPORTED_MODULE_0__config__["b" /* devicePixelRatio */];
    /**
     * @type {boolean}
     * @private
     */
    this._singleCanvas = singleCanvas;
    /**
     * 绘图容器
     * @type {HTMLElement}
     */
    this.root = root;

    var rootStyle = root.style;

    if (rootStyle) {
        rootStyle['-webkit-tap-highlight-color'] = 'transparent';
        rootStyle['-webkit-user-select'] =
        rootStyle['user-select'] =
        rootStyle['-webkit-touch-callout'] = 'none';

        root.innerHTML = '';
    }

    /**
     * @type {module:zrender/Storage}
     */
    this.storage = storage;

    /**
     * @type {Array.<number>}
     * @private
     */
    var zlevelList = this._zlevelList = [];

    /**
     * @type {Object.<string, module:zrender/Layer>}
     * @private
     */
    var layers = this._layers = {};

    /**
     * @type {Object.<string, Object>}
     * @type {private}
     */
    this._layerConfig = {};

    if (!singleCanvas) {
        this._width = this._getSize(0);
        this._height = this._getSize(1);

        var domRoot = this._domRoot = createRoot(
            this._width, this._height
        );
        root.appendChild(domRoot);
    }
    else {
        if (opts.width != null) {
            root.width = opts.width;
        }
        if (opts.height != null) {
            root.height = opts.height;
        }
        // Use canvas width and height directly
        var width = root.width;
        var height = root.height;
        this._width = width;
        this._height = height;

        // Create layer if only one given canvas
        // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
        var mainLayer = new __WEBPACK_IMPORTED_MODULE_5__Layer__["a" /* default */](root, this, 1);
        mainLayer.initContext();
        // FIXME Use canvas width and height
        // mainLayer.resize(width, height);
        layers[0] = mainLayer;
        zlevelList.push(0);

        this._domRoot = root;
    }

    // Layers for progressive rendering
    this._progressiveLayers = [];

    /**
     * @type {module:zrender/Layer}
     * @private
     */
    this._hoverlayer;

    this._hoverElements = [];
};

Painter.prototype = {

    constructor: Painter,

    getType: function () {
        return 'canvas';
    },

    /**
     * If painter use a single canvas
     * @return {boolean}
     */
    isSingleCanvas: function () {
        return this._singleCanvas;
    },
    /**
     * @return {HTMLDivElement}
     */
    getViewportRoot: function () {
        return this._domRoot;
    },

    getViewportRootOffset: function () {
        var viewportRoot = this.getViewportRoot();
        if (viewportRoot) {
            return {
                offsetLeft: viewportRoot.offsetLeft || 0,
                offsetTop: viewportRoot.offsetTop || 0
            };
        }
    },

    /**
     * 刷新
     * @param {boolean} [paintAll=false] 强制绘制所有displayable
     */
    refresh: function (paintAll) {

        var list = this.storage.getDisplayList(true);

        var zlevelList = this._zlevelList;

        this._paintList(list, paintAll);

        // Paint custum layers
        for (var i = 0; i < zlevelList.length; i++) {
            var z = zlevelList[i];
            var layer = this._layers[z];
            if (!layer.__builtin__ && layer.refresh) {
                layer.refresh();
            }
        }

        this.refreshHover();

        if (this._progressiveLayers.length) {
            this._startProgessive();
        }

        return this;
    },

    addHover: function (el, hoverStyle) {
        if (el.__hoverMir) {
            return;
        }
        var elMirror = new el.constructor({
            style: el.style,
            shape: el.shape
        });
        elMirror.__from = el;
        el.__hoverMir = elMirror;
        elMirror.setStyle(hoverStyle);
        this._hoverElements.push(elMirror);
    },

    removeHover: function (el) {
        var elMirror = el.__hoverMir;
        var hoverElements = this._hoverElements;
        var idx = __WEBPACK_IMPORTED_MODULE_1__core_util__["k" /* indexOf */](hoverElements, elMirror);
        if (idx >= 0) {
            hoverElements.splice(idx, 1);
        }
        el.__hoverMir = null;
    },

    clearHover: function (el) {
        var hoverElements = this._hoverElements;
        for (var i = 0; i < hoverElements.length; i++) {
            var from = hoverElements[i].__from;
            if (from) {
                from.__hoverMir = null;
            }
        }
        hoverElements.length = 0;
    },

    refreshHover: function () {
        var hoverElements = this._hoverElements;
        var len = hoverElements.length;
        var hoverLayer = this._hoverlayer;
        hoverLayer && hoverLayer.clear();

        if (!len) {
            return;
        }
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__core_timsort__["a" /* default */])(hoverElements, this.storage.displayableSortFunc);

        // Use a extream large zlevel
        // FIXME?
        if (!hoverLayer) {
            hoverLayer = this._hoverlayer = this.getLayer(1e5);
        }

        var scope = {};
        hoverLayer.ctx.save();
        for (var i = 0; i < len;) {
            var el = hoverElements[i];
            var originalEl = el.__from;
            // Original el is removed
            // PENDING
            if (!(originalEl && originalEl.__zr)) {
                hoverElements.splice(i, 1);
                originalEl.__hoverMir = null;
                len--;
                continue;
            }
            i++;

            // Use transform
            // FIXME style and shape ?
            if (!originalEl.invisible) {
                el.transform = originalEl.transform;
                el.invTransform = originalEl.invTransform;
                el.__clipPaths = originalEl.__clipPaths;
                // el.
                this._doPaintEl(el, hoverLayer, true, scope);
            }
        }
        hoverLayer.ctx.restore();
    },

    _startProgessive: function () {
        var self = this;

        if (!self._furtherProgressive) {
            return;
        }

        // Use a token to stop progress steps triggered by
        // previous zr.refresh calling.
        var token = self._progressiveToken = +new Date();

        self._progress++;
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__animation_requestAnimationFrame__["a" /* default */])(step);

        function step() {
            // In case refreshed or disposed
            if (token === self._progressiveToken && self.storage) {

                self._doPaintList(self.storage.getDisplayList());

                if (self._furtherProgressive) {
                    self._progress++;
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__animation_requestAnimationFrame__["a" /* default */])(step);
                }
                else {
                    self._progressiveToken = -1;
                }
            }
        }
    },

    _clearProgressive: function () {
        this._progressiveToken = -1;
        this._progress = 0;
        __WEBPACK_IMPORTED_MODULE_1__core_util__["b" /* each */](this._progressiveLayers, function (layer) {
            layer.__dirty && layer.clear();
        });
    },

    _paintList: function (list, paintAll) {

        if (paintAll == null) {
            paintAll = false;
        }

        this._updateLayerStatus(list);

        this._clearProgressive();

        this.eachBuiltinLayer(preProcessLayer);

        this._doPaintList(list, paintAll);

        this.eachBuiltinLayer(postProcessLayer);
    },

    _doPaintList: function (list, paintAll) {
        var currentLayer;
        var currentZLevel;
        var ctx;

        // var invTransform = [];
        var scope;

        var progressiveLayerIdx = 0;
        var currentProgressiveLayer;

        var width = this._width;
        var height = this._height;
        var layerProgress;
        var frame = this._progress;
        function flushProgressiveLayer(layer) {
            var dpr = ctx.dpr || 1;
            ctx.save();
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            // Avoid layer don't clear in next progressive frame
            currentLayer.__dirty = true;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
            ctx.restore();
        }

        for (var i = 0, l = list.length; i < l; i++) {
            var el = list[i];
            var elZLevel = this._singleCanvas ? 0 : el.zlevel;

            var elFrame = el.__frame;

            // Flush at current context
            // PENDING
            if (elFrame < 0 && currentProgressiveLayer) {
                flushProgressiveLayer(currentProgressiveLayer);
                currentProgressiveLayer = null;
            }

            // Change draw layer
            if (currentZLevel !== elZLevel) {
                if (ctx) {
                    ctx.restore();
                }

                // Reset scope
                scope = {};

                // Only 0 zlevel if only has one canvas
                currentZLevel = elZLevel;
                currentLayer = this.getLayer(currentZLevel);

                if (!currentLayer.__builtin__) {
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_log__["a" /* default */])(
                        'ZLevel ' + currentZLevel
                        + ' has been used by unkown layer ' + currentLayer.id
                    );
                }

                ctx = currentLayer.ctx;
                ctx.save();

                // Reset the count
                currentLayer.__unusedCount = 0;

                if (currentLayer.__dirty || paintAll) {
                    currentLayer.clear();
                }
            }

            if (!(currentLayer.__dirty || paintAll)) {
                continue;
            }

            if (elFrame >= 0) {
                // Progressive layer changed
                if (!currentProgressiveLayer) {
                    currentProgressiveLayer = this._progressiveLayers[
                        Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)
                    ];

                    currentProgressiveLayer.ctx.save();
                    currentProgressiveLayer.renderScope = {};

                    if (currentProgressiveLayer
                        && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)
                    ) {
                        // flushProgressiveLayer(currentProgressiveLayer);
                        // Quick jump all progressive elements
                        // All progressive element are not dirty, jump over and flush directly
                        i = currentProgressiveLayer.__nextIdxNotProg - 1;
                        // currentProgressiveLayer = null;
                        continue;
                    }

                    layerProgress = currentProgressiveLayer.__progress;

                    if (!currentProgressiveLayer.__dirty) {
                        // Keep rendering
                        frame = layerProgress;
                    }

                    currentProgressiveLayer.__progress = frame + 1;
                }

                if (elFrame === frame) {
                    this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
                }
            }
            else {
                this._doPaintEl(el, currentLayer, paintAll, scope);
            }

            el.__dirty = false;
        }

        if (currentProgressiveLayer) {
            flushProgressiveLayer(currentProgressiveLayer);
        }

        // Restore the lastLayer ctx
        ctx && ctx.restore();
        // If still has clipping state
        // if (scope.prevElClipPaths) {
        //     ctx.restore();
        // }

        this._furtherProgressive = false;
        __WEBPACK_IMPORTED_MODULE_1__core_util__["b" /* each */](this._progressiveLayers, function (layer) {
            if (layer.__maxProgress >= layer.__progress) {
                this._furtherProgressive = true;
            }
        }, this);
    },

    _doPaintEl: function (el, currentLayer, forcePaint, scope) {
        var ctx = currentLayer.ctx;
        var m = el.transform;
        if (
            (currentLayer.__dirty || forcePaint)
            // Ignore invisible element
            && !el.invisible
            // Ignore transparent element
            && el.style.opacity !== 0
            // Ignore scale 0 element, in some environment like node-canvas
            // Draw a scale 0 element can cause all following draw wrong
            // And setTransform with scale 0 will cause set back transform failed.
            && !(m && !m[0] && !m[3])
            // Ignore culled element
            && !(el.culling && isDisplayableCulled(el, this._width, this._height))
        ) {

            var clipPaths = el.__clipPaths;

            // Optimize when clipping on group with several elements
            if (scope.prevClipLayer !== currentLayer
                || isClipPathChanged(clipPaths, scope.prevElClipPaths)
            ) {
                // If has previous clipping state, restore from it
                if (scope.prevElClipPaths) {
                    scope.prevClipLayer.ctx.restore();
                    scope.prevClipLayer = scope.prevElClipPaths = null;

                    // Reset prevEl since context has been restored
                    scope.prevEl = null;
                }
                // New clipping state
                if (clipPaths) {
                    ctx.save();
                    doClip(clipPaths, ctx);
                    scope.prevClipLayer = currentLayer;
                    scope.prevElClipPaths = clipPaths;
                }
            }
            el.beforeBrush && el.beforeBrush(ctx);

            el.brush(ctx, scope.prevEl || null);
            scope.prevEl = el;

            el.afterBrush && el.afterBrush(ctx);
        }
    },

    /**
     * 获取 zlevel 所在层，如果不存在则会创建一个新的层
     * @param {number} zlevel
     * @return {module:zrender/Layer}
     */
    getLayer: function (zlevel) {
        if (this._singleCanvas) {
            return this._layers[0];
        }

        var layer = this._layers[zlevel];
        if (!layer) {
            // Create a new layer
            layer = new __WEBPACK_IMPORTED_MODULE_5__Layer__["a" /* default */]('zr_' + zlevel, this, this.dpr);
            layer.__builtin__ = true;

            if (this._layerConfig[zlevel]) {
                __WEBPACK_IMPORTED_MODULE_1__core_util__["p" /* merge */](layer, this._layerConfig[zlevel], true);
            }

            this.insertLayer(zlevel, layer);

            // Context is created after dom inserted to document
            // Or excanvas will get 0px clientWidth and clientHeight
            layer.initContext();
        }

        return layer;
    },

    insertLayer: function (zlevel, layer) {

        var layersMap = this._layers;
        var zlevelList = this._zlevelList;
        var len = zlevelList.length;
        var prevLayer = null;
        var i = -1;
        var domRoot = this._domRoot;

        if (layersMap[zlevel]) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_log__["a" /* default */])('ZLevel ' + zlevel + ' has been used already');
            return;
        }
        // Check if is a valid layer
        if (!isLayerValid(layer)) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_log__["a" /* default */])('Layer of zlevel ' + zlevel + ' is not valid');
            return;
        }

        if (len > 0 && zlevel > zlevelList[0]) {
            for (i = 0; i < len - 1; i++) {
                if (
                    zlevelList[i] < zlevel
                    && zlevelList[i + 1] > zlevel
                ) {
                    break;
                }
            }
            prevLayer = layersMap[zlevelList[i]];
        }
        zlevelList.splice(i + 1, 0, zlevel);

        layersMap[zlevel] = layer;

        // Vitual layer will not directly show on the screen.
        // (It can be a WebGL layer and assigned to a ZImage element)
        // But it still under management of zrender.
        if (!layer.virtual) {
            if (prevLayer) {
                var prevDom = prevLayer.dom;
                if (prevDom.nextSibling) {
                    domRoot.insertBefore(
                        layer.dom,
                        prevDom.nextSibling
                    );
                }
                else {
                    domRoot.appendChild(layer.dom);
                }
            }
            else {
                if (domRoot.firstChild) {
                    domRoot.insertBefore(layer.dom, domRoot.firstChild);
                }
                else {
                    domRoot.appendChild(layer.dom);
                }
            }
        }
    },

    // Iterate each layer
    eachLayer: function (cb, context) {
        var zlevelList = this._zlevelList;
        var z;
        var i;
        for (i = 0; i < zlevelList.length; i++) {
            z = zlevelList[i];
            cb.call(context, this._layers[z], z);
        }
    },

    // Iterate each buildin layer
    eachBuiltinLayer: function (cb, context) {
        var zlevelList = this._zlevelList;
        var layer;
        var z;
        var i;
        for (i = 0; i < zlevelList.length; i++) {
            z = zlevelList[i];
            layer = this._layers[z];
            if (layer.__builtin__) {
                cb.call(context, layer, z);
            }
        }
    },

    // Iterate each other layer except buildin layer
    eachOtherLayer: function (cb, context) {
        var zlevelList = this._zlevelList;
        var layer;
        var z;
        var i;
        for (i = 0; i < zlevelList.length; i++) {
            z = zlevelList[i];
            layer = this._layers[z];
            if (!layer.__builtin__) {
                cb.call(context, layer, z);
            }
        }
    },

    /**
     * 获取所有已创建的层
     * @param {Array.<module:zrender/Layer>} [prevLayer]
     */
    getLayers: function () {
        return this._layers;
    },

    _updateLayerStatus: function (list) {

        var layers = this._layers;
        var progressiveLayers = this._progressiveLayers;

        var elCountsLastFrame = {};
        var progressiveElCountsLastFrame = {};

        this.eachBuiltinLayer(function (layer, z) {
            elCountsLastFrame[z] = layer.elCount;
            layer.elCount = 0;
            layer.__dirty = false;
        });

        __WEBPACK_IMPORTED_MODULE_1__core_util__["b" /* each */](progressiveLayers, function (layer, idx) {
            progressiveElCountsLastFrame[idx] = layer.elCount;
            layer.elCount = 0;
            layer.__dirty = false;
        });

        var progressiveLayerCount = 0;
        var currentProgressiveLayer;
        var lastProgressiveKey;
        var frameCount = 0;
        for (var i = 0, l = list.length; i < l; i++) {
            var el = list[i];
            var zlevel = this._singleCanvas ? 0 : el.zlevel;
            var layer = layers[zlevel];
            var elProgress = el.progressive;
            if (layer) {
                layer.elCount++;
                layer.__dirty = layer.__dirty || el.__dirty;
            }

            /////// Update progressive
            if (elProgress >= 0) {
                // Fix wrong progressive sequence problem.
                if (lastProgressiveKey !== elProgress) {
                    lastProgressiveKey = elProgress;
                    frameCount++;
                }
                var elFrame = el.__frame = frameCount - 1;
                if (!currentProgressiveLayer) {
                    var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
                    currentProgressiveLayer = progressiveLayers[idx];
                    if (!currentProgressiveLayer) {
                        currentProgressiveLayer = progressiveLayers[idx] = new __WEBPACK_IMPORTED_MODULE_5__Layer__["a" /* default */](
                            'progressive', this, this.dpr
                        );
                        currentProgressiveLayer.initContext();
                    }
                    currentProgressiveLayer.__maxProgress = 0;
                }
                currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
                currentProgressiveLayer.elCount++;

                currentProgressiveLayer.__maxProgress = Math.max(
                    currentProgressiveLayer.__maxProgress, elFrame
                );

                if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
                    // Should keep rendering this  layer because progressive rendering is not finished yet
                    layer.__dirty = true;
                }
            }
            else {
                el.__frame = -1;

                if (currentProgressiveLayer) {
                    currentProgressiveLayer.__nextIdxNotProg = i;
                    progressiveLayerCount++;
                    currentProgressiveLayer = null;
                }
            }
        }

        if (currentProgressiveLayer) {
            progressiveLayerCount++;
            currentProgressiveLayer.__nextIdxNotProg = i;
        }

        // 层中的元素数量有发生变化
        this.eachBuiltinLayer(function (layer, z) {
            if (elCountsLastFrame[z] !== layer.elCount) {
                layer.__dirty = true;
            }
        });

        progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
        __WEBPACK_IMPORTED_MODULE_1__core_util__["b" /* each */](progressiveLayers, function (layer, idx) {
            if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
                el.__dirty = true;
            }
            if (layer.__dirty) {
                layer.__progress = 0;
            }
        });
    },

    /**
     * 清除hover层外所有内容
     */
    clear: function () {
        this.eachBuiltinLayer(this._clearLayer);
        return this;
    },

    _clearLayer: function (layer) {
        layer.clear();
    },

    /**
     * 修改指定zlevel的绘制参数
     *
     * @param {string} zlevel
     * @param {Object} config 配置对象
     * @param {string} [config.clearColor=0] 每次清空画布的颜色
     * @param {string} [config.motionBlur=false] 是否开启动态模糊
     * @param {number} [config.lastFrameAlpha=0.7]
     *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
     */
    configLayer: function (zlevel, config) {
        if (config) {
            var layerConfig = this._layerConfig;
            if (!layerConfig[zlevel]) {
                layerConfig[zlevel] = config;
            }
            else {
                __WEBPACK_IMPORTED_MODULE_1__core_util__["p" /* merge */](layerConfig[zlevel], config, true);
            }

            var layer = this._layers[zlevel];

            if (layer) {
                __WEBPACK_IMPORTED_MODULE_1__core_util__["p" /* merge */](layer, layerConfig[zlevel], true);
            }
        }
    },

    /**
     * 删除指定层
     * @param {number} zlevel 层所在的zlevel
     */
    delLayer: function (zlevel) {
        var layers = this._layers;
        var zlevelList = this._zlevelList;
        var layer = layers[zlevel];
        if (!layer) {
            return;
        }
        layer.dom.parentNode.removeChild(layer.dom);
        delete layers[zlevel];

        zlevelList.splice(__WEBPACK_IMPORTED_MODULE_1__core_util__["k" /* indexOf */](zlevelList, zlevel), 1);
    },

    /**
     * 区域大小变化后重绘
     */
    resize: function (width, height) {
        var domRoot = this._domRoot;
        // FIXME Why ?
        domRoot.style.display = 'none';

        // Save input w/h
        var opts = this._opts;
        width != null && (opts.width = width);
        height != null && (opts.height = height);

        width = this._getSize(0);
        height = this._getSize(1);

        domRoot.style.display = '';

        // 优化没有实际改变的resize
        if (this._width != width || height != this._height) {
            domRoot.style.width = width + 'px';
            domRoot.style.height = height + 'px';

            for (var id in this._layers) {
                if (this._layers.hasOwnProperty(id)) {
                    this._layers[id].resize(width, height);
                }
            }
            __WEBPACK_IMPORTED_MODULE_1__core_util__["b" /* each */](this._progressiveLayers, function (layer) {
                layer.resize(width, height);
            });

            this.refresh(true);
        }

        this._width = width;
        this._height = height;

        return this;
    },

    /**
     * 清除单独的一个层
     * @param {number} zlevel
     */
    clearLayer: function (zlevel) {
        var layer = this._layers[zlevel];
        if (layer) {
            layer.clear();
        }
    },

    /**
     * 释放
     */
    dispose: function () {
        this.root.innerHTML = '';

        this.root =
        this.storage =

        this._domRoot =
        this._layers = null;
    },

    /**
     * Get canvas which has all thing rendered
     * @param {Object} opts
     * @param {string} [opts.backgroundColor]
     * @param {number} [opts.pixelRatio]
     */
    getRenderedCanvas: function (opts) {
        opts = opts || {};
        if (this._singleCanvas) {
            return this._layers[0].dom;
        }

        var imageLayer = new __WEBPACK_IMPORTED_MODULE_5__Layer__["a" /* default */]('image', this, opts.pixelRatio || this.dpr);
        imageLayer.initContext();

        imageLayer.clearColor = opts.backgroundColor;
        imageLayer.clear();

        var displayList = this.storage.getDisplayList(true);

        var scope = {};
        var zlevel;

        var self = this;
        function findAndDrawOtherLayer(smaller, larger) {
            var zlevelList = self._zlevelList;
            if (smaller == null) {
                smaller = -Infinity;
            }
            var intermediateLayer;
            for (var i = 0; i < zlevelList.length; i++) {
                var z = zlevelList[i];
                var layer = self._layers[z];
                if (!layer.__builtin__ && z > smaller && z < larger) {
                    intermediateLayer = layer;
                    break;
                }
            }
            if (intermediateLayer && intermediateLayer.renderToCanvas) {
                imageLayer.ctx.save();
                intermediateLayer.renderToCanvas(imageLayer.ctx);
                imageLayer.ctx.restore();
            }
        }
        for (var i = 0; i < displayList.length; i++) {
            var el = displayList[i];

            if (el.zlevel !== zlevel) {
                findAndDrawOtherLayer(zlevel, el.zlevel);
                zlevel = el.zlevel;
            }
            this._doPaintEl(el, imageLayer, true, scope);
        }

        findAndDrawOtherLayer(zlevel, Infinity);

        return imageLayer.dom;
    },
    /**
     * 获取绘图区域宽度
     */
    getWidth: function () {
        return this._width;
    },

    /**
     * 获取绘图区域高度
     */
    getHeight: function () {
        return this._height;
    },

    _getSize: function (whIdx) {
        var opts = this._opts;
        var wh = ['width', 'height'][whIdx];
        var cwh = ['clientWidth', 'clientHeight'][whIdx];
        var plt = ['paddingLeft', 'paddingTop'][whIdx];
        var prb = ['paddingRight', 'paddingBottom'][whIdx];

        if (opts[wh] != null && opts[wh] !== 'auto') {
            return parseFloat(opts[wh]);
        }

        var root = this.root;
        // IE8 does not support getComputedStyle, but it use VML.
        var stl = document.defaultView.getComputedStyle(root);

        return (
            (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))
            - (parseInt10(stl[plt]) || 0)
            - (parseInt10(stl[prb]) || 0)
        ) | 0;
    },

    pathToImage: function (path, dpr) {
        dpr = dpr || this.dpr;

        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var rect = path.getBoundingRect();
        var style = path.style;
        var shadowBlurSize = style.shadowBlur;
        var shadowOffsetX = style.shadowOffsetX;
        var shadowOffsetY = style.shadowOffsetY;
        var lineWidth = style.hasStroke() ? style.lineWidth : 0;

        var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
        var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
        var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
        var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
        var width = rect.width + leftMargin + rightMargin;
        var height = rect.height + topMargin + bottomMargin;

        canvas.width = width * dpr;
        canvas.height = height * dpr;

        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, width, height);
        ctx.dpr = dpr;

        var pathTransform = {
            position: path.position,
            rotation: path.rotation,
            scale: path.scale
        };
        path.position = [leftMargin - rect.x, topMargin - rect.y];
        path.rotation = 0;
        path.scale = [1, 1];
        path.updateTransform();
        if (path) {
            path.brush(ctx);
        }

        var ImageShape = __WEBPACK_IMPORTED_MODULE_7__graphic_Image__["a" /* default */];
        var imgShape = new ImageShape({
            style: {
                x: 0,
                y: 0,
                image: canvas
            }
        });

        if (pathTransform.position != null) {
            imgShape.position = path.position = pathTransform.position;
        }

        if (pathTransform.rotation != null) {
            imgShape.rotation = path.rotation = pathTransform.rotation;
        }

        if (pathTransform.scale != null) {
            imgShape.scale = path.scale = pathTransform.scale;
        }

        return imgShape;
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Painter);

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_env__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__container_Group__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_timsort__ = __webpack_require__(22);
/**
 * Storage内容仓库模块
 * @module zrender/Storage
 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
 * @author errorrik (errorrik@gmail.com)
 * @author pissang (https://github.com/pissang/)
 */





// Use timsort because in most case elements are partially sorted
// https://jsfiddle.net/pissang/jr4x7mdm/8/


function shapeCompareFunc(a, b) {
    if (a.zlevel === b.zlevel) {
        if (a.z === b.z) {
            // if (a.z2 === b.z2) {
            //     // FIXME Slow has renderidx compare
            //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
            //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
            //     return a.__renderidx - b.__renderidx;
            // }
            return a.z2 - b.z2;
        }
        return a.z - b.z;
    }
    return a.zlevel - b.zlevel;
}
/**
 * 内容仓库 (M)
 * @alias module:zrender/Storage
 * @constructor
 */
var Storage = function () { // jshint ignore:line
    this._roots = [];

    this._displayList = [];

    this._displayListLen = 0;
};

Storage.prototype = {

    constructor: Storage,

    /**
     * @param  {Function} cb
     *
     */
    traverse: function (cb, context) {
        for (var i = 0; i < this._roots.length; i++) {
            this._roots[i].traverse(cb, context);
        }
    },

    /**
     * 返回所有图形的绘制队列
     * @param {boolean} [update=false] 是否在返回前更新该数组
     * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
     *
     * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
     * @return {Array.<module:zrender/graphic/Displayable>}
     */
    getDisplayList: function (update, includeIgnore) {
        includeIgnore = includeIgnore || false;
        if (update) {
            this.updateDisplayList(includeIgnore);
        }
        return this._displayList;
    },

    /**
     * 更新图形的绘制队列。
     * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
     * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
     * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
     */
    updateDisplayList: function (includeIgnore) {
        this._displayListLen = 0;
        var roots = this._roots;
        var displayList = this._displayList;
        for (var i = 0, len = roots.length; i < len; i++) {
            this._updateAndAddDisplayable(roots[i], null, includeIgnore);
        }
        displayList.length = this._displayListLen;

        // for (var i = 0, len = displayList.length; i < len; i++) {
        //     displayList[i].__renderidx = i;
        // }

        // displayList.sort(shapeCompareFunc);
        __WEBPACK_IMPORTED_MODULE_1__core_env__["a" /* default */].canvasSupported && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__core_timsort__["a" /* default */])(displayList, shapeCompareFunc);
    },

    _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {

        if (el.ignore && !includeIgnore) {
            return;
        }

        el.beforeUpdate();

        if (el.__dirty) {

            el.update();

        }

        el.afterUpdate();

        var userSetClipPath = el.clipPath;
        if (userSetClipPath) {

            // FIXME 效率影响
            if (clipPaths) {
                clipPaths = clipPaths.slice();
            }
            else {
                clipPaths = [];
            }

            var currentClipPath = userSetClipPath;
            var parentClipPath = el;
            // Recursively add clip path
            while (currentClipPath) {
                // clipPath 的变换是基于使用这个 clipPath 的元素
                currentClipPath.parent = parentClipPath;
                currentClipPath.updateTransform();

                clipPaths.push(currentClipPath);

                parentClipPath = currentClipPath;
                currentClipPath = currentClipPath.clipPath;
            }
        }

        if (el.isGroup) {
            var children = el._children;

            for (var i = 0; i < children.length; i++) {
                var child = children[i];

                // Force to mark as dirty if group is dirty
                // FIXME __dirtyPath ?
                if (el.__dirty) {
                    child.__dirty = true;
                }

                this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
            }

            // Mark group clean here
            el.__dirty = false;

        }
        else {
            el.__clipPaths = clipPaths;

            this._displayList[this._displayListLen++] = el;
        }
    },

    /**
     * 添加图形(Shape)或者组(Group)到根节点
     * @param {module:zrender/Element} el
     */
    addRoot: function (el) {
        if (el.__storage === this) {
            return;
        }

        if (el instanceof __WEBPACK_IMPORTED_MODULE_2__container_Group__["a" /* default */]) {
            el.addChildrenToStorage(this);
        }

        this.addToStorage(el);
        this._roots.push(el);
    },

    /**
     * 删除指定的图形(Shape)或者组(Group)
     * @param {string|Array.<string>} [el] 如果为空清空整个Storage
     */
    delRoot: function (el) {
        if (el == null) {
            // 不指定el清空
            for (var i = 0; i < this._roots.length; i++) {
                var root = this._roots[i];
                if (root instanceof __WEBPACK_IMPORTED_MODULE_2__container_Group__["a" /* default */]) {
                    root.delChildrenFromStorage(this);
                }
            }

            this._roots = [];
            this._displayList = [];
            this._displayListLen = 0;

            return;
        }

        if (el instanceof Array) {
            for (var i = 0, l = el.length; i < l; i++) {
                this.delRoot(el[i]);
            }
            return;
        }


        var idx = __WEBPACK_IMPORTED_MODULE_0__core_util__["k" /* indexOf */](this._roots, el);
        if (idx >= 0) {
            this.delFromStorage(el);
            this._roots.splice(idx, 1);
            if (el instanceof __WEBPACK_IMPORTED_MODULE_2__container_Group__["a" /* default */]) {
                el.delChildrenFromStorage(this);
            }
        }
    },

    addToStorage: function (el) {
        el.__storage = this;
        el.dirty(false);

        return this;
    },

    delFromStorage: function (el) {
        if (el) {
            el.__storage = null;
        }

        return this;
    },

    /**
     * 清空并且释放Storage
     */
    dispose: function () {
        this._renderList =
        this._roots = null;
    },

    displayableSortFunc: shapeCompareFunc
};

/* harmony default export */ __webpack_exports__["a"] = (Storage);

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_event__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__requestAnimationFrame__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Animator__ = __webpack_require__(13);
/**
 * 动画主类, 调度和管理所有动画控制器
 *
 * @module zrender/animation/Animation
 * @author pissang(https://github.com/pissang)
 */
// TODO Additive animation
// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
// https://developer.apple.com/videos/wwdc2014/#236






/**
 * @typedef {Object} IZRenderStage
 * @property {Function} update
 */

/**
 * @alias module:zrender/animation/Animation
 * @constructor
 * @param {Object} [options]
 * @param {Function} [options.onframe]
 * @param {IZRenderStage} [options.stage]
 * @example
 *     var animation = new Animation();
 *     var obj = {
 *         x: 100,
 *         y: 100
 *     };
 *     animation.animate(node.position)
 *         .when(1000, {
 *             x: 500,
 *             y: 500
 *         })
 *         .when(2000, {
 *             x: 100,
 *             y: 100
 *         })
 *         .start('spline');
 */
var Animation = function (options) {

    options = options || {};

    this.stage = options.stage || {};

    this.onframe = options.onframe || function() {};

    // private properties
    this._clips = [];

    this._running = false;

    this._time;

    this._pausedTime;

    this._pauseStart;

    this._paused = false;

    __WEBPACK_IMPORTED_MODULE_1__core_event__["a" /* Dispatcher */].call(this);
};

Animation.prototype = {

    constructor: Animation,
    /**
     * 添加 clip
     * @param {module:zrender/animation/Clip} clip
     */
    addClip: function (clip) {
        this._clips.push(clip);
    },
    /**
     * 添加 animator
     * @param {module:zrender/animation/Animator} animator
     */
    addAnimator: function (animator) {
        animator.animation = this;
        var clips = animator.getClips();
        for (var i = 0; i < clips.length; i++) {
            this.addClip(clips[i]);
        }
    },
    /**
     * 删除动画片段
     * @param {module:zrender/animation/Clip} clip
     */
    removeClip: function(clip) {
        var idx = __WEBPACK_IMPORTED_MODULE_0__core_util__["k" /* indexOf */](this._clips, clip);
        if (idx >= 0) {
            this._clips.splice(idx, 1);
        }
    },

    /**
     * 删除动画片段
     * @param {module:zrender/animation/Animator} animator
     */
    removeAnimator: function (animator) {
        var clips = animator.getClips();
        for (var i = 0; i < clips.length; i++) {
            this.removeClip(clips[i]);
        }
        animator.animation = null;
    },

    _update: function() {

        var time = new Date().getTime() - this._pausedTime;
        var delta = time - this._time;
        var clips = this._clips;
        var len = clips.length;

        var deferredEvents = [];
        var deferredClips = [];
        for (var i = 0; i < len; i++) {
            var clip = clips[i];
            var e = clip.step(time, delta);
            // Throw out the events need to be called after
            // stage.update, like destroy
            if (e) {
                deferredEvents.push(e);
                deferredClips.push(clip);
            }
        }

        // Remove the finished clip
        for (var i = 0; i < len;) {
            if (clips[i]._needsRemove) {
                clips[i] = clips[len - 1];
                clips.pop();
                len--;
            }
            else {
                i++;
            }
        }

        len = deferredEvents.length;
        for (var i = 0; i < len; i++) {
            deferredClips[i].fire(deferredEvents[i]);
        }

        this._time = time;

        this.onframe(delta);

        this.trigger('frame', delta);

        if (this.stage.update) {
            this.stage.update();
        }
    },

    _startLoop: function () {
        var self = this;

        this._running = true;

        function step() {
            if (self._running) {

                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__requestAnimationFrame__["a" /* default */])(step);

                !self._paused && self._update();
            }
        }

        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__requestAnimationFrame__["a" /* default */])(step);
    },

    /**
     * 开始运行动画
     */
    start: function () {

        this._time = new Date().getTime();
        this._pausedTime = 0;

        this._startLoop();
    },
    /**
     * 停止运行动画
     */
    stop: function () {
        this._running = false;
    },

    /**
     * Pause
     */
    pause: function () {
        if (!this._paused) {
            this._pauseStart = new Date().getTime();
            this._paused = true;
        }
    },

    /**
     * Resume
     */
    resume: function () {
        if (this._paused) {
            this._pausedTime += (new Date().getTime()) - this._pauseStart;
            this._paused = false;
        }
    },

    /**
     * 清除所有动画片段
     */
    clear: function () {
        this._clips = [];
    },
    /**
     * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
     * @param  {Object} target
     * @param  {Object} options
     * @param  {boolean} [options.loop=false] 是否循环播放动画
     * @param  {Function} [options.getter=null]
     *         如果指定getter函数，会通过getter函数取属性值
     * @param  {Function} [options.setter=null]
     *         如果指定setter函数，会通过setter函数设置属性值
     * @return {module:zrender/animation/Animation~Animator}
     */
    // TODO Gap
    animate: function (target, options) {
        options = options || {};

        var animator = new __WEBPACK_IMPORTED_MODULE_3__Animator__["a" /* default */](
            target,
            options.loop,
            options.getter,
            options.setter
        );

        this.addAnimator(animator);

        return animator;
    }
};

__WEBPACK_IMPORTED_MODULE_0__core_util__["j" /* mixin */](Animation, __WEBPACK_IMPORTED_MODULE_1__core_event__["a" /* Dispatcher */]);

/* harmony default export */ __webpack_exports__["a"] = (Animation);

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__easing__ = __webpack_require__(41);
/**
 * 动画主控制器
 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
 * @config life(1000) 动画时长
 * @config delay(0) 动画延迟时间
 * @config loop(true)
 * @config gap(0) 循环的间隔时间
 * @config onframe
 * @config easing(optional)
 * @config ondestroy(optional)
 * @config onrestart(optional)
 *
 * TODO pause
 */



function Clip(options) {

    this._target = options.target;

    // 生命周期
    this._life = options.life || 1000;
    // 延时
    this._delay = options.delay || 0;
    // 开始时间
    // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
    this._initialized = false;

    // 是否循环
    this.loop = options.loop == null ? false : options.loop;

    this.gap = options.gap || 0;

    this.easing = options.easing || 'Linear';

    this.onframe = options.onframe;
    this.ondestroy = options.ondestroy;
    this.onrestart = options.onrestart;

    this._pausedTime = 0;
    this._paused = false;
}

Clip.prototype = {

    constructor: Clip,

    step: function (globalTime, deltaTime) {
        // Set startTime on first step, or _startTime may has milleseconds different between clips
        // PENDING
        if (!this._initialized) {
            this._startTime = globalTime + this._delay;
            this._initialized = true;
        }

        if (this._paused) {
            this._pausedTime += deltaTime;
            return;
        }

        var percent = (globalTime - this._startTime - this._pausedTime) / this._life;

        // 还没开始
        if (percent < 0) {
            return;
        }

        percent = Math.min(percent, 1);

        var easing = this.easing;
        var easingFunc = typeof easing == 'string' ? __WEBPACK_IMPORTED_MODULE_0__easing__["a" /* default */][easing] : easing;
        var schedule = typeof easingFunc === 'function'
            ? easingFunc(percent)
            : percent;

        this.fire('frame', schedule);

        // 结束
        if (percent == 1) {
            if (this.loop) {
                this.restart (globalTime);
                // 重新开始周期
                // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
                return 'restart';
            }

            // 动画完成将这个控制器标识为待删除
            // 在Animation.update中进行批量删除
            this._needsRemove = true;
            return 'destroy';
        }

        return null;
    },

    restart: function (globalTime) {
        var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
        this._startTime = globalTime - remainder + this.gap;
        this._pausedTime = 0;

        this._needsRemove = false;
    },

    fire: function (eventType, arg) {
        eventType = 'on' + eventType;
        if (this[eventType]) {
            this[eventType](this._target, arg);
        }
    },

    pause: function () {
        this._paused = true;
    },

    resume: function () {
        this._paused = false;
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Clip);

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
 * @see http://sole.github.io/tween.js/examples/03_graphs.html
 * @exports zrender/animation/easing
 */
var easing = {
    /**
    * @param {number} k
    * @return {number}
    */
    linear: function (k) {
        return k;
    },

    /**
    * @param {number} k
    * @return {number}
    */
    quadraticIn: function (k) {
        return k * k;
    },
    /**
    * @param {number} k
    * @return {number}
    */
    quadraticOut: function (k) {
        return k * (2 - k);
    },
    /**
    * @param {number} k
    * @return {number}
    */
    quadraticInOut: function (k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k;
        }
        return -0.5 * (--k * (k - 2) - 1);
    },

    // 三次方的缓动（t^3）
    /**
    * @param {number} k
    * @return {number}
    */
    cubicIn: function (k) {
        return k * k * k;
    },
    /**
    * @param {number} k
    * @return {number}
    */
    cubicOut: function (k) {
        return --k * k * k + 1;
    },
    /**
    * @param {number} k
    * @return {number}
    */
    cubicInOut: function (k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k + 2);
    },

    // 四次方的缓动（t^4）
    /**
    * @param {number} k
    * @return {number}
    */
    quarticIn: function (k) {
        return k * k * k * k;
    },
    /**
    * @param {number} k
    * @return {number}
    */
    quarticOut: function (k) {
        return 1 - (--k * k * k * k);
    },
    /**
    * @param {number} k
    * @return {number}
    */
    quarticInOut: function (k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k * k * k;
        }
        return -0.5 * ((k -= 2) * k * k * k - 2);
    },

    // 五次方的缓动（t^5）
    /**
    * @param {number} k
    * @return {number}
    */
    quinticIn: function (k) {
        return k * k * k * k * k;
    },
    /**
    * @param {number} k
    * @return {number}
    */
    quinticOut: function (k) {
        return --k * k * k * k * k + 1;
    },
    /**
    * @param {number} k
    * @return {number}
    */
    quinticInOut: function (k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k * k * k + 2);
    },

    // 正弦曲线的缓动（sin(t)）
    /**
    * @param {number} k
    * @return {number}
    */
    sinusoidalIn: function (k) {
        return 1 - Math.cos(k * Math.PI / 2);
    },
    /**
    * @param {number} k
    * @return {number}
    */
    sinusoidalOut: function (k) {
        return Math.sin(k * Math.PI / 2);
    },
    /**
    * @param {number} k
    * @return {number}
    */
    sinusoidalInOut: function (k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
    },

    // 指数曲线的缓动（2^t）
    /**
    * @param {number} k
    * @return {number}
    */
    exponentialIn: function (k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
    },
    /**
    * @param {number} k
    * @return {number}
    */
    exponentialOut: function (k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
    },
    /**
    * @param {number} k
    * @return {number}
    */
    exponentialInOut: function (k) {
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if ((k *= 2) < 1) {
            return 0.5 * Math.pow(1024, k - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
    },

    // 圆形曲线的缓动（sqrt(1-t^2)）
    /**
    * @param {number} k
    * @return {number}
    */
    circularIn: function (k) {
        return 1 - Math.sqrt(1 - k * k);
    },
    /**
    * @param {number} k
    * @return {number}
    */
    circularOut: function (k) {
        return Math.sqrt(1 - (--k * k));
    },
    /**
    * @param {number} k
    * @return {number}
    */
    circularInOut: function (k) {
        if ((k *= 2) < 1) {
            return -0.5 * (Math.sqrt(1 - k * k) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    },

    // 创建类似于弹簧在停止前来回振荡的动画
    /**
    * @param {number} k
    * @return {number}
    */
    elasticIn: function (k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if (!a || a < 1) {
            a = 1; s = p / 4;
        }
        else {
            s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return -(a * Math.pow(2, 10 * (k -= 1)) *
                    Math.sin((k - s) * (2 * Math.PI) / p));
    },
    /**
    * @param {number} k
    * @return {number}
    */
    elasticOut: function (k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if (!a || a < 1) {
            a = 1; s = p / 4;
        }
        else {
            s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return (a * Math.pow(2, -10 * k) *
                Math.sin((k - s) * (2 * Math.PI) / p) + 1);
    },
    /**
    * @param {number} k
    * @return {number}
    */
    elasticInOut: function (k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if (!a || a < 1) {
            a = 1; s = p / 4;
        }
        else {
            s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        if ((k *= 2) < 1) {
            return -0.5 * (a * Math.pow(2, 10 * (k -= 1))
                * Math.sin((k - s) * (2 * Math.PI) / p));
        }
        return a * Math.pow(2, -10 * (k -= 1))
                * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;

    },

    // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
    /**
    * @param {number} k
    * @return {number}
    */
    backIn: function (k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
    },
    /**
    * @param {number} k
    * @return {number}
    */
    backOut: function (k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
    },
    /**
    * @param {number} k
    * @return {number}
    */
    backInOut: function (k) {
        var s = 1.70158 * 1.525;
        if ((k *= 2) < 1) {
            return 0.5 * (k * k * ((s + 1) * k - s));
        }
        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    },

    // 创建弹跳效果
    /**
    * @param {number} k
    * @return {number}
    */
    bounceIn: function (k) {
        return 1 - easing.bounceOut(1 - k);
    },
    /**
    * @param {number} k
    * @return {number}
    */
    bounceOut: function (k) {
        if (k < (1 / 2.75)) {
            return 7.5625 * k * k;
        }
        else if (k < (2 / 2.75)) {
            return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
        }
        else if (k < (2.5 / 2.75)) {
            return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
        }
        else {
            return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
        }
    },
    /**
    * @param {number} k
    * @return {number}
    */
    bounceInOut: function (k) {
        if (k < 0.5) {
            return easing.bounceIn(k * 2) * 0.5;
        }
        return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
    }
};

/* harmony default export */ __webpack_exports__["a"] = (easing);

/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = containStroke;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(16);



var PI2 = Math.PI * 2;

/**
 * 圆弧描边包含判断
 * @param  {number}  cx
 * @param  {number}  cy
 * @param  {number}  r
 * @param  {number}  startAngle
 * @param  {number}  endAngle
 * @param  {boolean}  anticlockwise
 * @param  {number} lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {Boolean}
 */
function containStroke(
    cx, cy, r, startAngle, endAngle, anticlockwise,
    lineWidth, x, y
) {

    if (lineWidth === 0) {
        return false;
    }
    var _l = lineWidth;

    x -= cx;
    y -= cy;
    var d = Math.sqrt(x * x + y * y);

    if ((d - _l > r) || (d + _l < r)) {
        return false;
    }
    if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
        // Is a circle
        return true;
    }
    if (anticlockwise) {
        var tmp = startAngle;
        startAngle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["a" /* normalizeRadian */])(endAngle);
        endAngle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["a" /* normalizeRadian */])(tmp);
    } else {
        startAngle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["a" /* normalizeRadian */])(startAngle);
        endAngle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util__["a" /* normalizeRadian */])(endAngle);
    }
    if (startAngle > endAngle) {
        endAngle += PI2;
    }

    var angle = Math.atan2(y, x);
    if (angle < 0) {
        angle += PI2;
    }
    return (angle >= startAngle && angle <= endAngle)
        || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
}

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = containStroke;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_curve__ = __webpack_require__(3);



/**
 * 三次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  x3
 * @param  {number}  y3
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    var _l = lineWidth;
    // Quick reject
    if (
        (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)
        || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)
        || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)
        || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)
    ) {
        return false;
    }
    var d = __WEBPACK_IMPORTED_MODULE_0__core_curve__["h" /* cubicProjectPoint */](
        x0, y0, x1, y1, x2, y2, x3, y3,
        x, y, null
    );
    return d <= _l / 2;
}

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = containStroke;

/**
 * 线段包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    var _l = lineWidth;
    var _a = 0;
    var _b = x0;
    // Quick reject
    if (
        (y > y0 + _l && y > y1 + _l)
        || (y < y0 - _l && y < y1 - _l)
        || (x > x0 + _l && x > x1 + _l)
        || (x < x0 - _l && x < x1 - _l)
    ) {
        return false;
    }

    if (x0 !== x1) {
        _a = (y0 - y1) / (x0 - x1);
        _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;
    }
    else {
        return Math.abs(x - x0) <= _l / 2;
    }
    var tmp = _a * x - y + _b;
    var _s = tmp * tmp / (_a * _a + 1);
    return _s <= _l / 2 * _l / 2;
}

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = contain;
/* harmony export (immutable) */ __webpack_exports__["a"] = containStroke;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_PathProxy__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__line__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cubic__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__quadratic__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__arc__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_curve__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__windingLine__ = __webpack_require__(47);









var CMD = __WEBPACK_IMPORTED_MODULE_0__core_PathProxy__["a" /* default */].CMD;
var PI2 = Math.PI * 2;

var EPSILON = 1e-4;

function isAroundEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
}

// 临时数组
var roots = [-1, -1, -1];
var extrema = [-1, -1];

function swapExtrema() {
    var tmp = extrema[0];
    extrema[0] = extrema[1];
    extrema[1] = tmp;
}

function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
    // Quick reject
    if (
        (y > y0 && y > y1 && y > y2 && y > y3)
        || (y < y0 && y < y1 && y < y2 && y < y3)
    ) {
        return 0;
    }
    var nRoots = __WEBPACK_IMPORTED_MODULE_6__core_curve__["a" /* cubicRootAt */](y0, y1, y2, y3, y, roots);
    if (nRoots === 0) {
        return 0;
    }
    else {
        var w = 0;
        var nExtrema = -1;
        var y0_, y1_;
        for (var i = 0; i < nRoots; i++) {
            var t = roots[i];

            // Avoid winding error when intersection point is the connect point of two line of polygon
            var unit = (t === 0 || t === 1) ? 0.5 : 1;

            var x_ = __WEBPACK_IMPORTED_MODULE_6__core_curve__["b" /* cubicAt */](x0, x1, x2, x3, t);
            if (x_ < x) { // Quick reject
                continue;
            }
            if (nExtrema < 0) {
                nExtrema = __WEBPACK_IMPORTED_MODULE_6__core_curve__["c" /* cubicExtrema */](y0, y1, y2, y3, extrema);
                if (extrema[1] < extrema[0] && nExtrema > 1) {
                    swapExtrema();
                }
                y0_ = __WEBPACK_IMPORTED_MODULE_6__core_curve__["b" /* cubicAt */](y0, y1, y2, y3, extrema[0]);
                if (nExtrema > 1) {
                    y1_ = __WEBPACK_IMPORTED_MODULE_6__core_curve__["b" /* cubicAt */](y0, y1, y2, y3, extrema[1]);
                }
            }
            if (nExtrema == 2) {
                // 分成三段单调函数
                if (t < extrema[0]) {
                    w += y0_ < y0 ? unit : -unit;
                }
                else if (t < extrema[1]) {
                    w += y1_ < y0_ ? unit : -unit;
                }
                else {
                    w += y3 < y1_ ? unit : -unit;
                }
            }
            else {
                // 分成两段单调函数
                if (t < extrema[0]) {
                    w += y0_ < y0 ? unit : -unit;
                }
                else {
                    w += y3 < y0_ ? unit : -unit;
                }
            }
        }
        return w;
    }
}

function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
    // Quick reject
    if (
        (y > y0 && y > y1 && y > y2)
        || (y < y0 && y < y1 && y < y2)
    ) {
        return 0;
    }
    var nRoots = __WEBPACK_IMPORTED_MODULE_6__core_curve__["d" /* quadraticRootAt */](y0, y1, y2, y, roots);
    if (nRoots === 0) {
        return 0;
    }
    else {
        var t = __WEBPACK_IMPORTED_MODULE_6__core_curve__["e" /* quadraticExtremum */](y0, y1, y2);
        if (t >= 0 && t <= 1) {
            var w = 0;
            var y_ = __WEBPACK_IMPORTED_MODULE_6__core_curve__["f" /* quadraticAt */](y0, y1, y2, t);
            for (var i = 0; i < nRoots; i++) {
                // Remove one endpoint.
                var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;

                var x_ = __WEBPACK_IMPORTED_MODULE_6__core_curve__["f" /* quadraticAt */](x0, x1, x2, roots[i]);
                if (x_ < x) {   // Quick reject
                    continue;
                }
                if (roots[i] < t) {
                    w += y_ < y0 ? unit : -unit;
                }
                else {
                    w += y2 < y_ ? unit : -unit;
                }
            }
            return w;
        }
        else {
            // Remove one endpoint.
            var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;

            var x_ = __WEBPACK_IMPORTED_MODULE_6__core_curve__["f" /* quadraticAt */](x0, x1, x2, roots[0]);
            if (x_ < x) {   // Quick reject
                return 0;
            }
            return y2 < y0 ? unit : -unit;
        }
    }
}

// TODO
// Arc 旋转
function windingArc(
    cx, cy, r, startAngle, endAngle, anticlockwise, x, y
) {
    y -= cy;
    if (y > r || y < -r) {
        return 0;
    }
    var tmp = Math.sqrt(r * r - y * y);
    roots[0] = -tmp;
    roots[1] = tmp;

    var diff = Math.abs(startAngle - endAngle);
    if (diff < 1e-4) {
        return 0;
    }
    if (diff % PI2 < 1e-4) {
        // Is a circle
        startAngle = 0;
        endAngle = PI2;
        var dir = anticlockwise ? 1 : -1;
        if (x >= roots[0] + cx && x <= roots[1] + cx) {
            return dir;
        } else {
            return 0;
        }
    }

    if (anticlockwise) {
        var tmp = startAngle;
        startAngle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__util__["a" /* normalizeRadian */])(endAngle);
        endAngle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__util__["a" /* normalizeRadian */])(tmp);
    }
    else {
        startAngle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__util__["a" /* normalizeRadian */])(startAngle);
        endAngle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__util__["a" /* normalizeRadian */])(endAngle);
    }
    if (startAngle > endAngle) {
        endAngle += PI2;
    }

    var w = 0;
    for (var i = 0; i < 2; i++) {
        var x_ = roots[i];
        if (x_ + cx > x) {
            var angle = Math.atan2(y, x_);
            var dir = anticlockwise ? 1 : -1;
            if (angle < 0) {
                angle = PI2 + angle;
            }
            if (
                (angle >= startAngle && angle <= endAngle)
                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)
            ) {
                if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
                    dir = -dir;
                }
                w += dir;
            }
        }
    }
    return w;
}

function containPath(data, lineWidth, isStroke, x, y) {
    var w = 0;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;

    for (var i = 0; i < data.length;) {
        var cmd = data[i++];
        // Begin a new subpath
        if (cmd === CMD.M && i > 1) {
            // Close previous subpath
            if (!isStroke) {
                w += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__windingLine__["a" /* default */])(xi, yi, x0, y0, x, y);
            }
            // 如果被任何一个 subpath 包含
            // if (w !== 0) {
            //     return true;
            // }
        }

        if (i == 1) {
            // 如果第一个命令是 L, C, Q
            // 则 previous point 同绘制命令的第一个 point
            //
            // 第一个命令为 Arc 的情况下会在后面特殊处理
            xi = data[i];
            yi = data[i + 1];

            x0 = xi;
            y0 = yi;
        }

        switch (cmd) {
            case CMD.M:
                // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
                // 在 closePath 的时候使用
                x0 = data[i++];
                y0 = data[i++];
                xi = x0;
                yi = y0;
                break;
            case CMD.L:
                if (isStroke) {
                    if (__WEBPACK_IMPORTED_MODULE_1__line__["a" /* containStroke */](xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
                        return true;
                    }
                }
                else {
                    // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
                    w += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__windingLine__["a" /* default */])(xi, yi, data[i], data[i + 1], x, y) || 0;
                }
                xi = data[i++];
                yi = data[i++];
                break;
            case CMD.C:
                if (isStroke) {
                    if (__WEBPACK_IMPORTED_MODULE_2__cubic__["a" /* containStroke */](xi, yi,
                        data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
                        lineWidth, x, y
                    )) {
                        return true;
                    }
                }
                else {
                    w += windingCubic(
                        xi, yi,
                        data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
                        x, y
                    ) || 0;
                }
                xi = data[i++];
                yi = data[i++];
                break;
            case CMD.Q:
                if (isStroke) {
                    if (__WEBPACK_IMPORTED_MODULE_3__quadratic__["a" /* containStroke */](xi, yi,
                        data[i++], data[i++], data[i], data[i + 1],
                        lineWidth, x, y
                    )) {
                        return true;
                    }
                }
                else {
                    w += windingQuadratic(
                        xi, yi,
                        data[i++], data[i++], data[i], data[i + 1],
                        x, y
                    ) || 0;
                }
                xi = data[i++];
                yi = data[i++];
                break;
            case CMD.A:
                // TODO Arc 判断的开销比较大
                var cx = data[i++];
                var cy = data[i++];
                var rx = data[i++];
                var ry = data[i++];
                var theta = data[i++];
                var dTheta = data[i++];
                // TODO Arc 旋转
                var psi = data[i++];
                var anticlockwise = 1 - data[i++];
                var x1 = Math.cos(theta) * rx + cx;
                var y1 = Math.sin(theta) * ry + cy;
                // 不是直接使用 arc 命令
                if (i > 1) {
                    w += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__windingLine__["a" /* default */])(xi, yi, x1, y1, x, y);
                }
                else {
                    // 第一个命令起点还未定义
                    x0 = x1;
                    y0 = y1;
                }
                // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
                var _x = (x - cx) * ry / rx + cx;
                if (isStroke) {
                    if (__WEBPACK_IMPORTED_MODULE_4__arc__["a" /* containStroke */](
                        cx, cy, ry, theta, theta + dTheta, anticlockwise,
                        lineWidth, _x, y
                    )) {
                        return true;
                    }
                }
                else {
                    w += windingArc(
                        cx, cy, ry, theta, theta + dTheta, anticlockwise,
                        _x, y
                    );
                }
                xi = Math.cos(theta + dTheta) * rx + cx;
                yi = Math.sin(theta + dTheta) * ry + cy;
                break;
            case CMD.R:
                x0 = xi = data[i++];
                y0 = yi = data[i++];
                var width = data[i++];
                var height = data[i++];
                var x1 = x0 + width;
                var y1 = y0 + height;
                if (isStroke) {
                    if (__WEBPACK_IMPORTED_MODULE_1__line__["a" /* containStroke */](x0, y0, x1, y0, lineWidth, x, y)
                        || __WEBPACK_IMPORTED_MODULE_1__line__["a" /* containStroke */](x1, y0, x1, y1, lineWidth, x, y)
                        || __WEBPACK_IMPORTED_MODULE_1__line__["a" /* containStroke */](x1, y1, x0, y1, lineWidth, x, y)
                        || __WEBPACK_IMPORTED_MODULE_1__line__["a" /* containStroke */](x0, y1, x0, y0, lineWidth, x, y)
                    ) {
                        return true;
                    }
                }
                else {
                    // FIXME Clockwise ?
                    w += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__windingLine__["a" /* default */])(x1, y0, x1, y1, x, y);
                    w += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__windingLine__["a" /* default */])(x0, y1, x0, y0, x, y);
                }
                break;
            case CMD.Z:
                if (isStroke) {
                    if (__WEBPACK_IMPORTED_MODULE_1__line__["a" /* containStroke */](
                        xi, yi, x0, y0, lineWidth, x, y
                    )) {
                        return true;
                    }
                }
                else {
                    // Close a subpath
                    w += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__windingLine__["a" /* default */])(xi, yi, x0, y0, x, y);
                    // 如果被任何一个 subpath 包含
                    // FIXME subpaths may overlap
                    // if (w !== 0) {
                    //     return true;
                    // }
                }
                xi = x0;
                yi = y0;
                break;
        }
    }
    if (!isStroke && !isAroundEqual(yi, y0)) {
        w += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__windingLine__["a" /* default */])(xi, yi, x0, y0, x, y) || 0;
    }
    return w !== 0;
}

function contain(pathData, x, y) {
    return containPath(pathData, 0, false, x, y);
}

function containStroke(pathData, lineWidth, x, y) {
    return containPath(pathData, lineWidth, true, x, y);
}

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = containStroke;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_curve__ = __webpack_require__(3);


/**
 * 二次贝塞尔曲线描边包含判断
 * @param  {number}  x0
 * @param  {number}  y0
 * @param  {number}  x1
 * @param  {number}  y1
 * @param  {number}  x2
 * @param  {number}  y2
 * @param  {number}  lineWidth
 * @param  {number}  x
 * @param  {number}  y
 * @return {boolean}
 */
function containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    var _l = lineWidth;
    // Quick reject
    if (
        (y > y0 + _l && y > y1 + _l && y > y2 + _l)
        || (y < y0 - _l && y < y1 - _l && y < y2 - _l)
        || (x > x0 + _l && x > x1 + _l && x > x2 + _l)
        || (x < x0 - _l && x < x1 - _l && x < x2 - _l)
    ) {
        return false;
    }
    var d = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_curve__["g" /* quadraticProjectPoint */])(
        x0, y0, x1, y1, x2, y2,
        x, y, null
    );
    return d <= _l / 2;
}


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = windingLine;

function windingLine(x0, y0, x1, y1, x, y) {
    if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
        return 0;
    }
    // Ignore horizontal line
    if (y1 === y0) {
        return 0;
    }
    var dir = y1 < y0 ? 1 : -1;
    var t = (y - y0) / (y1 - y0);

    // Avoid winding error when intersection point is the connect point of two line of polygon
    if (t === 1 || t === 0) {
        dir = y1 < y0 ? 0.5 : -0.5;
    }

    var x_ = t * (x1 - x0) + x0;

    return x_ > x ? dir : 0;
}

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__event__ = __webpack_require__(8);
/**
 * Only implements needed gestures for mobile.
 */



var GestureMgr = function () {

    /**
     * @private
     * @type {Array.<Object>}
     */
    this._track = [];
};

GestureMgr.prototype = {

    constructor: GestureMgr,

    recognize: function (event, target, root) {
        this._doTrack(event, target, root);
        return this._recognize(event);
    },

    clear: function () {
        this._track.length = 0;
        return this;
    },

    _doTrack: function (event, target, root) {
        var touches = event.touches;

        if (!touches) {
            return;
        }

        var trackItem = {
            points: [],
            touches: [],
            target: target,
            event: event
        };

        for (var i = 0, len = touches.length; i < len; i++) {
            var touch = touches[i];
            var pos = __WEBPACK_IMPORTED_MODULE_0__event__["e" /* clientToLocal */](root, touch, {});
            trackItem.points.push([pos.zrX, pos.zrY]);
            trackItem.touches.push(touch);
        }

        this._track.push(trackItem);
    },

    _recognize: function (event) {
        for (var eventName in recognizers) {
            if (recognizers.hasOwnProperty(eventName)) {
                var gestureInfo = recognizers[eventName](this._track, event);
                if (gestureInfo) {
                    return gestureInfo;
                }
            }
        }
    }
};

function dist(pointPair) {
    var dx = pointPair[1][0] - pointPair[0][0];
    var dy = pointPair[1][1] - pointPair[0][1];

    return Math.sqrt(dx * dx + dy * dy);
}

function center(pointPair) {
    return [
        (pointPair[0][0] + pointPair[1][0]) / 2,
        (pointPair[0][1] + pointPair[1][1]) / 2
    ];
}

var recognizers = {

    pinch: function (track, event) {
        var trackLen = track.length;

        if (!trackLen) {
            return;
        }

        var pinchEnd = (track[trackLen - 1] || {}).points;
        var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;

        if (pinchPre
            && pinchPre.length > 1
            && pinchEnd
            && pinchEnd.length > 1
        ) {
            var pinchScale = dist(pinchEnd) / dist(pinchPre);
            !isFinite(pinchScale) && (pinchScale = 1);

            event.pinchScale = pinchScale;

            var pinchCenter = center(pinchEnd);
            event.pinchX = pinchCenter[0];
            event.pinchY = pinchCenter[1];

            return {
                type: 'pinch',
                target: track[0].target,
                event: event
            };
        }
    }

    // Only pinch currently.
};

/* harmony default export */ __webpack_exports__["a"] = (GestureMgr);

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export fromPoints */
/* harmony export (immutable) */ __webpack_exports__["a"] = fromLine;
/* harmony export (immutable) */ __webpack_exports__["b"] = fromCubic;
/* harmony export (immutable) */ __webpack_exports__["c"] = fromQuadratic;
/* harmony export (immutable) */ __webpack_exports__["d"] = fromArc;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__curve__ = __webpack_require__(3);
/**
 * @author Yi Shen(https://github.com/pissang)
 */




var mathMin = Math.min;
var mathMax = Math.max;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI2 = Math.PI * 2;

var start = __WEBPACK_IMPORTED_MODULE_0__vector__["b" /* create */]();
var end = __WEBPACK_IMPORTED_MODULE_0__vector__["b" /* create */]();
var extremity = __WEBPACK_IMPORTED_MODULE_0__vector__["b" /* create */]();

/**
 * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
 * @module zrender/core/bbox
 * @param {Array<Object>} points 顶点数组
 * @param {number} min
 * @param {number} max
 */
function fromPoints(points, min, max) {
    if (points.length === 0) {
        return;
    }
    var p = points[0];
    var left = p[0];
    var right = p[0];
    var top = p[1];
    var bottom = p[1];
    var i;

    for (i = 1; i < points.length; i++) {
        p = points[i];
        left = mathMin(left, p[0]);
        right = mathMax(right, p[0]);
        top = mathMin(top, p[1]);
        bottom = mathMax(bottom, p[1]);
    }

    min[0] = left;
    min[1] = top;
    max[0] = right;
    max[1] = bottom;
}

/**
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */
function fromLine(x0, y0, x1, y1, min, max) {
    min[0] = mathMin(x0, x1);
    min[1] = mathMin(y0, y1);
    max[0] = mathMax(x0, x1);
    max[1] = mathMax(y0, y1);
}

var xDim = [];
var yDim = [];
/**
 * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */
function fromCubic(
    x0, y0, x1, y1, x2, y2, x3, y3, min, max
) {
    var cubicExtrema = __WEBPACK_IMPORTED_MODULE_1__curve__["c" /* cubicExtrema */];
    var cubicAt = __WEBPACK_IMPORTED_MODULE_1__curve__["b" /* cubicAt */];
    var i;
    var n = cubicExtrema(x0, x1, x2, x3, xDim);
    min[0] = Infinity;
    min[1] = Infinity;
    max[0] = -Infinity;
    max[1] = -Infinity;

    for (i = 0; i < n; i++) {
        var x = cubicAt(x0, x1, x2, x3, xDim[i]);
        min[0] = mathMin(x, min[0]);
        max[0] = mathMax(x, max[0]);
    }
    n = cubicExtrema(y0, y1, y2, y3, yDim);
    for (i = 0; i < n; i++) {
        var y = cubicAt(y0, y1, y2, y3, yDim[i]);
        min[1] = mathMin(y, min[1]);
        max[1] = mathMax(y, max[1]);
    }

    min[0] = mathMin(x0, min[0]);
    max[0] = mathMax(x0, max[0]);
    min[0] = mathMin(x3, min[0]);
    max[0] = mathMax(x3, max[0]);

    min[1] = mathMin(y0, min[1]);
    max[1] = mathMax(y0, max[1]);
    min[1] = mathMin(y3, min[1]);
    max[1] = mathMax(y3, max[1]);
}

/**
 * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
 * @memberOf module:zrender/core/bbox
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */
function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
    var quadraticExtremum = __WEBPACK_IMPORTED_MODULE_1__curve__["e" /* quadraticExtremum */];
    var quadraticAt = __WEBPACK_IMPORTED_MODULE_1__curve__["f" /* quadraticAt */];
    // Find extremities, where derivative in x dim or y dim is zero
    var tx =
        mathMax(
            mathMin(quadraticExtremum(x0, x1, x2), 1), 0
        );
    var ty =
        mathMax(
            mathMin(quadraticExtremum(y0, y1, y2), 1), 0
        );

    var x = quadraticAt(x0, x1, x2, tx);
    var y = quadraticAt(y0, y1, y2, ty);

    min[0] = mathMin(x0, x2, x);
    min[1] = mathMin(y0, y2, y);
    max[0] = mathMax(x0, x2, x);
    max[1] = mathMax(y0, y2, y);
}

/**
 * 从圆弧中计算出最小包围盒，写入`min`和`max`中
 * @method
 * @memberOf module:zrender/core/bbox
 * @param {number} x
 * @param {number} y
 * @param {number} rx
 * @param {number} ry
 * @param {number} startAngle
 * @param {number} endAngle
 * @param {number} anticlockwise
 * @param {Array.<number>} min
 * @param {Array.<number>} max
 */
function fromArc(
    x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max
) {
    var vec2Min = __WEBPACK_IMPORTED_MODULE_0__vector__["d" /* min */];
    var vec2Max = __WEBPACK_IMPORTED_MODULE_0__vector__["e" /* max */];

    var diff = Math.abs(startAngle - endAngle);


    if (diff % PI2 < 1e-4 && diff > 1e-4) {
        // Is a circle
        min[0] = x - rx;
        min[1] = y - ry;
        max[0] = x + rx;
        max[1] = y + ry;
        return;
    }

    start[0] = mathCos(startAngle) * rx + x;
    start[1] = mathSin(startAngle) * ry + y;

    end[0] = mathCos(endAngle) * rx + x;
    end[1] = mathSin(endAngle) * ry + y;

    vec2Min(min, start, end);
    vec2Max(max, start, end);

    // Thresh to [0, Math.PI * 2]
    startAngle = startAngle % (PI2);
    if (startAngle < 0) {
        startAngle = startAngle + PI2;
    }
    endAngle = endAngle % (PI2);
    if (endAngle < 0) {
        endAngle = endAngle + PI2;
    }

    if (startAngle > endAngle && !anticlockwise) {
        endAngle += PI2;
    }
    else if (startAngle < endAngle && anticlockwise) {
        startAngle += PI2;
    }
    if (anticlockwise) {
        var tmp = endAngle;
        endAngle = startAngle;
        startAngle = tmp;
    }

    // var number = 0;
    // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
    for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
        if (angle > startAngle) {
            extremity[0] = mathCos(angle) * rx + x;
            extremity[1] = mathSin(angle) * ry + y;

            vec2Min(min, extremity, min);
            vec2Max(max, extremity, max);
        }
    }
}


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_event__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mixin_Eventful__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_env__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_GestureMgr__ = __webpack_require__(48);







var TOUCH_CLICK_DELAY = 300;

var mouseHandlerNames = [
    'click', 'dblclick', 'mousewheel', 'mouseout',
    'mouseup', 'mousedown', 'mousemove', 'contextmenu'
];

var touchHandlerNames = [
    'touchstart', 'touchend', 'touchmove'
];

var pointerEventNames = {
    pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1
};

var pointerHandlerNames = __WEBPACK_IMPORTED_MODULE_1__core_util__["o" /* map */](mouseHandlerNames, function (name) {
    var nm = name.replace('mouse', 'pointer');
    return pointerEventNames[nm] ? nm : name;
});

function eventNameFix(name) {
    return (name === 'mousewheel' && __WEBPACK_IMPORTED_MODULE_3__core_env__["a" /* default */].browser.firefox) ? 'DOMMouseScroll' : name;
}

function processGesture(proxy, event, stage) {
    var gestureMgr = proxy._gestureMgr;

    stage === 'start' && gestureMgr.clear();

    var gestureInfo = gestureMgr.recognize(
        event,
        proxy.handler.findHover(event.zrX, event.zrY, null).target,
        proxy.dom
    );

    stage === 'end' && gestureMgr.clear();

    // Do not do any preventDefault here. Upper application do that if necessary.
    if (gestureInfo) {
        var type = gestureInfo.type;
        event.gestureEvent = type;

        proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);
    }
}

// function onMSGestureChange(proxy, event) {
//     if (event.translationX || event.translationY) {
//         // mousemove is carried by MSGesture to reduce the sensitivity.
//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
//     }
//     if (event.scale !== 1) {
//         event.pinchX = event.offsetX;
//         event.pinchY = event.offsetY;
//         event.pinchScale = event.scale;
//         proxy.handler.dispatchToElement(event.target, 'pinch', event);
//     }
// }

/**
 * Prevent mouse event from being dispatched after Touch Events action
 * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
 * 1. Mobile browsers dispatch mouse events 300ms after touchend.
 * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
 * Result: Blocking Mouse Events for 700ms.
 */
function setTouchTimer(instance) {
    instance._touching = true;
    clearTimeout(instance._touchTimer);
    instance._touchTimer = setTimeout(function () {
        instance._touching = false;
    }, 700);
}


var domHandlers = {
    /**
     * Mouse move handler
     * @inner
     * @param {Event} event
     */
    mousemove: function (event) {
        event = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_event__["b" /* normalizeEvent */])(this.dom, event);

        this.trigger('mousemove', event);
    },

    /**
     * Mouse out handler
     * @inner
     * @param {Event} event
     */
    mouseout: function (event) {
        event = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_event__["b" /* normalizeEvent */])(this.dom, event);

        var element = event.toElement || event.relatedTarget;
        if (element != this.dom) {
            while (element && element.nodeType != 9) {
                // 忽略包含在root中的dom引起的mouseOut
                if (element === this.dom) {
                    return;
                }

                element = element.parentNode;
            }
        }

        this.trigger('mouseout', event);
    },

    /**
     * Touch开始响应函数
     * @inner
     * @param {Event} event
     */
    touchstart: function (event) {
        // Default mouse behaviour should not be disabled here.
        // For example, page may needs to be slided.
        event = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_event__["b" /* normalizeEvent */])(this.dom, event);

        // Mark touch, which is useful in distinguish touch and
        // mouse event in upper applicatoin.
        event.zrByTouch = true;

        this._lastTouchMoment = new Date();

        processGesture(this, event, 'start');

        // In touch device, trigger `mousemove`(`mouseover`) should
        // be triggered, and must before `mousedown` triggered.
        domHandlers.mousemove.call(this, event);

        domHandlers.mousedown.call(this, event);

        setTouchTimer(this);
    },

    /**
     * Touch移动响应函数
     * @inner
     * @param {Event} event
     */
    touchmove: function (event) {

        event = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_event__["b" /* normalizeEvent */])(this.dom, event);

        // Mark touch, which is useful in distinguish touch and
        // mouse event in upper applicatoin.
        event.zrByTouch = true;

        processGesture(this, event, 'change');

        // Mouse move should always be triggered no matter whether
        // there is gestrue event, because mouse move and pinch may
        // be used at the same time.
        domHandlers.mousemove.call(this, event);

        setTouchTimer(this);
    },

    /**
     * Touch结束响应函数
     * @inner
     * @param {Event} event
     */
    touchend: function (event) {

        event = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_event__["b" /* normalizeEvent */])(this.dom, event);

        // Mark touch, which is useful in distinguish touch and
        // mouse event in upper applicatoin.
        event.zrByTouch = true;

        processGesture(this, event, 'end');

        domHandlers.mouseup.call(this, event);

        // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
        // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
        // we can conveniently implement "hover style" in both PC and touch device just
        // by listening to `mouseover` to add "hover style" and listening to `mouseout`
        // to remove "hover style" on an element, without any additional code for
        // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
        // style" will remain for user view)

        // click event should always be triggered no matter whether
        // there is gestrue event. System click can not be prevented.
        if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
            domHandlers.click.call(this, event);
        }

        setTouchTimer(this);
    },

    pointerdown: function (event) {
        domHandlers.mousedown.call(this, event);

        // if (useMSGuesture(this, event)) {
        //     this._msGesture.addPointer(event.pointerId);
        // }
    },

    pointermove: function (event) {
        // FIXME
        // pointermove is so sensitive that it always triggered when
        // tap(click) on touch screen, which affect some judgement in
        // upper application. So, we dont support mousemove on MS touch
        // device yet.
        if (!isPointerFromTouch(event)) {
            domHandlers.mousemove.call(this, event);
        }
    },

    pointerup: function (event) {
        domHandlers.mouseup.call(this, event);
    },

    pointerout: function (event) {
        // pointerout will be triggered when tap on touch screen
        // (IE11+/Edge on MS Surface) after click event triggered,
        // which is inconsistent with the mousout behavior we defined
        // in touchend. So we unify them.
        // (check domHandlers.touchend for detailed explanation)
        if (!isPointerFromTouch(event)) {
            domHandlers.mouseout.call(this, event);
        }
    }
};

function isPointerFromTouch(event) {
    var pointerType = event.pointerType;
    return pointerType === 'pen' || pointerType === 'touch';
}

// function useMSGuesture(handlerProxy, event) {
//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
// }

// Common handlers
__WEBPACK_IMPORTED_MODULE_1__core_util__["b" /* each */](['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
    domHandlers[name] = function (event) {
        event = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_event__["b" /* normalizeEvent */])(this.dom, event);
        this.trigger(name, event);
    };
});

/**
 * 为控制类实例初始化dom 事件处理函数
 *
 * @inner
 * @param {module:zrender/Handler} instance 控制类实例
 */
function initDomHandler(instance) {
    __WEBPACK_IMPORTED_MODULE_1__core_util__["b" /* each */](touchHandlerNames, function (name) {
        instance._handlers[name] = __WEBPACK_IMPORTED_MODULE_1__core_util__["n" /* bind */](domHandlers[name], instance);
    });

    __WEBPACK_IMPORTED_MODULE_1__core_util__["b" /* each */](pointerHandlerNames, function (name) {
        instance._handlers[name] = __WEBPACK_IMPORTED_MODULE_1__core_util__["n" /* bind */](domHandlers[name], instance);
    });

    __WEBPACK_IMPORTED_MODULE_1__core_util__["b" /* each */](mouseHandlerNames, function (name) {
        instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
    });

    function makeMouseHandler(fn, instance) {
        return function () {
            if (instance._touching) {
                return;
            }
            return fn.apply(instance, arguments);
        };
    }
}


function HandlerDomProxy(dom) {
    __WEBPACK_IMPORTED_MODULE_2__mixin_Eventful__["a" /* default */].call(this);

    this.dom = dom;

    /**
     * @private
     * @type {boolean}
     */
    this._touching = false;

    /**
     * @private
     * @type {number}
     */
    this._touchTimer;

    /**
     * @private
     * @type {module:zrender/core/GestureMgr}
     */
    this._gestureMgr = new __WEBPACK_IMPORTED_MODULE_4__core_GestureMgr__["a" /* default */]();

    this._handlers = {};

    initDomHandler(this);

    if (__WEBPACK_IMPORTED_MODULE_3__core_env__["a" /* default */].pointerEventsSupported) { // Only IE11+/Edge
        // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
        // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
        // at the same time.
        // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
        // screen, which do not occurs in pointer event.
        // So we use pointer event to both detect touch gesture and mouse behavior.
        mountHandlers(pointerHandlerNames, this);

        // FIXME
        // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
        // which does not prevent defuault behavior occasionally (which may cause view port
        // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
        // So we have to not to use MSGesture and not to support touchmove and pinch on MS
        // touch screen. And we only support click behavior on MS touch screen now.

        // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
        // We dont support touch on IE on win7.
        // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
        // if (typeof MSGesture === 'function') {
        //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
        //     dom.addEventListener('MSGestureChange', onMSGestureChange);
        // }
    }
    else {
        if (__WEBPACK_IMPORTED_MODULE_3__core_env__["a" /* default */].touchEventsSupported) {
            mountHandlers(touchHandlerNames, this);
            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
            // addEventListener(root, 'mouseout', this._mouseoutHandler);
        }

        // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
        // mouse event can not be handle in those devices.
        // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
        // mouseevent after touch event triggered, see `setTouchTimer`.
        mountHandlers(mouseHandlerNames, this);
    }

    function mountHandlers(handlerNames, instance) {
        __WEBPACK_IMPORTED_MODULE_1__core_util__["b" /* each */](handlerNames, function (name) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_event__["c" /* addEventListener */])(dom, eventNameFix(name), instance._handlers[name]);
        }, instance);
    }
}

var handlerDomProxyProto = HandlerDomProxy.prototype;
handlerDomProxyProto.dispose = function () {
    var handlerNames = mouseHandlerNames.concat(touchHandlerNames);

    for (var i = 0; i < handlerNames.length; i++) {
        var name = handlerNames[i];
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core_event__["d" /* removeEventListener */])(this.dom, eventNameFix(name), this._handlers[name]);
    }
};

handlerDomProxyProto.setCursor = function (cursorStyle) {
    this.dom.style.cursor = cursorStyle || 'default';
};

__WEBPACK_IMPORTED_MODULE_1__core_util__["j" /* mixin */](HandlerDomProxy, __WEBPACK_IMPORTED_MODULE_2__mixin_Eventful__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (HandlerDomProxy);

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Displayable__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_BoundingRect__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helper_image__ = __webpack_require__(10);





/**
 * @alias zrender/graphic/Image
 * @extends module:zrender/graphic/Displayable
 * @constructor
 * @param {Object} opts
 */
function ZImage(opts) {
    __WEBPACK_IMPORTED_MODULE_0__Displayable__["a" /* default */].call(this, opts);
}

ZImage.prototype = {

    constructor: ZImage,

    type: 'image',

    brush: function (ctx, prevEl) {
        var style = this.style;
        var src = style.image;

        // Must bind each time
        style.bind(ctx, this, prevEl);

        var image = this._image = __WEBPACK_IMPORTED_MODULE_3__helper_image__["a" /* createOrUpdateImage */](
            src,
            this._image,
            this,
            this.onload
        );

        if (!image || !__WEBPACK_IMPORTED_MODULE_3__helper_image__["b" /* isImageReady */](image)) {
            return;
        }

        // 图片已经加载完成
        // if (image.nodeName.toUpperCase() == 'IMG') {
        //     if (!image.complete) {
        //         return;
        //     }
        // }
        // Else is canvas

        var x = style.x || 0;
        var y = style.y || 0;
        var width = style.width;
        var height = style.height;
        var aspect = image.width / image.height;
        if (width == null && height != null) {
            // Keep image/height ratio
            width = height * aspect;
        }
        else if (height == null && width != null) {
            height = width / aspect;
        }
        else if (width == null && height == null) {
            width = image.width;
            height = image.height;
        }

        // 设置transform
        this.setTransform(ctx);

        if (style.sWidth && style.sHeight) {
            var sx = style.sx || 0;
            var sy = style.sy || 0;
            ctx.drawImage(
                image,
                sx, sy, style.sWidth, style.sHeight,
                x, y, width, height
            );
        }
        else if (style.sx && style.sy) {
            var sx = style.sx;
            var sy = style.sy;
            var sWidth = width - sx;
            var sHeight = height - sy;
            ctx.drawImage(
                image,
                sx, sy, sWidth, sHeight,
                x, y, width, height
            );
        }
        else {
            ctx.drawImage(image, x, y, width, height);
        }

        this.restoreTransform(ctx);

        // Draw rect text
        if (style.text != null) {
            this.drawRectText(ctx, this.getBoundingRect());
        }
    },

    getBoundingRect: function () {
        var style = this.style;
        if (! this._rect) {
            this._rect = new __WEBPACK_IMPORTED_MODULE_1__core_BoundingRect__["a" /* default */](
                style.x || 0, style.y || 0, style.width || 0, style.height || 0
            );
        }
        return this._rect;
    }
};

__WEBPACK_IMPORTED_MODULE_2__core_util__["a" /* inherits */](ZImage, __WEBPACK_IMPORTED_MODULE_0__Displayable__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (ZImage);

/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = buildPath;

function buildPath(ctx, shape) {
    var x = shape.x;
    var y = shape.y;
    var width = shape.width;
    var height = shape.height;
    var r = shape.r;
    var r1;
    var r2;
    var r3;
    var r4;

    // Convert width and height to positive for better borderRadius
    if (width < 0) {
        x = x + width;
        width = -width;
    }
    if (height < 0) {
        y = y + height;
        height = -height;
    }

    if (typeof r === 'number') {
        r1 = r2 = r3 = r4 = r;
    }
    else if (r instanceof Array) {
        if (r.length === 1) {
            r1 = r2 = r3 = r4 = r[0];
        }
        else if (r.length === 2) {
            r1 = r3 = r[0];
            r2 = r4 = r[1];
        }
        else if (r.length === 3) {
            r1 = r[0];
            r2 = r4 = r[1];
            r3 = r[2];
        }
        else {
            r1 = r[0];
            r2 = r[1];
            r3 = r[2];
            r4 = r[3];
        }
    }
    else {
        r1 = r2 = r3 = r4 = 0;
    }

    var total;
    if (r1 + r2 > width) {
        total = r1 + r2;
        r1 *= width / total;
        r2 *= width / total;
    }
    if (r3 + r4 > width) {
        total = r3 + r4;
        r3 *= width / total;
        r4 *= width / total;
    }
    if (r2 + r3 > height) {
        total = r2 + r3;
        r2 *= height / total;
        r3 *= height / total;
    }
    if (r1 + r4 > height) {
        total = r1 + r4;
        r1 *= height / total;
        r4 *= height / total;
    }
    ctx.moveTo(x + r1, y);
    ctx.lineTo(x + width - r2, y);
    r2 !== 0 && ctx.quadraticCurveTo(
        x + width, y, x + width, y + r2
    );
    ctx.lineTo(x + width, y + height - r3);
    r3 !== 0 && ctx.quadraticCurveTo(
        x + width, y + height, x + width - r3, y + height
    );
    ctx.lineTo(x + r4, y + height);
    r4 !== 0 && ctx.quadraticCurveTo(
        x, y + height, x, y + height - r4
    );
    ctx.lineTo(x, y + r1);
    r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
}


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__helper_text__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_BoundingRect__ = __webpack_require__(1);
/**
 * Mixin for drawing text in a element bounding rect
 * @module zrender/mixin/RectText
 */




var tmpRect = new __WEBPACK_IMPORTED_MODULE_1__core_BoundingRect__["a" /* default */]();

var RectText = function () {};

RectText.prototype = {

    constructor: RectText,

    /**
     * Draw text in a rect with specified position.
     * @param  {CanvasRenderingContext2D} ctx
     * @param  {Object} rect Displayable rect
     */
    drawRectText: function (ctx, rect) {
        var style = this.style;

        rect = style.textRect || rect;

        // Optimize, avoid normalize every time.
        this.__dirty && __WEBPACK_IMPORTED_MODULE_0__helper_text__["a" /* normalizeTextStyle */](style, true);

        var text = style.text;

        // Convert to string
        text != null && (text += '');

        if (!__WEBPACK_IMPORTED_MODULE_0__helper_text__["b" /* needDrawText */](text, style)) {
            return;
        }

        // FIXME
        ctx.save();

        // Transform rect to view space
        var transform = this.transform;
        if (!style.transformText) {
            if (transform) {
                tmpRect.copy(rect);
                tmpRect.applyTransform(transform);
                rect = tmpRect;
            }
        }
        else {
            this.setTransform(ctx);
        }

        // transformText and textRotation can not be used at the same time.
        __WEBPACK_IMPORTED_MODULE_0__helper_text__["c" /* renderText */](this, ctx, text, style, rect);

        ctx.restore();
    }
};

/* harmony default export */ __webpack_exports__["a"] = (RectText);

/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Path__ = __webpack_require__(23);
/**
 * 圆形
 * @module zrender/shape/Circle
 */



/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0__Path__["a" /* default */].extend({

    type: 'circle',

    shape: {
        cx: 0,
        cy: 0,
        r: 0
    },


    buildPath : function (ctx, shape, inBundle) {
        // Better stroking in ShapeBundle
        // Always do it may have performence issue ( fill may be 2x more cost)
        if (inBundle) {
            ctx.moveTo(shape.cx + shape.r, shape.cy);
        }
        // else {
        //     if (ctx.allocate && !ctx.data.length) {
        //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
        //     }
        // }
        // Better stroking in ShapeBundle
        // ctx.moveTo(shape.cx + shape.r, shape.cy);
        ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
    }
}));

/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Path__ = __webpack_require__(23);
/**
 * 直线
 * @module zrender/graphic/shape/Line
 */



/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0__Path__["a" /* default */].extend({

    type: 'line',

    shape: {
        // Start point
        x1: 0,
        y1: 0,
        // End point
        x2: 0,
        y2: 0,

        percent: 1
    },

    style: {
        stroke: '#000',
        fill: null
    },

    buildPath: function (ctx, shape) {
        var x1 = shape.x1;
        var y1 = shape.y1;
        var x2 = shape.x2;
        var y2 = shape.y2;
        var percent = shape.percent;

        if (percent === 0) {
            return;
        }

        ctx.moveTo(x1, y1);

        if (percent < 1) {
            x2 = x1 * (1 - percent) + x2 * percent;
            y2 = y1 * (1 - percent) + y2 * percent;
        }
        ctx.lineTo(x2, y2);
    },

    /**
     * Get point at percent
     * @param  {number} percent
     * @return {Array.<number>}
     */
    pointAt: function (p) {
        var shape = this.shape;
        return [
            shape.x1 * (1 - p) + shape.x2 * p,
            shape.y1 * (1 - p) + shape.y2 * p
        ];
    }
}));

/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__animation_Animator__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_log__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_util__ = __webpack_require__(0);




/**
 * @alias modue:zrender/mixin/Animatable
 * @constructor
 */
var Animatable = function () {

    /**
     * @type {Array.<module:zrender/animation/Animator>}
     * @readOnly
     */
    this.animators = [];
};

Animatable.prototype = {

    constructor: Animatable,

    /**
     * 动画
     *
     * @param {string} path The path to fetch value from object, like 'a.b.c'.
     * @param {boolean} [loop] Whether to loop animation.
     * @return {module:zrender/animation/Animator}
     * @example:
     *     el.animate('style', false)
     *         .when(1000, {x: 10} )
     *         .done(function(){ // Animation done })
     *         .start()
     */
    animate: function (path, loop) {
        var target;
        var animatingShape = false;
        var el = this;
        var zr = this.__zr;
        if (path) {
            var pathSplitted = path.split('.');
            var prop = el;
            // If animating shape
            animatingShape = pathSplitted[0] === 'shape';
            for (var i = 0, l = pathSplitted.length; i < l; i++) {
                if (!prop) {
                    continue;
                }
                prop = prop[pathSplitted[i]];
            }
            if (prop) {
                target = prop;
            }
        }
        else {
            target = el;
        }

        if (!target) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__core_log__["a" /* default */])(
                'Property "'
                + path
                + '" is not existed in element '
                + el.id
            );
            return;
        }

        var animators = el.animators;

        var animator = new __WEBPACK_IMPORTED_MODULE_0__animation_Animator__["a" /* default */](target, loop);

        animator.during(function (target) {
            el.dirty(animatingShape);
        })
        .done(function () {
            // FIXME Animator will not be removed if use `Animator#stop` to stop animation
            animators.splice(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["k" /* indexOf */])(animators, animator), 1);
        });

        animators.push(animator);

        // If animate after added to the zrender
        if (zr) {
            zr.animation.addAnimator(animator);
        }

        return animator;
    },

    /**
     * 停止动画
     * @param {boolean} forwardToLast If move to last frame before stop
     */
    stopAnimation: function (forwardToLast) {
        var animators = this.animators;
        var len = animators.length;
        for (var i = 0; i < len; i++) {
            animators[i].stop(forwardToLast);
        }
        animators.length = 0;

        return this;
    },

    /**
     * Caution: this method will stop previous animation.
     * So do not use this method to one element twice before
     * animation starts, unless you know what you are doing.
     * @param {Object} target
     * @param {number} [time=500] Time in ms
     * @param {string} [easing='linear']
     * @param {number} [delay=0]
     * @param {Function} [callback]
     * @param {Function} [forceAnimate] Prevent stop animation and callback
     *        immediently when target values are the same as current values.
     *
     * @example
     *  // Animate position
     *  el.animateTo({
     *      position: [10, 10]
     *  }, function () { // done })
     *
     *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
     *  el.animateTo({
     *      shape: {
     *          width: 500
     *      },
     *      style: {
     *          fill: 'red'
     *      }
     *      position: [10, 10]
     *  }, 100, 100, 'cubicOut', function () { // done })
     */
        // TODO Return animation key
    animateTo: function (target, time, delay, easing, callback, forceAnimate) {
        // animateTo(target, time, easing, callback);
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["f" /* isString */])(delay)) {
            callback = easing;
            easing = delay;
            delay = 0;
        }
        // animateTo(target, time, delay, callback);
        else if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["l" /* isFunction */])(easing)) {
            callback = easing;
            easing = 'linear';
            delay = 0;
        }
        // animateTo(target, time, callback);
        else if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["l" /* isFunction */])(delay)) {
            callback = delay;
            delay = 0;
        }
        // animateTo(target, callback)
        else if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["l" /* isFunction */])(time)) {
            callback = time;
            time = 500;
        }
        // animateTo(target)
        else if (!time) {
            time = 500;
        }
        // Stop all previous animations
        this.stopAnimation();
        this._animateToShallow('', this, target, time, delay);

        // Animators may be removed immediately after start
        // if there is nothing to animate
        var animators = this.animators.slice();
        var count = animators.length;
        function done() {
            count--;
            if (!count) {
                callback && callback();
            }
        }

        // No animators. This should be checked before animators[i].start(),
        // because 'done' may be executed immediately if no need to animate.
        if (!count) {
            callback && callback();
        }
        // Start after all animators created
        // Incase any animator is done immediately when all animation properties are not changed
        for (var i = 0; i < animators.length; i++) {
            animators[i]
                .done(done)
                .start(easing, forceAnimate);
        }
    },

    /**
     * @private
     * @param {string} path=''
     * @param {Object} source=this
     * @param {Object} target
     * @param {number} [time=500]
     * @param {number} [delay=0]
     *
     * @example
     *  // Animate position
     *  el._animateToShallow({
     *      position: [10, 10]
     *  })
     *
     *  // Animate shape, style and position in 100ms, delayed 100ms
     *  el._animateToShallow({
     *      shape: {
     *          width: 500
     *      },
     *      style: {
     *          fill: 'red'
     *      }
     *      position: [10, 10]
     *  }, 100, 100)
     */
    _animateToShallow: function (path, source, target, time, delay) {
        var objShallow = {};
        var propertyCount = 0;
        for (var name in target) {
            if (!target.hasOwnProperty(name)) {
                continue;
            }

            if (source[name] != null) {
                if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["g" /* isObject */])(target[name]) && !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__core_util__["m" /* isArrayLike */])(target[name])) {
                    this._animateToShallow(
                        path ? path + '.' + name : name,
                        source[name],
                        target[name],
                        time,
                        delay
                    );
                }
                else {
                    objShallow[name] = target[name];
                    propertyCount++;
                }
            }
            else if (target[name] != null) {
                // Attr directly if not has property
                // FIXME, if some property not needed for element ?
                if (!path) {
                    this.attr(name, target[name]);
                }
                else {  // Shape or style
                    var props = {};
                    props[path] = {};
                    props[path][name] = target[name];
                    this.attr(props);
                }
            }
        }

        if (propertyCount > 0) {
            this.animate(path, false)
                .when(time == null ? 500 : time, objShallow)
                .delay(delay || 0);
        }

        return this;
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Animatable);

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// TODO Draggable for group
// FIXME Draggable on element which has parent rotation or scale
function Draggable() {

    this.on('mousedown', this._dragStart, this);
    this.on('mousemove', this._drag, this);
    this.on('mouseup', this._dragEnd, this);
    this.on('globalout', this._dragEnd, this);
    // this._dropTarget = null;
    // this._draggingTarget = null;

    // this._x = 0;
    // this._y = 0;
}

Draggable.prototype = {

    constructor: Draggable,

    _dragStart: function (e) {
        var draggingTarget = e.target;
        if (draggingTarget && draggingTarget.draggable) {
            this._draggingTarget = draggingTarget;
            draggingTarget.dragging = true;
            this._x = e.offsetX;
            this._y = e.offsetY;

            this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
        }
    },

    _drag: function (e) {
        var draggingTarget = this._draggingTarget;
        if (draggingTarget) {

            var x = e.offsetX;
            var y = e.offsetY;

            var dx = x - this._x;
            var dy = y - this._y;
            this._x = x;
            this._y = y;

            draggingTarget.drift(dx, dy, e);
            this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);

            var dropTarget = this.findHover(x, y, draggingTarget).target;
            var lastDropTarget = this._dropTarget;
            this._dropTarget = dropTarget;

            if (draggingTarget !== dropTarget) {
                if (lastDropTarget && dropTarget !== lastDropTarget) {
                    this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
                }
                if (dropTarget && dropTarget !== lastDropTarget) {
                    this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
                }
            }
        }
    },

    _dragEnd: function (e) {
        var draggingTarget = this._draggingTarget;

        if (draggingTarget) {
            draggingTarget.dragging = false;
        }

        this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);

        if (this._dropTarget) {
            this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
        }

        this._draggingTarget = null;
        this._dropTarget = null;
    }

};

function param(target, e) {
    return {target: target, topTarget: e && e.topTarget};
}

/* harmony default export */ __webpack_exports__["a"] = (Draggable);

/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_matrix__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_vector__ = __webpack_require__(2);
/**
 * 提供变换扩展
 * @module zrender/mixin/Transformable
 * @author pissang (https://www.github.com/pissang)
 */




var mIdentity = __WEBPACK_IMPORTED_MODULE_0__core_matrix__["d" /* identity */];

var EPSILON = 5e-5;

function isNotAroundZero(val) {
    return val > EPSILON || val < -EPSILON;
}

/**
 * @alias module:zrender/mixin/Transformable
 * @constructor
 */
var Transformable = function (opts) {
    opts = opts || {};
    // If there are no given position, rotation, scale
    if (!opts.position) {
        /**
         * 平移
         * @type {Array.<number>}
         * @default [0, 0]
         */
        this.position = [0, 0];
    }
    if (opts.rotation == null) {
        /**
         * 旋转
         * @type {Array.<number>}
         * @default 0
         */
        this.rotation = 0;
    }
    if (!opts.scale) {
        /**
         * 缩放
         * @type {Array.<number>}
         * @default [1, 1]
         */
        this.scale = [1, 1];
    }
    /**
     * 旋转和缩放的原点
     * @type {Array.<number>}
     * @default null
     */
    this.origin = this.origin || null;
};

var transformableProto = Transformable.prototype;
transformableProto.transform = null;

/**
 * 判断是否需要有坐标变换
 * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
 */
transformableProto.needLocalTransform = function () {
    return isNotAroundZero(this.rotation)
        || isNotAroundZero(this.position[0])
        || isNotAroundZero(this.position[1])
        || isNotAroundZero(this.scale[0] - 1)
        || isNotAroundZero(this.scale[1] - 1);
};

transformableProto.updateTransform = function () {
    var parent = this.parent;
    var parentHasTransform = parent && parent.transform;
    var needLocalTransform = this.needLocalTransform();

    var m = this.transform;
    if (!(needLocalTransform || parentHasTransform)) {
        m && mIdentity(m);
        return;
    }

    m = m || __WEBPACK_IMPORTED_MODULE_0__core_matrix__["a" /* create */]();

    if (needLocalTransform) {
        this.getLocalTransform(m);
    }
    else {
        mIdentity(m);
    }

    // 应用父节点变换
    if (parentHasTransform) {
        if (needLocalTransform) {
            __WEBPACK_IMPORTED_MODULE_0__core_matrix__["e" /* mul */](m, parent.transform, m);
        }
        else {
            __WEBPACK_IMPORTED_MODULE_0__core_matrix__["f" /* copy */](m, parent.transform);
        }
    }
    // 保存这个变换矩阵
    this.transform = m;

    this.invTransform = this.invTransform || __WEBPACK_IMPORTED_MODULE_0__core_matrix__["a" /* create */]();
    __WEBPACK_IMPORTED_MODULE_0__core_matrix__["g" /* invert */](this.invTransform, m);
};

transformableProto.getLocalTransform = function (m) {
    return Transformable.getLocalTransform(this, m);
};

/**
 * 将自己的transform应用到context上
 * @param {CanvasRenderingContext2D} ctx
 */
transformableProto.setTransform = function (ctx) {
    var m = this.transform;
    var dpr = ctx.dpr || 1;
    if (m) {
        ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
    }
    else {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
};

transformableProto.restoreTransform = function (ctx) {
    var dpr = ctx.dpr || 1;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
};

var tmpTransform = [];

/**
 * 分解`transform`矩阵到`position`, `rotation`, `scale`
 */
transformableProto.decomposeTransform = function () {
    if (!this.transform) {
        return;
    }
    var parent = this.parent;
    var m = this.transform;
    if (parent && parent.transform) {
        // Get local transform and decompose them to position, scale, rotation
        __WEBPACK_IMPORTED_MODULE_0__core_matrix__["e" /* mul */](tmpTransform, parent.invTransform, m);
        m = tmpTransform;
    }
    var sx = m[0] * m[0] + m[1] * m[1];
    var sy = m[2] * m[2] + m[3] * m[3];
    var position = this.position;
    var scale = this.scale;
    if (isNotAroundZero(sx - 1)) {
        sx = Math.sqrt(sx);
    }
    if (isNotAroundZero(sy - 1)) {
        sy = Math.sqrt(sy);
    }
    if (m[0] < 0) {
        sx = -sx;
    }
    if (m[3] < 0) {
        sy = -sy;
    }
    position[0] = m[4];
    position[1] = m[5];
    scale[0] = sx;
    scale[1] = sy;
    this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
};

/**
 * Get global scale
 * @return {Array.<number>}
 */
transformableProto.getGlobalScale = function () {
    var m = this.transform;
    if (!m) {
        return [1, 1];
    }
    var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
    var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
    if (m[0] < 0) {
        sx = -sx;
    }
    if (m[3] < 0) {
        sy = -sy;
    }
    return [sx, sy];
};
/**
 * 变换坐标位置到 shape 的局部坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */
transformableProto.transformCoordToLocal = function (x, y) {
    var v2 = [x, y];
    var invTransform = this.invTransform;
    if (invTransform) {
        __WEBPACK_IMPORTED_MODULE_1__core_vector__["a" /* applyTransform */](v2, v2, invTransform);
    }
    return v2;
};

/**
 * 变换局部坐标位置到全局坐标空间
 * @method
 * @param {number} x
 * @param {number} y
 * @return {Array.<number>}
 */
transformableProto.transformCoordToGlobal = function (x, y) {
    var v2 = [x, y];
    var transform = this.transform;
    if (transform) {
        __WEBPACK_IMPORTED_MODULE_1__core_vector__["a" /* applyTransform */](v2, v2, transform);
    }
    return v2;
};

/**
 * @static
 * @param {Object} target
 * @param {Array.<number>} target.origin
 * @param {number} target.rotation
 * @param {Array.<number>} target.position
 * @param {Array.<number>} [m]
 */
Transformable.getLocalTransform = function (target, m) {
    m = m || [];
    mIdentity(m);

    var origin = target.origin;
    var scale = target.scale || [1, 1];
    var rotation = target.rotation || 0;
    var position = target.position || [0, 0];

    if (origin) {
        // Translate to origin
        m[4] -= origin[0];
        m[5] -= origin[1];
    }
    __WEBPACK_IMPORTED_MODULE_0__core_matrix__["c" /* scale */](m, m, scale);
    if (rotation) {
        __WEBPACK_IMPORTED_MODULE_0__core_matrix__["h" /* rotate */](m, m, rotation);
    }
    if (origin) {
        // Translate back from origin
        m[4] += origin[0];
        m[5] += origin[1];
    }

    m[4] += position[0];
    m[5] += position[1];

    return m;
};

/* harmony default export */ __webpack_exports__["a"] = (Transformable);

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parse;
/* unused harmony export lift */
/* unused harmony export toHex */
/* unused harmony export fastLerp */
/* unused harmony export fastMapToColor */
/* unused harmony export lerp */
/* unused harmony export mapToColor */
/* unused harmony export modifyHSL */
/* unused harmony export modifyAlpha */
/* unused harmony export stringify */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_LRU__ = __webpack_require__(17);


var kCSSColorTable = {
    'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],
    'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],
    'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],
    'beige': [245,245,220,1], 'bisque': [255,228,196,1],
    'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],
    'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],
    'brown': [165,42,42,1], 'burlywood': [222,184,135,1],
    'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],
    'chocolate': [210,105,30,1], 'coral': [255,127,80,1],
    'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],
    'crimson': [220,20,60,1], 'cyan': [0,255,255,1],
    'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],
    'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],
    'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],
    'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],
    'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],
    'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],
    'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],
    'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],
    'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],
    'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],
    'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],
    'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],
    'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],
    'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],
    'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],
    'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],
    'gray': [128,128,128,1], 'green': [0,128,0,1],
    'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],
    'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],
    'indianred': [205,92,92,1], 'indigo': [75,0,130,1],
    'ivory': [255,255,240,1], 'khaki': [240,230,140,1],
    'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],
    'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],
    'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],
    'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],
    'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],
    'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],
    'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],
    'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],
    'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],
    'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],
    'limegreen': [50,205,50,1], 'linen': [250,240,230,1],
    'magenta': [255,0,255,1], 'maroon': [128,0,0,1],
    'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],
    'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],
    'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],
    'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],
    'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],
    'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],
    'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],
    'navy': [0,0,128,1], 'oldlace': [253,245,230,1],
    'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],
    'orange': [255,165,0,1], 'orangered': [255,69,0,1],
    'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],
    'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],
    'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],
    'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],
    'pink': [255,192,203,1], 'plum': [221,160,221,1],
    'powderblue': [176,224,230,1], 'purple': [128,0,128,1],
    'red': [255,0,0,1], 'rosybrown': [188,143,143,1],
    'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],
    'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],
    'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],
    'sienna': [160,82,45,1], 'silver': [192,192,192,1],
    'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],
    'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],
    'snow': [255,250,250,1], 'springgreen': [0,255,127,1],
    'steelblue': [70,130,180,1], 'tan': [210,180,140,1],
    'teal': [0,128,128,1], 'thistle': [216,191,216,1],
    'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],
    'violet': [238,130,238,1], 'wheat': [245,222,179,1],
    'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],
    'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]
};

function clampCssByte(i) {  // Clamp to integer 0 .. 255.
    i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
    return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clampCssAngle(i) {  // Clamp to integer 0 .. 360.
    i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
    return i < 0 ? 0 : i > 360 ? 360 : i;
}

function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.
    return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parseCssInt(str) {  // int or percentage.
    if (str.length && str.charAt(str.length - 1) === '%') {
        return clampCssByte(parseFloat(str) / 100 * 255);
    }
    return clampCssByte(parseInt(str, 10));
}

function parseCssFloat(str) {  // float or percentage.
    if (str.length && str.charAt(str.length - 1) === '%') {
        return clampCssFloat(parseFloat(str) / 100);
    }
    return clampCssFloat(parseFloat(str));
}

function cssHueToRgb(m1, m2, h) {
    if (h < 0) {
        h += 1;
    }
    else if (h > 1) {
        h -= 1;
    }

    if (h * 6 < 1) {
        return m1 + (m2 - m1) * h * 6;
    }
    if (h * 2 < 1) {
        return m2;
    }
    if (h * 3 < 2) {
        return m1 + (m2 - m1) * (2/3 - h) * 6;
    }
    return m1;
}

function lerpNumber(a, b, p) {
    return a + (b - a) * p;
}

function setRgba(out, r, g, b, a) {
    out[0] = r; out[1] = g; out[2] = b; out[3] = a;
    return out;
}
function copyRgba(out, a) {
    out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
    return out;
}

var colorCache = new __WEBPACK_IMPORTED_MODULE_0__core_LRU__["a" /* default */](20);
var lastRemovedArr = null;

function putToCache(colorStr, rgbaArr) {
    // Reuse removed array
    if (lastRemovedArr) {
        copyRgba(lastRemovedArr, rgbaArr);
    }
    lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));
}

/**
 * @param {string} colorStr
 * @param {Array.<number>} out
 * @return {Array.<number>}
 * @memberOf module:zrender/util/color
 */
function parse(colorStr, rgbaArr) {
    if (!colorStr) {
        return;
    }
    rgbaArr = rgbaArr || [];

    var cached = colorCache.get(colorStr);
    if (cached) {
        return copyRgba(rgbaArr, cached);
    }

    // colorStr may be not string
    colorStr = colorStr + '';
    // Remove all whitespace, not compliant, but should just be more accepting.
    var str = colorStr.replace(/ /g, '').toLowerCase();

    // Color keywords (and transparent) lookup.
    if (str in kCSSColorTable) {
        copyRgba(rgbaArr, kCSSColorTable[str]);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
    }

    // #abc and #abc123 syntax.
    if (str.charAt(0) === '#') {
        if (str.length === 4) {
            var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
            if (!(iv >= 0 && iv <= 0xfff)) {
                setRgba(rgbaArr, 0, 0, 0, 1);
                return;  // Covers NaN.
            }
            setRgba(rgbaArr,
                ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
                (iv & 0xf0) | ((iv & 0xf0) >> 4),
                (iv & 0xf) | ((iv & 0xf) << 4),
                1
            );
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
        }
        else if (str.length === 7) {
            var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
            if (!(iv >= 0 && iv <= 0xffffff)) {
                setRgba(rgbaArr, 0, 0, 0, 1);
                return;  // Covers NaN.
            }
            setRgba(rgbaArr,
                (iv & 0xff0000) >> 16,
                (iv & 0xff00) >> 8,
                iv & 0xff,
                1
            );
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
        }

        return;
    }
    var op = str.indexOf('('), ep = str.indexOf(')');
    if (op !== -1 && ep + 1 === str.length) {
        var fname = str.substr(0, op);
        var params = str.substr(op + 1, ep - (op + 1)).split(',');
        var alpha = 1;  // To allow case fallthrough.
        switch (fname) {
            case 'rgba':
                if (params.length !== 4) {
                    setRgba(rgbaArr, 0, 0, 0, 1);
                    return;
                }
                alpha = parseCssFloat(params.pop()); // jshint ignore:line
            // Fall through.
            case 'rgb':
                if (params.length !== 3) {
                    setRgba(rgbaArr, 0, 0, 0, 1);
                    return;
                }
                setRgba(rgbaArr,
                    parseCssInt(params[0]),
                    parseCssInt(params[1]),
                    parseCssInt(params[2]),
                    alpha
                );
                putToCache(colorStr, rgbaArr);
                return rgbaArr;
            case 'hsla':
                if (params.length !== 4) {
                    setRgba(rgbaArr, 0, 0, 0, 1);
                    return;
                }
                params[3] = parseCssFloat(params[3]);
                hsla2rgba(params, rgbaArr);
                putToCache(colorStr, rgbaArr);
                return rgbaArr;
            case 'hsl':
                if (params.length !== 3) {
                    setRgba(rgbaArr, 0, 0, 0, 1);
                    return;
                }
                hsla2rgba(params, rgbaArr);
                putToCache(colorStr, rgbaArr);
                return rgbaArr;
            default:
                return;
        }
    }

    setRgba(rgbaArr, 0, 0, 0, 1);
    return;
}

/**
 * @param {Array.<number>} hsla
 * @param {Array.<number>} rgba
 * @return {Array.<number>} rgba
 */
function hsla2rgba(hsla, rgba) {
    var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
    // NOTE(deanm): According to the CSS spec s/l should only be
    // percentages, but we don't bother and let float or percentage.
    var s = parseCssFloat(hsla[1]);
    var l = parseCssFloat(hsla[2]);
    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
    var m1 = l * 2 - m2;

    rgba = rgba || [];
    setRgba(rgba,
        clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),
        clampCssByte(cssHueToRgb(m1, m2, h) * 255),
        clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),
        1
    );

    if (hsla.length === 4) {
        rgba[3] = hsla[3];
    }

    return rgba;
}

/**
 * @param {Array.<number>} rgba
 * @return {Array.<number>} hsla
 */
function rgba2hsla(rgba) {
    if (!rgba) {
        return;
    }

    // RGB from 0 to 255
    var R = rgba[0] / 255;
    var G = rgba[1] / 255;
    var B = rgba[2] / 255;

    var vMin = Math.min(R, G, B); // Min. value of RGB
    var vMax = Math.max(R, G, B); // Max. value of RGB
    var delta = vMax - vMin; // Delta RGB value

    var L = (vMax + vMin) / 2;
    var H;
    var S;
    // HSL results from 0 to 1
    if (delta === 0) {
        H = 0;
        S = 0;
    }
    else {
        if (L < 0.5) {
            S = delta / (vMax + vMin);
        }
        else {
            S = delta / (2 - vMax - vMin);
        }

        var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
        var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
        var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;

        if (R === vMax) {
            H = deltaB - deltaG;
        }
        else if (G === vMax) {
            H = (1 / 3) + deltaR - deltaB;
        }
        else if (B === vMax) {
            H = (2 / 3) + deltaG - deltaR;
        }

        if (H < 0) {
            H += 1;
        }

        if (H > 1) {
            H -= 1;
        }
    }

    var hsla = [H * 360, S, L];

    if (rgba[3] != null) {
        hsla.push(rgba[3]);
    }

    return hsla;
}

/**
 * @param {string} color
 * @param {number} level
 * @return {string}
 * @memberOf module:zrender/util/color
 */
function lift(color, level) {
    var colorArr = parse(color);
    if (colorArr) {
        for (var i = 0; i < 3; i++) {
            if (level < 0) {
                colorArr[i] = colorArr[i] * (1 - level) | 0;
            }
            else {
                colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;
            }
        }
        return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
    }
}

/**
 * @param {string} color
 * @return {string}
 * @memberOf module:zrender/util/color
 */
function toHex(color) {
    var colorArr = parse(color);
    if (colorArr) {
        return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);
    }
}

/**
 * Map value to color. Faster than lerp methods because color is represented by rgba array.
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<Array.<number>>} colors List of rgba color array
 * @param {Array.<number>} [out] Mapped gba color array
 * @return {Array.<number>} will be null/undefined if input illegal.
 */
function fastLerp(normalizedValue, colors, out) {
    if (!(colors && colors.length)
        || !(normalizedValue >= 0 && normalizedValue <= 1)
    ) {
        return;
    }

    out = out || [];

    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = colors[leftIndex];
    var rightColor = colors[rightIndex];
    var dv = value - leftIndex;
    out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
    out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
    out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
    out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));

    return out;
}

/**
 * @deprecated
 */
var fastMapToColor = fastLerp;

/**
 * @param {number} normalizedValue A float between 0 and 1.
 * @param {Array.<string>} colors Color list.
 * @param {boolean=} fullOutput Default false.
 * @return {(string|Object)} Result color. If fullOutput,
 *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
 * @memberOf module:zrender/util/color
 */
function lerp(normalizedValue, colors, fullOutput) {
    if (!(colors && colors.length)
        || !(normalizedValue >= 0 && normalizedValue <= 1)
    ) {
        return;
    }

    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = parse(colors[leftIndex]);
    var rightColor = parse(colors[rightIndex]);
    var dv = value - leftIndex;

    var color = stringify(
        [
            clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
            clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
            clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
            clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
        ],
        'rgba'
    );

    return fullOutput
        ? {
            color: color,
            leftIndex: leftIndex,
            rightIndex: rightIndex,
            value: value
        }
        : color;
}

/**
 * @deprecated
 */
var mapToColor = lerp;

/**
 * @param {string} color
 * @param {number=} h 0 ~ 360, ignore when null.
 * @param {number=} s 0 ~ 1, ignore when null.
 * @param {number=} l 0 ~ 1, ignore when null.
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */
function modifyHSL(color, h, s, l) {
    color = parse(color);

    if (color) {
        color = rgba2hsla(color);
        h != null && (color[0] = clampCssAngle(h));
        s != null && (color[1] = parseCssFloat(s));
        l != null && (color[2] = parseCssFloat(l));

        return stringify(hsla2rgba(color), 'rgba');
    }
}

/**
 * @param {string} color
 * @param {number=} alpha 0 ~ 1
 * @return {string} Color string in rgba format.
 * @memberOf module:zrender/util/color
 */
function modifyAlpha(color, alpha) {
    color = parse(color);

    if (color && alpha != null) {
        color[3] = clampCssFloat(alpha);
        return stringify(color, 'rgba');
    }
}

/**
 * @param {Array.<number>} arrColor like [12,33,44,0.4]
 * @param {string} type 'rgba', 'hsva', ...
 * @return {string} Result color. (If input illegal, return undefined).
 */
function stringify(arrColor, type) {
    if (!arrColor || !arrColor.length) {
        return;
    }
    var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
    if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
        colorStr += ',' + arrColor[3];
    }
    return type + '(' + colorStr + ')';
}


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgM2Q3YTQzOGQ0MjkxYzVlZjU5MzUiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9jb3JlL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9jb3JlL0JvdW5kaW5nUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2NvcmUvdmVjdG9yLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvY29yZS9jdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2NvcmUvZW52LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvbWl4aW4vRXZlbnRmdWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9jb250YWluZXIvR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9jb3JlL2V2ZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2dyYXBoaWMvaGVscGVyL2ltYWdlLmpzIiwid2VicGFjazovLy8uL3NyYy9Qb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL0VsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9hbmltYXRpb24vQW5pbWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvY29udGFpbi90ZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvY29udGFpbi91dGlsLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvY29yZS9MUlUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9jb3JlL1BhdGhQcm94eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2NvcmUvbG9nLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvY29yZS9tYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9jb3JlL3RpbXNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9ncmFwaGljL1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9ncmFwaGljL1BhdHRlcm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9ncmFwaGljL1N0eWxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUm9hZExpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NjZW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvZ3JhcGhpYy9UZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvenJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwLmpzIiwid2VicGFjazovLy8uL34vbGluZS1pbnRlcnNlY3QvZXMvY2hlY2staW50ZXJzZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vbGluZS1pbnRlcnNlY3QvZXMvY29saW5lYXItcG9pbnQtd2l0aGluLXNlZ21lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9saW5lLWludGVyc2VjdC9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL0hhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9MYXllci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL1BhaW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9TdG9yYWdlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvYW5pbWF0aW9uL0FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2FuaW1hdGlvbi9DbGlwLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvYW5pbWF0aW9uL2Vhc2luZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2NvbnRhaW4vYXJjLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvY29udGFpbi9jdWJpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2NvbnRhaW4vbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2NvbnRhaW4vcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2NvbnRhaW4vcXVhZHJhdGljLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvY29udGFpbi93aW5kaW5nTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2NvcmUvR2VzdHVyZU1nci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2NvcmUvYmJveC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2RvbS9IYW5kbGVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy9ncmFwaGljL0ltYWdlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvZ3JhcGhpYy9oZWxwZXIvcm91bmRSZWN0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9zcmMvbWl4aW4vQW5pbWF0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL21peGluL0RyYWdnYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvc3JjL21peGluL1RyYW5zZm9ybWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL3NyYy90b29sL2NvbG9yLmpzIl0sIm5hbWVzIjpbIlBvaW50IiwibW9kZWwiLCJDaXJjbGUiLCJjYWxsIiwic2hhcGUiLCJyIiwiY3giLCJ4IiwiY3kiLCJ5IiwiZHJhZ2dhYmxlIiwib25kcmFnZW5kIiwiZXZ0Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJwYXJlbnQiLCJjcm9zcyIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsIlJvYWRMaW5lIiwib3BzIiwiR3JvdXAiLCJ0eXBlIiwic3RhcnQiLCJ4MSIsInkxIiwiZW5kIiwieDIiLCJ5MiIsImNyb3NzUG9pbnRzIiwibGluZSIsIkxpbmUiLCJhZGQiLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJvbmRyYWciLCJhdHRyIiwiY3Jvc3NMaW5lIiwidGFyZ2V0IiwicmVzIiwiY2hlY2tJbnRlcnNlY3Rpb24iLCJwb2ludCIsInRvRGF0YSIsIlNjZW5lIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJpdGVtIiwiZm9yRWFjaCIsImNwIiwicmVtb3ZlIiwibGluZXMiLCJpIiwibGVuZ3RoIiwibGluZTEiLCJqIiwibGluZTIiLCJjcnBvaW50IiwiY29udGFpbmVyIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwienIiLCJ6cmVuZGVyIiwic2NlbmUiLCJ0ZXh0IiwiVGV4dCIsInN0eWxlIiwib24iLCJkYXRhcyIsInB1c2giLCJjb25zb2xlIiwiZGVidWciLCJwb3NpdGlvbiIsIm9uY29udGV4dG1lbnUiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInJlc2l6ZSIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFD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LFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFZSxpRUFBUSxFOzs7Ozs7O0FDM1N2QjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFdUM7QUFDTjtBQUNlOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJLHlEQUFPOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsMkRBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUVBQVk7QUFDdEM7QUFDQTs7QUFFQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQWUsUUFBUSx5REFBTzs7QUFFZiw4REFBSyxFOzs7Ozs7O0FDMVRwQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QztBQUNqQjs7QUFFeEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTs7QUFFQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscURBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLGNBQWMsYUFBYTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ2dDOzs7Ozs7OztBQ3JKaEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHdUM7QUFDWDtBQUNLO0FBQ087O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJLHlEQUFPOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHFCQUFxQix1REFBSzs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEMsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLFlBQVkseURBQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLHlCQUF5Qix1REFBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0REFBZSxjQUFjLHlEQUFPOztBQUVwQyx5REFBWSxjQUFjLGdFQUFRO0FBQ2xDOztBQUVlLG9FQUFXLEU7Ozs7Ozs7Ozs7OztBQ3RRTzs7QUFFakMsMkJBQTJCLDBEQUFHOztBQUU5QjtBQUNBLFdBQVcsaURBQWlEO0FBQzVELFlBQVksMENBQTBDO0FBQ3REO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpREFBaUQ7QUFDNUQsV0FBVywwQ0FBMEM7QUFDckQsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixZQUFZLDBDQUEwQztBQUN0RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlDQUFpQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7Ozs7Ozs7OztBQ3pGQTtBQUFBO0FBQUE7O0FBRUEsU0FBU0EsS0FBVCxDQUFlQyxLQUFmLEVBQXFCO0FBQ2pCQyxxRkFBTUEsQ0FBQ0MsSUFBUCxDQUFZLElBQVo7QUFDQSxTQUFLQyxLQUFMLENBQVdDLENBQVgsR0FBZSxDQUFmO0FBQ0EsU0FBS0QsS0FBTCxDQUFXRSxFQUFYLEdBQWdCTCxNQUFNTSxDQUF0QjtBQUNBLFNBQUtILEtBQUwsQ0FBV0ksRUFBWCxHQUFnQlAsTUFBTVEsQ0FBdEI7QUFDQSxTQUFLQyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsU0FBS0MsU0FBTCxHQUFrQkMsR0FBRCxJQUFTO0FBQ3RCWCxjQUFNTSxDQUFOLEdBQVVLLElBQUlDLE9BQWQ7QUFDQVosY0FBTVEsQ0FBTixHQUFVRyxJQUFJRSxPQUFkO0FBQ0EsYUFBS0MsTUFBTCxDQUFZQyxLQUFaO0FBQ0gsS0FKRDtBQUtIO0FBQ0RoQixNQUFNaUIsU0FBTixHQUFrQkMsT0FBT0MsTUFBUCxDQUFjakIsaUZBQU1BLENBQUNlLFNBQXJCLENBQWxCOzs7Ozs7Ozs7QUNkQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQStCO0FBQ1M7QUFDVTtBQUNOO0FBQ047O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0EsK0JBQStCOztBQUUvQixJQUFJLHFFQUFhO0FBQ2pCLElBQUksZ0VBQVE7QUFDWixJQUFJLGtFQUFVOztBQUVkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSx5QkFBeUIsa0ZBQUk7QUFDN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNERBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5REFBWSxVQUFVLGtFQUFVO0FBQ2hDLHlEQUFZLFVBQVUscUVBQWE7QUFDbkMseURBQVksVUFBVSxnRUFBUTs7QUFFZixnRUFBTyxFOzs7Ozs7O0FDL1B0QjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQ2E7QUFDRTs7QUFFekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07QUFDbEIsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQywyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07QUFDbEIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsc0ZBQVc7QUFDbkI7QUFDQSxZQUFZLHNGQUFXO0FBQ3ZCO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsc0ZBQVc7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNGQUFXO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0RBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyx5QkFBeUI7QUFDekIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQiw4QkFBOEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlLGlFQUFRLEU7Ozs7Ozs7O0FDMW9CUjtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDWkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBZ0Q7QUFDTztBQU1qQzs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixxQkFBcUIsS0FBSzs7QUFFdEM7O0FBRVA7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPLEVBQUU7QUFDckI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLG1FQUFZO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsbUVBQVk7QUFDM0I7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU8sT0FBTztBQUN6QixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPLEVBQUU7QUFDckI7QUFDTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsaUZBQU0sR0FBRzs7QUFFdkI7QUFDQSxtQkFBbUIsb0ZBQVM7QUFDNUIsNEJBQTRCLG9GQUFTO0FBQ3JDLG9DQUFvQyxvRkFBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0ZBQVM7O0FBRW5DO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEUsbUJBQW1CLDZDQUE2QztBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUNBQWlDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMscUZBQVU7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU8sU0FBUztBQUM1QjtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixZQUFZLFdBQVcsWUFBWSxJQUFJLEdBQUc7QUFDdEUsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxvRkFBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0ZBQVM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2RUFBMEI7QUFDMUQsNEJBQTRCLDJFQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxvRkFBUztBQUM1RCxxREFBcUQsb0ZBQVM7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRUFBa0UsV0FBVzs7QUFFN0U7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEdBQUc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDdHFCQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7O0FDVEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsNERBQUcsRTs7Ozs7OztBQ2xNbEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVpQztBQUNBO0FBQ0Y7QUFDVztBQUNROztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpRUFBRztBQUNsQywrQkFBK0IsaUVBQUc7QUFDbEMsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekMsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxvRUFBb0U7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVEQUFhO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaUJBQWlCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVEQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isc0RBQVk7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1REFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG9EQUFRO0FBQ3BCLFlBQVksb0RBQVE7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDhEQUFZO0FBQy9CO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZSxrRUFBUyxFOzs7Ozs7O0FDanhCeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZTtBQUNmO0FBQ0EsQzs7Ozs7OztBQ1ZBO0FBQW9DOztBQUVwQztBQUNBOztBQUVBLElBQUksMERBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBEQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSw0REFBRyxFOzs7Ozs7O0FDcEJsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkMsV0FBVyw0QkFBNEI7QUFDdkMsV0FBVyw0QkFBNEI7QUFDdkM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsT0FBTztBQUNsQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoS0E7QUFBQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsT0FBTztBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsT0FBTztBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsT0FBTztBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsT0FBTztBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsT0FBTztBQUNy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QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMzEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDNkN2E0MzhkNDI5MWM1ZWY1OTM1IiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuLy8g55So5LqO5aSE55CGbWVyZ2Xml7bml6Dms5XpgY3ljoZEYXRl562J5a+56LGh55qE6Zeu6aKYXG52YXIgQlVJTFRJTl9PQkpFQ1QgPSB7XG4gICAgJ1tvYmplY3QgRnVuY3Rpb25dJzogMSxcbiAgICAnW29iamVjdCBSZWdFeHBdJzogMSxcbiAgICAnW29iamVjdCBEYXRlXSc6IDEsXG4gICAgJ1tvYmplY3QgRXJyb3JdJzogMSxcbiAgICAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nOiAxLFxuICAgICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJzogMSxcbiAgICAvLyBGb3Igbm9kZS1jYW52YXNcbiAgICAnW29iamVjdCBJbWFnZV0nOiAxLFxuICAgICdbb2JqZWN0IENhbnZhc10nOiAxXG59O1xuXG52YXIgVFlQRURfQVJSQVkgPSB7XG4gICAgJ1tvYmplY3QgSW50OEFycmF5XSc6IDEsXG4gICAgJ1tvYmplY3QgVWludDhBcnJheV0nOiAxLFxuICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6IDEsXG4gICAgJ1tvYmplY3QgSW50MTZBcnJheV0nOiAxLFxuICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XSc6IDEsXG4gICAgJ1tvYmplY3QgSW50MzJBcnJheV0nOiAxLFxuICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XSc6IDEsXG4gICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc6IDEsXG4gICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc6IDFcbn07XG5cbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIG5hdGl2ZUZvckVhY2ggPSBhcnJheVByb3RvLmZvckVhY2g7XG52YXIgbmF0aXZlRmlsdGVyID0gYXJyYXlQcm90by5maWx0ZXI7XG52YXIgbmF0aXZlU2xpY2UgPSBhcnJheVByb3RvLnNsaWNlO1xudmFyIG5hdGl2ZU1hcCA9IGFycmF5UHJvdG8ubWFwO1xudmFyIG5hdGl2ZVJlZHVjZSA9IGFycmF5UHJvdG8ucmVkdWNlO1xuXG4vLyBBdm9pZCBhc3NpZ24gdG8gYW4gZXhwb3J0ZWQgdmFyaWFibGUsIGZvciB0cmFuc2Zvcm1pbmcgdG8gY2pzLlxudmFyIG1ldGhvZHMgPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uICRvdmVycmlkZShuYW1lLCBmbikge1xuICAgIG1ldGhvZHNbbmFtZV0gPSBmbjtcbn1cblxuLyoqXG4gKiBUaG9zZSBkYXRhIHR5cGVzIGNhbiBiZSBjbG9uZWQ6XG4gKiAgICAgUGxhaW4gb2JqZWN0LCBBcnJheSwgVHlwZWRBcnJheSwgbnVtYmVyLCBzdHJpbmcsIG51bGwsIHVuZGVmaW5lZC5cbiAqIFRob3NlIGRhdGEgdHlwZXMgd2lsbCBiZSBhc3NnaW5lZCB1c2luZyB0aGUgb3JnaW5hbCBkYXRhOlxuICogICAgIEJVSUxUSU5fT0JKRUNUXG4gKiBJbnN0YW5jZSBvZiB1c2VyIGRlZmluZWQgY2xhc3Mgd2lsbCBiZSBjbG9uZWQgdG8gYSBwbGFpbiBvYmplY3QsIHdpdGhvdXRcbiAqIHByb3BlcnRpZXMgaW4gcHJvdG90eXBlLlxuICogT3RoZXIgZGF0YSB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkIChub3Qgc3VyZSB3aGF0IHdpbGwgaGFwcGVuKS5cbiAqXG4gKiBDYXV0aW9uOiBkbyBub3Qgc3VwcG9ydCBjbG9uZSBEYXRlLCBmb3IgcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbi5cbiAqIChUaGVyZSBtaWdodCBiZSBhIGxhcmdlIG51bWJlciBvZiBkYXRlIGluIGBzZXJpZXMuZGF0YWApLlxuICogU28gZGF0ZSBzaG91bGQgbm90IGJlIG1vZGlmaWVkIGluIGFuZCBvdXQgb2YgZWNoYXJ0cy5cbiAqXG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQHJldHVybiB7Kn0gbmV3XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwgfHwgdHlwZW9mIHNvdXJjZSAhPSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBzb3VyY2U7XG4gICAgdmFyIHR5cGVTdHIgPSBvYmpUb1N0cmluZy5jYWxsKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZVN0ciA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gY2xvbmUoc291cmNlW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChUWVBFRF9BUlJBWVt0eXBlU3RyXSkge1xuICAgICAgICB2YXIgQ3RvciA9IHNvdXJjZS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKHNvdXJjZS5jb25zdHJ1Y3Rvci5mcm9tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBDdG9yLmZyb20oc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBDdG9yKHNvdXJjZS5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoIUJVSUxUSU5fT0JKRUNUW3R5cGVTdHJdICYmICFpc1ByaW1pdGl2ZShzb3VyY2UpICYmICFpc0RvbShzb3VyY2UpKSB7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3ZlcndyaXRlKSB7XG4gICAgLy8gV2Ugc2hvdWxkIGVzY2Fwc2UgdGhhdCBzb3VyY2UgaXMgc3RyaW5nXG4gICAgLy8gYW5kIGVudGVyIGZvciAuLi4gaW4gLi4uXG4gICAgaWYgKCFpc09iamVjdChzb3VyY2UpIHx8ICFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBvdmVyd3JpdGUgPyBjbG9uZShzb3VyY2UpIDogdGFyZ2V0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0UHJvcCA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgdmFyIHNvdXJjZVByb3AgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgJiYgaXNPYmplY3QodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAmJiAhaXNBcnJheShzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICYmICFpc0FycmF5KHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgJiYgIWlzRG9tKHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgJiYgIWlzRG9tKHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgJiYgIWlzQnVpbHRJbk9iamVjdChzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICYmICFpc0J1aWx0SW5PYmplY3QodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAmJiAhaXNQcmltaXRpdmUoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAmJiAhaXNQcmltaXRpdmUodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIOWmguaenOmcgOimgemAkuW9kuimhueblu+8jOWwsemAkuW9kuiwg+eUqG1lcmdlXG4gICAgICAgICAgICAgICAgbWVyZ2UodGFyZ2V0UHJvcCwgc291cmNlUHJvcCwgb3ZlcndyaXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJ3cml0ZSB8fCAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8g5ZCm5YiZ5Y+q5aSE55CGb3ZlcndyaXRl5Li6dHJ1Ze+8jOaIluiAheWcqOebruagh+WvueixoeS4reayoeacieatpOWxnuaAp+eahOaDheWGtVxuICAgICAgICAgICAgICAgIC8vIE5PVEXvvIzlnKggdGFyZ2V0W2tleV0g5LiN5a2Y5Zyo55qE5pe25YCZ5Lmf5piv55u05o6l6KaG55uWXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldEFuZFNvdXJjZXMgVGhlIGZpcnN0IGl0ZW0gaXMgdGFyZ2V0LCBhbmQgdGhlIHJlc3RzIGFyZSBzb3VyY2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gKiBAcmV0dXJuIHsqfSB0YXJnZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQWxsKHRhcmdldEFuZFNvdXJjZXMsIG92ZXJ3cml0ZSkge1xuICAgIHZhciByZXN1bHQgPSB0YXJnZXRBbmRTb3VyY2VzWzBdO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0YXJnZXRBbmRTb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IG1lcmdlKHJlc3VsdCwgdGFyZ2V0QW5kU291cmNlc1tpXSwgb3ZlcndyaXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBzb3VyY2VcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVybGF5PWZhbHNlXVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KVxuICAgICAgICAgICAgJiYgKG92ZXJsYXkgPyBzb3VyY2Vba2V5XSAhPSBudWxsIDogdGFyZ2V0W2tleV0gPT0gbnVsbClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCB2YXIgY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtZXRob2RzLmNyZWF0ZUNhbnZhcygpO1xufTtcblxubWV0aG9kcy5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xufTtcblxuLy8gRklYTUVcbnZhciBfY3R4O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICBpZiAoIV9jdHgpIHtcbiAgICAgICAgLy8gVXNlIHV0aWwuY3JlYXRlQ2FudmFzIGluc3RlYWQgb2YgY3JlYXRlQ2FudmFzXG4gICAgICAgIC8vIGJlY2F1c2UgY3JlYXRlQ2FudmFzIG1heSBiZSBvdmVyd3JpdHRlbiBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRcbiAgICAgICAgX2N0eCA9IGNyZWF0ZUNhbnZhcygpLmdldENvbnRleHQoJzJkJyk7XG4gICAgfVxuICAgIHJldHVybiBfY3R4O1xufVxuXG4vKipcbiAqIOafpeivouaVsOe7hOS4reWFg+e0oOeahGluZGV4XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgIGlmIChhcnJheSkge1xuICAgICAgICBpZiAoYXJyYXkuaW5kZXhPZikge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiDmnoTpgKDnsbvnu6fmib/lhbPns7tcbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGF6eiDmupDnsbtcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcbiAgICB2YXIgY2xhenpQcm90b3R5cGUgPSBjbGF6ei5wcm90b3R5cGU7XG4gICAgZnVuY3Rpb24gRigpIHt9XG4gICAgRi5wcm90b3R5cGUgPSBiYXNlQ2xhenoucHJvdG90eXBlO1xuICAgIGNsYXp6LnByb3RvdHlwZSA9IG5ldyBGKCk7XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XG4gICAgICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xuICAgIH1cbiAgICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcbiAgICBjbGF6ei5zdXBlckNsYXNzID0gYmFzZUNsYXp6O1xufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBzb3JjZVxuICogQHBhcmFtIHtib29sZWFufSBvdmVybGF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICAgIHRhcmdldCA9ICdwcm90b3R5cGUnIGluIHRhcmdldCA/IHRhcmdldC5wcm90b3R5cGUgOiB0YXJnZXQ7XG4gICAgc291cmNlID0gJ3Byb3RvdHlwZScgaW4gc291cmNlID8gc291cmNlLnByb3RvdHlwZSA6IHNvdXJjZTtcblxuICAgIGRlZmF1bHRzKHRhcmdldCwgc291cmNlLCBvdmVybGF5KTtcbn1cblxuLyoqXG4gKiBDb25zaWRlciB0eXBlZCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl8VHlwZWRBcnJheX0gZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUxpa2UoZGF0YSkge1xuICAgIGlmICghIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIGRhdGEubGVuZ3RoID09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIOaVsOe7hOaIluWvueixoemBjeWOhlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9iai5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGNiLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiDmlbDnu4TmmKDlsIRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvYmoubWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkge1xuICAgICAgICByZXR1cm4gb2JqLm1hcChjYiwgY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gW21lbW9dXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2Uob2JqLCBjYiwgbWVtbywgY29udGV4dCkge1xuICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob2JqLnJlZHVjZSAmJiBvYmoucmVkdWNlID09PSBuYXRpdmVSZWR1Y2UpIHtcbiAgICAgICAgcmV0dXJuIG9iai5yZWR1Y2UoY2IsIG1lbW8sIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbWVtbyA9IGNiLmNhbGwoY29udGV4dCwgbWVtbywgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cbn1cblxuLyoqXG4gKiDmlbDnu4Tov4fmu6RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcihvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvYmouZmlsdGVyICYmIG9iai5maWx0ZXIgPT09IG5hdGl2ZUZpbHRlcikge1xuICAgICAgICByZXR1cm4gb2JqLmZpbHRlcihjYiwgY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbi8qKlxuICog5pWw57uE6aG55p+l5om+XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQob2JqLCBjYiwgY29udGV4dCkge1xuICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZChmdW5jLCBjb250ZXh0KSB7XG4gICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1cnJ5KGZ1bmMpIHtcbiAgICB2YXIgYXJncyA9IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgKCEhdmFsdWUgJiYgdHlwZSA9PSAnb2JqZWN0Jyk7XG59XG5cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnVpbHRJbk9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiAhIUJVSUxUSU5fT0JKRUNUW29ialRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEb20odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuICAgICAgICAmJiB0eXBlb2YgdmFsdWUubm9kZVR5cGUgPT09ICdudW1iZXInXG4gICAgICAgICYmIHR5cGVvZiB2YWx1ZS5vd25lckRvY3VtZW50ID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBXaGV0aGVyIGlzIGV4YWN0bHkgTmFOLiBOb3RpY2UgaXNOYU4oJ2EnKSByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXFOYU4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG4vKipcbiAqIElmIHZhbHVlMSBpcyBub3QgbnVsbCwgdGhlbiByZXR1cm4gdmFsdWUxLCBvdGhlcndpc2UganVkZ2V0IHJlc3Qgb2YgdmFsdWVzLlxuICogTG93IHBlcmZvcm1hbmNlLlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlKHZhbHVlcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV0cmlldmUyKHZhbHVlMCwgdmFsdWUxKSB7XG4gICAgcmV0dXJuIHZhbHVlMCAhPSBudWxsXG4gICAgICAgID8gdmFsdWUwXG4gICAgICAgIDogdmFsdWUxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV0cmlldmUzKHZhbHVlMCwgdmFsdWUxLCB2YWx1ZTIpIHtcbiAgICByZXR1cm4gdmFsdWUwICE9IG51bGxcbiAgICAgICAgPyB2YWx1ZTBcbiAgICAgICAgOiB2YWx1ZTEgIT0gbnVsbFxuICAgICAgICA/IHZhbHVlMVxuICAgICAgICA6IHZhbHVlMjtcbn1cblxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gZW5kSW5kZXhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2UoKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLmNhbGwuYXBwbHkobmF0aXZlU2xpY2UsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGNzcyBsaWtlZCBhcnJheSBjb25maWd1cmF0aW9uXG4gKiBlLmcuXG4gKiAgMyA9PiBbMywgMywgMywgM11cbiAqICBbNCwgMl0gPT4gWzQsIDIsIDQsIDJdXG4gKiAgWzQsIDMsIDJdID0+IFs0LCAzLCAyLCAzXVxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHZhbFxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVDc3NBcnJheSh2YWwpIHtcbiAgICBpZiAodHlwZW9mICh2YWwpID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWwsIHZhbF07XG4gICAgfVxuICAgIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuICAgIGlmIChsZW4gPT09IDIpIHtcbiAgICAgICAgLy8gdmVydGljYWwgfCBob3Jpem9udGFsXG4gICAgICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFswXSwgdmFsWzFdXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuID09PSAzKSB7XG4gICAgICAgIC8vIHRvcCB8IGhvcml6b250YWwgfCBib3R0b21cbiAgICAgICAgcmV0dXJuIFt2YWxbMF0sIHZhbFsxXSwgdmFsWzJdLCB2YWxbMV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG59XG5cbnZhciBwcmltaXRpdmVLZXkgPSAnX19lY19wcmltaXRpdmVfXyc7XG4vKipcbiAqIFNldCBhbiBvYmplY3QgYXMgcHJpbWl0aXZlIHRvIGJlIGlnbm9yZWQgdHJhdmVyc2luZyBjaGlsZHJlbiBpbiBjbG9uZSBvciBtZXJnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0QXNQcmltaXRpdmUob2JqKSB7XG4gICAgb2JqW3ByaW1pdGl2ZUtleV0gPSB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcmltaXRpdmUob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcmltaXRpdmVLZXldO1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPbmx5IGFwcGx5IGBvd25Qcm9wZXJ0eWAuXG4gKi9cbmZ1bmN0aW9uIEhhc2hNYXAob2JqKSB7XG4gICAgb2JqICYmIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICB9LCB0aGlzKTtcbn1cblxuLy8gQWRkIHByZWZpeCB0byBhdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUuXG52YXIgSEFTSF9NQVBfUFJFRklYID0gJ19lY18nO1xudmFyIEhBU0hfTUFQX1BSRUZJWF9MRU5HVEggPSA0O1xuXG5IYXNoTWFwLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogSGFzaE1hcCxcbiAgICAvLyBEbyBub3QgcHJvdmlkZSBgaGFzYCBtZXRob2QgdG8gYXZvaWQgZGVmaW5pbmcgd2hhdCBpcyBgaGFzYC5cbiAgICAvLyAoV2UgdXN1YWxseSB0cmVhdCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFzIHRoZSBzYW1lLCBkaWZmZXJlbnRcbiAgICAvLyBmcm9tIEVTNiBNYXApLlxuICAgIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpc1tIQVNIX01BUF9QUkVGSVggKyBrZXldO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV0gPSB2YWx1ZTtcbiAgICAgICAgLy8gQ29tcGFyaW5nIHdpdGggaW52b2NhdGlvbiBjaGFpbmluZywgYHJldHVybiB2YWx1ZWAgaXMgbW9yZSBjb21tb25seVxuICAgICAgICAvLyB1c2VkIGluIHRoaXMgY2FzZTogYHZhciBzb21lVmFsID0gbWFwLnNldCgnYScsIGdlblZhbCgpKTtgXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIC8vIEFsdGhvdWdoIHV0aWwuZWFjaCBjYW4gYmUgcGVyZm9ybWVkIG9uIHRoaXMgaGFzaE1hcCBkaXJlY3RseSwgdXNlclxuICAgIC8vIHNob3VsZCBub3QgdXNlIHRoZSBleHBvc2VkIGtleXMsIHdobyBhcmUgcHJlZml4ZWQuXG4gICAgZWFjaDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgIT09IHZvaWQgMCAmJiAoY2IgPSBiaW5kKGNiLCBjb250ZXh0KSk7XG4gICAgICAgIGZvciAodmFyIHByZWZpeGVkS2V5IGluIHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzT3duUHJvcGVydHkocHJlZml4ZWRLZXkpXG4gICAgICAgICAgICAgICAgJiYgY2IodGhpc1twcmVmaXhlZEtleV0sIHByZWZpeGVkS2V5LnNsaWNlKEhBU0hfTUFQX1BSRUZJWF9MRU5HVEgpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBpZiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gICAgcmVtb3ZlS2V5OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hNYXAob2JqKSB7XG4gICAgcmV0dXJuIG5ldyBIYXNoTWFwKG9iaik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge31cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9jb3JlL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAqL1xuXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4vdmVjdG9yJztcbmltcG9ydCAqIGFzIG1hdHJpeCBmcm9tICcuL21hdHJpeCc7XG5cbnZhciB2MkFwcGx5VHJhbnNmb3JtID0gdmVjMi5hcHBseVRyYW5zZm9ybTtcbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICovXG5mdW5jdGlvbiBCb3VuZGluZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICB4ID0geCArIHdpZHRoO1xuICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnggPSB4O1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy55ID0geTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xufVxuXG5Cb3VuZGluZ1JlY3QucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IEJvdW5kaW5nUmVjdCxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9IG90aGVyXG4gICAgICovXG4gICAgdW5pb246IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgeCA9IG1hdGhNaW4ob3RoZXIueCwgdGhpcy54KTtcbiAgICAgICAgdmFyIHkgPSBtYXRoTWluKG90aGVyLnksIHRoaXMueSk7XG5cbiAgICAgICAgdGhpcy53aWR0aCA9IG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgb3RoZXIueCArIG90aGVyLndpZHRoLFxuICAgICAgICAgICAgICAgIHRoaXMueCArIHRoaXMud2lkdGhcbiAgICAgICAgICAgICkgLSB4O1xuICAgICAgICB0aGlzLmhlaWdodCA9IG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgb3RoZXIueSArIG90aGVyLmhlaWdodCxcbiAgICAgICAgICAgICAgICB0aGlzLnkgKyB0aGlzLmhlaWdodFxuICAgICAgICAgICAgKSAtIHk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1cbiAgICAgKiBAbWV0aG9kc1xuICAgICAqL1xuICAgIGFwcGx5VHJhbnNmb3JtOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbHQgPSBbXTtcbiAgICAgICAgdmFyIHJiID0gW107XG4gICAgICAgIHZhciBsYiA9IFtdO1xuICAgICAgICB2YXIgcnQgPSBbXTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIHVzYWdlIGxpa2UgdGhpc1xuICAgICAgICAgICAgLy8gZWwuZ2V0Qm91bmRpbmdSZWN0KCkuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKVxuICAgICAgICAgICAgLy8gQW5kIGVsZW1lbnQgaGFzIG5vIHRyYW5zZm9ybVxuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbHRbMF0gPSBsYlswXSA9IHRoaXMueDtcbiAgICAgICAgICAgIGx0WzFdID0gcnRbMV0gPSB0aGlzLnk7XG4gICAgICAgICAgICByYlswXSA9IHJ0WzBdID0gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICAgICAgICAgIHJiWzFdID0gbGJbMV0gPSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblxuICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShsdCwgbHQsIG0pO1xuICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShyYiwgcmIsIG0pO1xuICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShsYiwgbGIsIG0pO1xuICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShydCwgcnQsIG0pO1xuXG4gICAgICAgICAgICB0aGlzLnggPSBtYXRoTWluKGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgICAgICAgIHRoaXMueSA9IG1hdGhNaW4obHRbMV0sIHJiWzFdLCBsYlsxXSwgcnRbMV0pO1xuICAgICAgICAgICAgdmFyIG1heFggPSBtYXRoTWF4KGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgICAgICAgIHZhciBtYXhZID0gbWF0aE1heChsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gbWF4WCAtIHRoaXMueDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbWF4WSAtIHRoaXMueTtcbiAgICAgICAgfTtcbiAgICB9KSgpLFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIG1hdHJpeCBvZiB0cmFuc2Zvcm1pbmcgZnJvbSBzZWxmIHRvIHRhcmdldCByZWN0XG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IGJcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgICAgIHZhciBzeSA9IGIuaGVpZ2h0IC8gYS5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIG0gPSBtYXRyaXguY3JlYXRlKCk7XG5cbiAgICAgICAgLy8g55+p6Zi15Y+z5LmYXG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUobSwgbSwgWy1hLngsIC1hLnldKTtcbiAgICAgICAgbWF0cml4LnNjYWxlKG0sIG0sIFtzeCwgc3ldKTtcbiAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbYi54LCBiLnldKTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsobW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R8T2JqZWN0KX0gYlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoYikge1xuICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKGIgaW5zdGFuY2VvZiBCb3VuZGluZ1JlY3QpKSB7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgbmVnYXRpdmUgd2lkdGgvaGVpZ2h0LlxuICAgICAgICAgICAgYiA9IEJvdW5kaW5nUmVjdC5jcmVhdGUoYik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIHZhciBheDAgPSBhLng7XG4gICAgICAgIHZhciBheDEgPSBhLnggKyBhLndpZHRoO1xuICAgICAgICB2YXIgYXkwID0gYS55O1xuICAgICAgICB2YXIgYXkxID0gYS55ICsgYS5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGJ4MCA9IGIueDtcbiAgICAgICAgdmFyIGJ4MSA9IGIueCArIGIud2lkdGg7XG4gICAgICAgIHZhciBieTAgPSBiLnk7XG4gICAgICAgIHZhciBieTEgPSBiLnkgKyBiLmhlaWdodDtcblxuICAgICAgICByZXR1cm4gISAoYXgxIDwgYngwIHx8IGJ4MSA8IGF4MCB8fCBheTEgPCBieTAgfHwgYnkxIDwgYXkwKTtcbiAgICB9LFxuXG4gICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzO1xuICAgICAgICByZXR1cm4geCA+PSByZWN0LnhcbiAgICAgICAgICAgICYmIHggPD0gKHJlY3QueCArIHJlY3Qud2lkdGgpXG4gICAgICAgICAgICAmJiB5ID49IHJlY3QueVxuICAgICAgICAgICAgJiYgeSA8PSAocmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3B5IGZyb20gYW5vdGhlciByZWN0XG4gICAgICovXG4gICAgY29weTogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHRoaXMueCA9IG90aGVyLng7XG4gICAgICAgIHRoaXMueSA9IG90aGVyLnk7XG4gICAgICAgIHRoaXMud2lkdGggPSBvdGhlci53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XG4gICAgfSxcblxuICAgIHBsYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB0aGlzLngsXG4gICAgICAgICAgICB5OiB0aGlzLnksXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fG1vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC54XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC55XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC53aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3QuaGVpZ2h0XG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAqL1xuQm91bmRpbmdSZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJvdW5kaW5nUmVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvY29yZS9Cb3VuZGluZ1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCdcbiAgICA/IEFycmF5XG4gICAgOiBGbG9hdDMyQXJyYXk7XG5cbi8qKlxuICog5Yib5bu65LiA5Liq5ZCR6YePXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICogQHJldHVybiB7VmVjdG9yMn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSh4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG4gICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICB4ID0gMDtcbiAgICB9XG4gICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICB5ID0gMDtcbiAgICB9XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICog5aSN5Yi25ZCR6YeP5pWw5o2uXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtWZWN0b3IyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IHZbMV07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiDlhYvpmobkuIDkuKrlkJHph49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHJldHVybiB7VmVjdG9yMn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKHYpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IHZbMV07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiDorr7nva7lkJHph4/nmoTkuKTkuKrpoblcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9IOe7k+aenFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGE7XG4gICAgb3V0WzFdID0gYjtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIOWQkemHj+ebuOWKoFxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIHYxLCB2Mikge1xuICAgIG91dFswXSA9IHYxWzBdICsgdjJbMF07XG4gICAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIOWQkemHj+e8qeaUvuWQjuebuOWKoFxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIHYxLCB2MiwgYSkge1xuICAgIG91dFswXSA9IHYxWzBdICsgdjJbMF0gKiBhO1xuICAgIG91dFsxXSA9IHYxWzFdICsgdjJbMV0gKiBhO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICog5ZCR6YeP55u45YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ViKG91dCwgdjEsIHYyKSB7XG4gICAgb3V0WzBdID0gdjFbMF0gLSB2MlswXTtcbiAgICBvdXRbMV0gPSB2MVsxXSAtIHYyWzFdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICog5ZCR6YeP6ZW/5bqmXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlbih2KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChsZW5TcXVhcmUodikpO1xufVxuZXhwb3J0IHZhciBsZW5ndGggPSBsZW47IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4vKipcbiAqIOWQkemHj+mVv+W6puW5s+aWuVxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5TcXVhcmUodikge1xuICAgIHJldHVybiB2WzBdICogdlswXSArIHZbMV0gKiB2WzFdO1xufVxuZXhwb3J0IHZhciBsZW5ndGhTcXVhcmUgPSBsZW5TcXVhcmU7XG5cbi8qKlxuICog5ZCR6YeP5LmY5rOVXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsKG91dCwgdjEsIHYyKSB7XG4gICAgb3V0WzBdID0gdjFbMF0gKiB2MlswXTtcbiAgICBvdXRbMV0gPSB2MVsxXSAqIHYyWzFdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICog5ZCR6YeP6Zmk5rOVXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGl2KG91dCwgdjEsIHYyKSB7XG4gICAgb3V0WzBdID0gdjFbMF0gLyB2MlswXTtcbiAgICBvdXRbMV0gPSB2MVsxXSAvIHYyWzFdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICog5ZCR6YeP54K55LmYXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3QodjEsIHYyKSB7XG4gICAgcmV0dXJuIHYxWzBdICogdjJbMF0gKyB2MVsxXSAqIHYyWzFdO1xufVxuXG4vKipcbiAqIOWQkemHj+e8qeaUvlxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHBhcmFtIHtudW1iZXJ9IHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgdiwgcykge1xuICAgIG91dFswXSA9IHZbMF0gKiBzO1xuICAgIG91dFsxXSA9IHZbMV0gKiBzO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICog5ZCR6YeP5b2S5LiA5YyWXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCB2KSB7XG4gICAgdmFyIGQgPSBsZW4odik7XG4gICAgaWYgKGQgPT09IDApIHtcbiAgICAgICAgb3V0WzBdID0gMDtcbiAgICAgICAgb3V0WzFdID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG91dFswXSA9IHZbMF0gLyBkO1xuICAgICAgICBvdXRbMV0gPSB2WzFdIC8gZDtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiDorqHnrpflkJHph4/pl7Tot53nprtcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKHYxLCB2Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKVxuICAgICAgICArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKVxuICAgICk7XG59XG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcblxuLyoqXG4gKiDlkJHph4/ot53nprvlubPmlrlcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlU3F1YXJlKHYxLCB2Mikge1xuICAgIHJldHVybiAodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSlcbiAgICAgICAgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSk7XG59XG5leHBvcnQgdmFyIGRpc3RTcXVhcmUgPSBkaXN0YW5jZVNxdWFyZTtcblxuLyoqXG4gKiDmsYLotJ/lkJHph49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSAtdlswXTtcbiAgICBvdXRbMV0gPSAtdlsxXTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIOaPkuWAvOS4pOS4queCuVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgdjEsIHYyLCB0KSB7XG4gICAgb3V0WzBdID0gdjFbMF0gKyB0ICogKHYyWzBdIC0gdjFbMF0pO1xuICAgIG91dFsxXSA9IHYxWzFdICsgdCAqICh2MlsxXSAtIHYxWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIOefqemYteW3puS5mOWQkemHj1xuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHBhcmFtIHtWZWN0b3IyfSBtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShvdXQsIHYsIG0pIHtcbiAgICB2YXIgeCA9IHZbMF07XG4gICAgdmFyIHkgPSB2WzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICog5rGC5Lik5Liq5ZCR6YeP5pyA5bCP5YC8XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgdjEsIHYyKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4odjFbMF0sIHYyWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbih2MVsxXSwgdjJbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICog5rGC5Lik5Liq5ZCR6YeP5pyA5aSn5YC8XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgdjEsIHYyKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgodjFbMF0sIHYyWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heCh2MVsxXSwgdjJbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvY29yZS92ZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDmm7Lnur/ovoXliqnmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2N1cnZlXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cbmltcG9ydCB7XG4gICAgY3JlYXRlIGFzIHYyQ3JlYXRlLFxuICAgIGRpc3RTcXVhcmUgYXMgdjJEaXN0U3F1YXJlXG59IGZyb20gJy4vdmVjdG9yJztcblxudmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcblxudmFyIEVQU0lMT04gPSAxZS04O1xudmFyIEVQU0lMT05fTlVNRVJJQyA9IDFlLTQ7XG5cbnZhciBUSFJFRV9TUVJUID0gbWF0aFNxcnQoMyk7XG52YXIgT05FX1RISVJEID0gMSAvIDM7XG5cbi8vIOS4tOaXtuWPmOmHj1xudmFyIF92MCA9IHYyQ3JlYXRlKCk7XG52YXIgX3YxID0gdjJDcmVhdGUoKTtcbnZhciBfdjIgPSB2MkNyZWF0ZSgpO1xuXG5mdW5jdGlvbiBpc0Fyb3VuZFplcm8odmFsKSB7XG4gICAgcmV0dXJuIHZhbCA+IC1FUFNJTE9OICYmIHZhbCA8IEVQU0lMT047XG59XG5mdW5jdGlvbiBpc05vdEFyb3VuZFplcm8odmFsKSB7XG4gICAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOWAvFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNBdChwMCwgcDEsIHAyLCBwMywgdCkge1xuICAgIHZhciBvbmV0ID0gMSAtIHQ7XG4gICAgcmV0dXJuIG9uZXQgKiBvbmV0ICogKG9uZXQgKiBwMCArIDMgKiB0ICogcDEpXG4gICAgICAgICAgICArIHQgKiB0ICogKHQgKiBwMyArIDMgKiBvbmV0ICogcDIpO1xufVxuXG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOWvvOaVsOWAvFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICB2YXIgb25ldCA9IDEgLSB0O1xuICAgIHJldHVybiAzICogKFxuICAgICAgICAoKHAxIC0gcDApICogb25ldCArIDIgKiAocDIgLSBwMSkgKiB0KSAqIG9uZXRcbiAgICAgICAgKyAocDMgLSBwMikgKiB0ICogdFxuICAgICk7XG59XG5cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5qC577yM5L2/55So55ub6YeR5YWs5byPXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1YmljUm9vdEF0KHAwLCBwMSwgcDIsIHAzLCB2YWwsIHJvb3RzKSB7XG4gICAgLy8gRXZhbHVhdGUgcm9vdHMgb2YgY3ViaWMgZnVuY3Rpb25zXG4gICAgdmFyIGEgPSBwMyArIDMgKiAocDEgLSBwMikgLSBwMDtcbiAgICB2YXIgYiA9IDMgKiAocDIgLSBwMSAqIDIgKyBwMCk7XG4gICAgdmFyIGMgPSAzICogKHAxICAtIHAwKTtcbiAgICB2YXIgZCA9IHAwIC0gdmFsO1xuXG4gICAgdmFyIEEgPSBiICogYiAtIDMgKiBhICogYztcbiAgICB2YXIgQiA9IGIgKiBjIC0gOSAqIGEgKiBkO1xuICAgIHZhciBDID0gYyAqIGMgLSAzICogYiAqIGQ7XG5cbiAgICB2YXIgbiA9IDA7XG5cbiAgICBpZiAoaXNBcm91bmRaZXJvKEEpICYmIGlzQXJvdW5kWmVybyhCKSkge1xuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGIpKSB7XG4gICAgICAgICAgICByb290c1swXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdDEgPSAtYyAvIGI7ICAvL3QxLCB0MiwgdDMsIGIgaXMgbm90IHplcm9cbiAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBkaXNjID0gQiAqIEIgLSA0ICogQSAqIEM7XG5cbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgdmFyIEsgPSBCIC8gQTtcbiAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gYSArIEs7ICAvLyB0MSwgYSBpcyBub3QgemVyb1xuICAgICAgICAgICAgdmFyIHQyID0gLUsgLyAyOyAgLy8gdDIsIHQzXG4gICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICAgICAgICB2YXIgWTEgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgKyBkaXNjU3FydCk7XG4gICAgICAgICAgICB2YXIgWTIgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgLSBkaXNjU3FydCk7XG4gICAgICAgICAgICBpZiAoWTEgPCAwKSB7XG4gICAgICAgICAgICAgICAgWTEgPSAtbWF0aFBvdygtWTEsIE9ORV9USElSRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBZMSA9IG1hdGhQb3coWTEsIE9ORV9USElSRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoWTIgPCAwKSB7XG4gICAgICAgICAgICAgICAgWTIgPSAtbWF0aFBvdygtWTIsIE9ORV9USElSRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBZMiA9IG1hdGhQb3coWTIsIE9ORV9USElSRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdDEgPSAoLWIgLSAoWTEgKyBZMikpIC8gKDMgKiBhKTtcbiAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgVCA9ICgyICogQSAqIGIgLSAzICogYSAqIEIpIC8gKDIgKiBtYXRoU3FydChBICogQSAqIEEpKTtcbiAgICAgICAgICAgIHZhciB0aGV0YSA9IE1hdGguYWNvcyhUKSAvIDM7XG4gICAgICAgICAgICB2YXIgQVNxcnQgPSBtYXRoU3FydChBKTtcbiAgICAgICAgICAgIHZhciB0bXAgPSBNYXRoLmNvcyh0aGV0YSk7XG5cbiAgICAgICAgICAgIHZhciB0MSA9ICgtYiAtIDIgKiBBU3FydCAqIHRtcCkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgdmFyIHQyID0gKC1iICsgQVNxcnQgKiAodG1wICsgVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgICAgICAgIHZhciB0MyA9ICgtYiArIEFTcXJ0ICogKHRtcCAtIFRIUkVFX1NRUlQgKiBNYXRoLnNpbih0aGV0YSkpKSAvICgzICogYSk7XG4gICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0MyA+PSAwICYmIHQzIDw9IDEpIHtcbiAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG5cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC855qE5L2N572uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IGV4dHJlbWFcbiAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5pWw55uuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY0V4dHJlbWEocDAsIHAxLCBwMiwgcDMsIGV4dHJlbWEpIHtcbiAgICB2YXIgYiA9IDYgKiBwMiAtIDEyICogcDEgKyA2ICogcDA7XG4gICAgdmFyIGEgPSA5ICogcDEgKyAzICogcDMgLSAzICogcDAgLSA5ICogcDI7XG4gICAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG5cbiAgICB2YXIgbiA9IDA7XG4gICAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKGIpKSB7XG4gICAgICAgICAgICB2YXIgdDEgPSAtYyAvIGI7XG4gICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PTEpIHtcbiAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgZXh0cmVtYVswXSA9IC1iIC8gKDIgKiBhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICAgICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiDnu4bliIbkuInmrKHotJ3loZ7lsJTmm7Lnur9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1YmljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHAzLCB0LCBvdXQpIHtcbiAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgIHZhciBwMTIgPSAocDIgLSBwMSkgKiB0ICsgcDE7XG4gICAgdmFyIHAyMyA9IChwMyAtIHAyKSAqIHQgKyBwMjtcblxuICAgIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxO1xuICAgIHZhciBwMTIzID0gKHAyMyAtIHAxMikgKiB0ICsgcDEyO1xuXG4gICAgdmFyIHAwMTIzID0gKHAxMjMgLSBwMDEyKSAqIHQgKyBwMDEyO1xuICAgIC8vIFNlZzBcbiAgICBvdXRbMF0gPSBwMDtcbiAgICBvdXRbMV0gPSBwMDE7XG4gICAgb3V0WzJdID0gcDAxMjtcbiAgICBvdXRbM10gPSBwMDEyMztcbiAgICAvLyBTZWcxXG4gICAgb3V0WzRdID0gcDAxMjM7XG4gICAgb3V0WzVdID0gcDEyMztcbiAgICBvdXRbNl0gPSBwMjM7XG4gICAgb3V0WzddID0gcDM7XG59XG5cbi8qKlxuICog5oqV5bCE54K55Yiw5LiJ5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIOaKleWwhOeCuVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNQcm9qZWN0UG9pbnQoXG4gICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLFxuICAgIHgsIHksIG91dFxuKSB7XG4gICAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICAgIHZhciB0O1xuICAgIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICAgIHZhciBkID0gSW5maW5pdHk7XG4gICAgdmFyIHByZXY7XG4gICAgdmFyIG5leHQ7XG4gICAgdmFyIGQxO1xuICAgIHZhciBkMjtcblxuICAgIF92MFswXSA9IHg7XG4gICAgX3YwWzFdID0geTtcblxuICAgIC8vIOWFiOeyl+eVpeS8sOiuoeS4gOS4i+WPr+iDveeahOacgOWwj+i3neemu+eahCB0IOWAvFxuICAgIC8vIFBFTkRJTkdcbiAgICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgICAgICBfdjFbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBfdCk7XG4gICAgICAgIF92MVsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIF90KTtcbiAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuICAgICAgICBpZiAoZDEgPCBkKSB7XG4gICAgICAgICAgICB0ID0gX3Q7XG4gICAgICAgICAgICBkID0gZDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZCA9IEluZmluaXR5O1xuXG4gICAgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICBuZXh0ID0gdCArIGludGVydmFsO1xuICAgICAgICAvLyB0IC0gaW50ZXJ2YWxcbiAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgcHJldik7XG4gICAgICAgIF92MVsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHByZXYpO1xuXG4gICAgICAgIGQxID0gdjJEaXN0U3F1YXJlKF92MSwgX3YwKTtcblxuICAgICAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgICAgICAgdCA9IHByZXY7XG4gICAgICAgICAgICBkID0gZDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0ICsgaW50ZXJ2YWxcbiAgICAgICAgICAgIF92MlswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIG5leHQpO1xuICAgICAgICAgICAgX3YyWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgbmV4dCk7XG4gICAgICAgICAgICBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgZCA9IGQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHRcbiAgICBpZiAob3V0KSB7XG4gICAgICAgIG91dFswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgICBvdXRbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuICAgIHJldHVybiBtYXRoU3FydChkKTtcbn1cblxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlgLxcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhZHJhdGljQXQocDAsIHAxLCBwMiwgdCkge1xuICAgIHZhciBvbmV0ID0gMSAtIHQ7XG4gICAgcmV0dXJuIG9uZXQgKiAob25ldCAqIHAwICsgMiAqIHQgKiBwMSkgKyB0ICogdCAqIHAyO1xufVxuXG4vKipcbiAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOWvvOaVsOWAvFxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgdCkge1xuICAgIHJldHVybiAyICogKCgxIC0gdCkgKiAocDEgLSBwMCkgKyB0ICogKHAyIC0gcDEpKTtcbn1cblxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTmlrnnqIvmoLlcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJvb3RzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhZHJhdGljUm9vdEF0KHAwLCBwMSwgcDIsIHZhbCwgcm9vdHMpIHtcbiAgICB2YXIgYSA9IHAwIC0gMiAqIHAxICsgcDI7XG4gICAgdmFyIGIgPSAyICogKHAxIC0gcDApO1xuICAgIHZhciBjID0gcDAgLSB2YWw7XG5cbiAgICB2YXIgbiA9IDA7XG4gICAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKGIpKSB7XG4gICAgICAgICAgICB2YXIgdDEgPSAtYyAvIGI7XG4gICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICAgICAgICB2YXIgdDEgPSAtYiAvICgyICogYSk7XG4gICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICAgICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICB2YXIgdDIgPSAoLWIgLSBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG5cbi8qKlxuICog6K6h566X5LqM5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhZHJhdGljRXh0cmVtdW0ocDAsIHAxLCBwMikge1xuICAgIHZhciBkaXZpZGVyID0gcDAgKyBwMiAtIDIgKiBwMTtcbiAgICBpZiAoZGl2aWRlciA9PT0gMCkge1xuICAgICAgICAvLyBwMSBpcyBjZW50ZXIgb2YgcDAgYW5kIHAyXG4gICAgICAgIHJldHVybiAwLjU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKHAwIC0gcDEpIC8gZGl2aWRlcjtcbiAgICB9XG59XG5cbi8qKlxuICog57uG5YiG5LqM5qyh6LSd5aGe5bCU5puy57q/XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFkcmF0aWNTdWJkaXZpZGUocDAsIHAxLCBwMiwgdCwgb3V0KSB7XG4gICAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxO1xuXG4gICAgLy8gU2VnMFxuICAgIG91dFswXSA9IHAwO1xuICAgIG91dFsxXSA9IHAwMTtcbiAgICBvdXRbMl0gPSBwMDEyO1xuXG4gICAgLy8gU2VnMVxuICAgIG91dFszXSA9IHAwMTI7XG4gICAgb3V0WzRdID0gcDEyO1xuICAgIG91dFs1XSA9IHAyO1xufVxuXG4vKipcbiAqIOaKleWwhOeCueWIsOS6jOasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICog5oqV5bCE54K55pyJ5Y+v6IO95Lya5pyJ5LiA5Liq5oiW6ICF5aSa5Liq77yM6L+Z6YeM5Y+q6L+U5Zue5YW25Lit6Led56a75pyA55+t55qE5LiA5Liq44CCXG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG91dCDmipXlsITngrlcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YWRyYXRpY1Byb2plY3RQb2ludChcbiAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLFxuICAgIHgsIHksIG91dFxuKSB7XG4gICAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICAgIHZhciB0O1xuICAgIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICAgIHZhciBkID0gSW5maW5pdHk7XG5cbiAgICBfdjBbMF0gPSB4O1xuICAgIF92MFsxXSA9IHk7XG5cbiAgICAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgICAvLyBQRU5ESU5HXG4gICAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICAgICAgX3YxWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgX3QpO1xuICAgICAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBfdCk7XG4gICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG4gICAgICAgIGlmIChkMSA8IGQpIHtcbiAgICAgICAgICAgIHQgPSBfdDtcbiAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkID0gSW5maW5pdHk7XG5cbiAgICAvLyBBdCBtb3N0IDMyIGl0ZXJhdGlvblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICB2YXIgbmV4dCA9IHQgKyBpbnRlcnZhbDtcbiAgICAgICAgLy8gdCAtIGludGVydmFsXG4gICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHByZXYpO1xuICAgICAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBwcmV2KTtcblxuICAgICAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgICAgIGlmIChwcmV2ID49IDAgJiYgZDEgPCBkKSB7XG4gICAgICAgICAgICB0ID0gcHJldjtcbiAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgICAgICAgX3YyWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgbmV4dCk7XG4gICAgICAgICAgICBfdjJbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBuZXh0KTtcbiAgICAgICAgICAgIHZhciBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBuZXh0O1xuICAgICAgICAgICAgICAgIGQgPSBkMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB0XG4gICAgaWYgKG91dCkge1xuICAgICAgICBvdXRbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0KTtcbiAgICAgICAgb3V0WzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKGludGVydmFsLCBpKTtcbiAgICByZXR1cm4gbWF0aFNxcnQoZCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvY29yZS9jdXJ2ZS5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZHByID0gMTtcblxuLy8gSWYgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZHByID0gTWF0aC5tYXgod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMSk7XG59XG5cbi8qKlxuICogY29uZmln6buY6K6k6YWN572u6aG5XG4gKiBAZXhwb3J0cyB6cmVuZGVyL2NvbmZpZ1xuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiBkZWJ1Z+aXpeW/l+mAiemhue+8mmNhdGNoQnJ1c2hFeGNlcHRpb27kuLp0cnVl5LiL5pyJ5pWIXG4gKiAwIDog5LiN55Sf5oiQZGVidWfmlbDmja7vvIzlj5HluIPnlKhcbiAqIDEgOiDlvILluLjmipvlh7rvvIzosIPor5XnlKhcbiAqIDIgOiDmjqfliLblj7DovpPlh7rvvIzosIPor5XnlKhcbiAqL1xuZXhwb3J0IHZhciBkZWJ1Z01vZGUgPSAwO1xuXG4vLyByZXRpbmEg5bGP5bmV5LyY5YyWXG5leHBvcnQgdmFyIGRldmljZVBpeGVsUmF0aW8gPSBkcHI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvY29uZmlnLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogZWNoYXJ0c+iuvuWkh+eOr+Wig+ivhuWIq1xuICpcbiAqIEBkZXNjIGVjaGFydHPln7rkuo5DYW52YXPvvIznuq9KYXZhc2NyaXB05Zu+6KGo5bqT77yM5o+Q5L6b55u06KeC77yM55Sf5Yqo77yM5Y+v5Lqk5LqS77yM5Y+v5Liq5oCn5YyW5a6a5Yi255qE5pWw5o2u57uf6K6h5Zu+6KGo44CCXG4gKiBAYXV0aG9yIGZpcmVkZVtmaXJlZGVAZmlyZWRlLnVzXVxuICogQGRlc2MgdGhhbmtzIHplcHRvLlxuICovXG5cbnZhciBlbnYgPSB7fTtcblxuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gSW4gbm9kZVxuICAgIGVudiA9IHtcbiAgICAgICAgYnJvd3Nlcjoge30sXG4gICAgICAgIG9zOiB7fSxcbiAgICAgICAgbm9kZTogdHJ1ZSxcbiAgICAgICAgLy8gQXNzdW1lIGNhbnZhcyBpcyBzdXBwb3J0ZWRcbiAgICAgICAgY2FudmFzU3VwcG9ydGVkOiB0cnVlLFxuICAgICAgICBzdmdTdXBwb3J0ZWQ6IHRydWVcbiAgICB9O1xufVxuZWxzZSB7XG4gICAgZW52ID0gZGV0ZWN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlbnY7XG5cbi8vIFplcHRvLmpzXG4vLyAoYykgMjAxMC0yMDEzIFRob21hcyBGdWNoc1xuLy8gWmVwdG8uanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbmZ1bmN0aW9uIGRldGVjdCh1YSkge1xuICAgIHZhciBvcyA9IHt9O1xuICAgIHZhciBicm93c2VyID0ge307XG4gICAgLy8gdmFyIHdlYmtpdCA9IHVhLm1hdGNoKC9XZWJba0tdaXRbXFwvXXswLDF9KFtcXGQuXSspLyk7XG4gICAgLy8gdmFyIGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/Lyk7XG4gICAgLy8gdmFyIGlwYWQgPSB1YS5tYXRjaCgvKGlQYWQpLipPU1xccyhbXFxkX10rKS8pO1xuICAgIC8vIHZhciBpcG9kID0gdWEubWF0Y2goLyhpUG9kKSguKk9TXFxzKFtcXGRfXSspKT8vKTtcbiAgICAvLyB2YXIgaXBob25lID0gIWlwYWQgJiYgdWEubWF0Y2goLyhpUGhvbmVcXHNPUylcXHMoW1xcZF9dKykvKTtcbiAgICAvLyB2YXIgd2Vib3MgPSB1YS5tYXRjaCgvKHdlYk9TfGhwd09TKVtcXHNcXC9dKFtcXGQuXSspLyk7XG4gICAgLy8gdmFyIHRvdWNocGFkID0gd2Vib3MgJiYgdWEubWF0Y2goL1RvdWNoUGFkLyk7XG4gICAgLy8gdmFyIGtpbmRsZSA9IHVhLm1hdGNoKC9LaW5kbGVcXC8oW1xcZC5dKykvKTtcbiAgICAvLyB2YXIgc2lsayA9IHVhLm1hdGNoKC9TaWxrXFwvKFtcXGQuX10rKS8pO1xuICAgIC8vIHZhciBibGFja2JlcnJ5ID0gdWEubWF0Y2goLyhCbGFja0JlcnJ5KS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAgIC8vIHZhciBiYjEwID0gdWEubWF0Y2goLyhCQjEwKS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAgIC8vIHZhciByaW10YWJsZXRvcyA9IHVhLm1hdGNoKC8oUklNXFxzVGFibGV0XFxzT1MpXFxzKFtcXGQuXSspLyk7XG4gICAgLy8gdmFyIHBsYXlib29rID0gdWEubWF0Y2goL1BsYXlCb29rLyk7XG4gICAgLy8gdmFyIGNocm9tZSA9IHVhLm1hdGNoKC9DaHJvbWVcXC8oW1xcZC5dKykvKSB8fCB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKTtcbiAgICB2YXIgZmlyZWZveCA9IHVhLm1hdGNoKC9GaXJlZm94XFwvKFtcXGQuXSspLyk7XG4gICAgLy8gdmFyIHNhZmFyaSA9IHdlYmtpdCAmJiB1YS5tYXRjaCgvTW9iaWxlXFwvLykgJiYgIWNocm9tZTtcbiAgICAvLyB2YXIgd2VidmlldyA9IHVhLm1hdGNoKC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpLykgJiYgIWNocm9tZTtcbiAgICB2YXIgaWUgPSB1YS5tYXRjaCgvTVNJRVxccyhbXFxkLl0rKS8pXG4gICAgICAgIC8vIElFIDExIFRyaWRlbnQvNy4wOyBydjoxMS4wXG4gICAgICAgIHx8IHVhLm1hdGNoKC9UcmlkZW50XFwvLis/cnY6KChbXFxkLl0rKSkvKTtcbiAgICB2YXIgZWRnZSA9IHVhLm1hdGNoKC9FZGdlXFwvKFtcXGQuXSspLyk7IC8vIElFIDEyIGFuZCAxMitcblxuICAgIHZhciB3ZUNoYXQgPSAoL21pY3JvbWVzc2VuZ2VyL2kpLnRlc3QodWEpO1xuXG4gICAgLy8gVG9kbzogY2xlYW4gdGhpcyB1cCB3aXRoIGEgYmV0dGVyIE9TL2Jyb3dzZXIgc2VwZXJhdGlvbjpcbiAgICAvLyAtIGRpc2Nlcm4gKG1vcmUpIGJldHdlZW4gbXVsdGlwbGUgYnJvd3NlcnMgb24gYW5kcm9pZFxuICAgIC8vIC0gZGVjaWRlIGlmIGtpbmRsZSBmaXJlIGluIHNpbGsgbW9kZSBpcyBhbmRyb2lkIG9yIG5vdFxuICAgIC8vIC0gRmlyZWZveCBvbiBBbmRyb2lkIGRvZXNuJ3Qgc3BlY2lmeSB0aGUgQW5kcm9pZCB2ZXJzaW9uXG4gICAgLy8gLSBwb3NzaWJseSBkZXZpZGUgaW4gb3MsIGRldmljZSBhbmQgYnJvd3NlciBoYXNoZXNcblxuICAgIC8vIGlmIChicm93c2VyLndlYmtpdCA9ICEhd2Via2l0KSBicm93c2VyLnZlcnNpb24gPSB3ZWJraXRbMV07XG5cbiAgICAvLyBpZiAoYW5kcm9pZCkgb3MuYW5kcm9pZCA9IHRydWUsIG9zLnZlcnNpb24gPSBhbmRyb2lkWzJdO1xuICAgIC8vIGlmIChpcGhvbmUgJiYgIWlwb2QpIG9zLmlvcyA9IG9zLmlwaG9uZSA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGhvbmVbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgIC8vIGlmIChpcGFkKSBvcy5pb3MgPSBvcy5pcGFkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwYWRbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgIC8vIGlmIChpcG9kKSBvcy5pb3MgPSBvcy5pcG9kID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwb2RbM10gPyBpcG9kWzNdLnJlcGxhY2UoL18vZywgJy4nKSA6IG51bGw7XG4gICAgLy8gaWYgKHdlYm9zKSBvcy53ZWJvcyA9IHRydWUsIG9zLnZlcnNpb24gPSB3ZWJvc1syXTtcbiAgICAvLyBpZiAodG91Y2hwYWQpIG9zLnRvdWNocGFkID0gdHJ1ZTtcbiAgICAvLyBpZiAoYmxhY2tiZXJyeSkgb3MuYmxhY2tiZXJyeSA9IHRydWUsIG9zLnZlcnNpb24gPSBibGFja2JlcnJ5WzJdO1xuICAgIC8vIGlmIChiYjEwKSBvcy5iYjEwID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJiMTBbMl07XG4gICAgLy8gaWYgKHJpbXRhYmxldG9zKSBvcy5yaW10YWJsZXRvcyA9IHRydWUsIG9zLnZlcnNpb24gPSByaW10YWJsZXRvc1syXTtcbiAgICAvLyBpZiAocGxheWJvb2spIGJyb3dzZXIucGxheWJvb2sgPSB0cnVlO1xuICAgIC8vIGlmIChraW5kbGUpIG9zLmtpbmRsZSA9IHRydWUsIG9zLnZlcnNpb24gPSBraW5kbGVbMV07XG4gICAgLy8gaWYgKHNpbGspIGJyb3dzZXIuc2lsayA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IHNpbGtbMV07XG4gICAgLy8gaWYgKCFzaWxrICYmIG9zLmFuZHJvaWQgJiYgdWEubWF0Y2goL0tpbmRsZSBGaXJlLykpIGJyb3dzZXIuc2lsayA9IHRydWU7XG4gICAgLy8gaWYgKGNocm9tZSkgYnJvd3Nlci5jaHJvbWUgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBjaHJvbWVbMV07XG4gICAgaWYgKGZpcmVmb3gpIHtcbiAgICAgICAgYnJvd3Nlci5maXJlZm94ID0gdHJ1ZTtcbiAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gZmlyZWZveFsxXTtcbiAgICB9XG4gICAgLy8gaWYgKHNhZmFyaSAmJiAodWEubWF0Y2goL1NhZmFyaS8pIHx8ICEhb3MuaW9zKSkgYnJvd3Nlci5zYWZhcmkgPSB0cnVlO1xuICAgIC8vIGlmICh3ZWJ2aWV3KSBicm93c2VyLndlYnZpZXcgPSB0cnVlO1xuXG4gICAgaWYgKGllKSB7XG4gICAgICAgIGJyb3dzZXIuaWUgPSB0cnVlO1xuICAgICAgICBicm93c2VyLnZlcnNpb24gPSBpZVsxXTtcbiAgICB9XG5cbiAgICBpZiAoZWRnZSkge1xuICAgICAgICBicm93c2VyLmVkZ2UgPSB0cnVlO1xuICAgICAgICBicm93c2VyLnZlcnNpb24gPSBlZGdlWzFdO1xuICAgIH1cblxuICAgIC8vIEl0IGlzIGRpZmZpY3VsdCB0byBkZXRlY3QgV2VDaGF0IGluIFdpbiBQaG9uZSBwcmVjaXNlbHksIGJlY2F1c2UgdWEgY2FuXG4gICAgLy8gbm90IGJlIHNldCBvbiB3aW4gcGhvbmUuIFNvIHdlIGRvIG5vdCBjb25zaWRlciBXaW4gUGhvbmUuXG4gICAgaWYgKHdlQ2hhdCkge1xuICAgICAgICBicm93c2VyLndlQ2hhdCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gb3MudGFibGV0ID0gISEoaXBhZCB8fCBwbGF5Ym9vayB8fCAoYW5kcm9pZCAmJiAhdWEubWF0Y2goL01vYmlsZS8pKSB8fFxuICAgIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvVGFibGV0LykpIHx8IChpZSAmJiAhdWEubWF0Y2goL1Bob25lLykgJiYgdWEubWF0Y2goL1RvdWNoLykpKTtcbiAgICAvLyBvcy5waG9uZSAgPSAhISghb3MudGFibGV0ICYmICFvcy5pcG9kICYmIChhbmRyb2lkIHx8IGlwaG9uZSB8fCB3ZWJvcyB8fFxuICAgIC8vICAgICAoY2hyb21lICYmIHVhLm1hdGNoKC9BbmRyb2lkLykpIHx8IChjaHJvbWUgJiYgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLykpIHx8XG4gICAgLy8gICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9Nb2JpbGUvKSkgfHwgKGllICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICAgICAgb3M6IG9zLFxuICAgICAgICBub2RlOiBmYWxzZSxcbiAgICAgICAgLy8g5Y6f55SfY2FudmFz5pSv5oyB77yM5pS55p6B56uv54K55LqGXG4gICAgICAgIC8vIGNhbnZhc1N1cHBvcnRlZCA6ICEoYnJvd3Nlci5pZSAmJiBwYXJzZUZsb2F0KGJyb3dzZXIudmVyc2lvbikgPCA5KVxuICAgICAgICBjYW52YXNTdXBwb3J0ZWQ6ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCxcbiAgICAgICAgc3ZnU3VwcG9ydGVkOiB0eXBlb2YgU1ZHUmVjdCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgICAgIC8vIEBzZWUgPGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDgxNzAyOS93aGF0cy10aGUtYmVzdC13YXktdG8tZGV0ZWN0LWEtdG91Y2gtc2NyZWVuLWRldmljZS11c2luZy1qYXZhc2NyaXB0PlxuICAgICAgICAvLyB3b3JrcyBvbiBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIElFMTAvMTEgZG9lcyBub3Qgc3VwcG9ydCB0b3VjaCBldmVudCwgYW5kIE1TIEVkZ2Ugc3VwcG9ydHMgdGhlbSBidXQgbm90IGJ5XG4gICAgICAgIC8vIGRlZmF1bHQsIHNvIHdlIGRvbnQgY2hlY2sgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIGZvciB0aGVtIGhlcmUuXG4gICAgICAgIHRvdWNoRXZlbnRzU3VwcG9ydGVkOiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgIWJyb3dzZXIuaWUgJiYgIWJyb3dzZXIuZWRnZSxcbiAgICAgICAgLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXBvaW50ZXIlMjBldmVudD4uXG4gICAgICAgIHBvaW50ZXJFdmVudHNTdXBwb3J0ZWQ6ICdvbnBvaW50ZXJkb3duJyBpbiB3aW5kb3dcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggc3VwcG9ydHMgcG9pbnRlciBidXQgbm90IGJ5IGRlZmF1bHQsIG9ubHkgTVMgYnJvd3NlcnMgYXJlIHJlbGlhYmxlIG9uIHBvaW50ZXJcbiAgICAgICAgICAgIC8vIGV2ZW50cyBjdXJyZW50bHkuIFNvIHdlIGRvbnQgdXNlIHRoYXQgb24gb3RoZXIgYnJvd3NlcnMgdW5sZXNzIHRlc3RlZCBzdWZmaWNpZW50bHkuXG4gICAgICAgICAgICAvLyBBbHRob3VnaCBJRSAxMCBzdXBwb3J0cyBwb2ludGVyIGV2ZW50LCBpdCB1c2Ugb2xkIHN0eWxlIGFuZCBpcyBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIHN0YW5kYXJkLiBTbyB3ZSBleGNsdWRlIHRoYXQuIChJRSAxMCBpcyBoYXJkbHkgdXNlZCBvbiB0b3VjaCBkZXZpY2UpXG4gICAgICAgICAgICAmJiAoYnJvd3Nlci5lZGdlIHx8IChicm93c2VyLmllICYmIGJyb3dzZXIudmVyc2lvbiA+PSAxMSkpXG4gICAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvY29yZS9lbnYuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDkuovku7bmianlsZVcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9FdmVudGZ1bFxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG52YXIgYXJyeVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIOS6i+S7tuWIhuWPkeWZqFxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEV2ZW50ZnVsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xufTtcblxuRXZlbnRmdWwucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IEV2ZW50ZnVsLFxuXG4gICAgLyoqXG4gICAgICog5Y2V5qyh6Kem5Y+R57uR5a6a77yMdHJpZ2dlcuWQjumUgOavgVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5ZON5bqU5Ye95pWwXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICAgKi9cbiAgICBvbmU6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICAgICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgICAgICAgX2hbZXZlbnRdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9oW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9oW2V2ZW50XVtpXS5oID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICAgICAgICBoOiBoYW5kbGVyLFxuICAgICAgICAgICAgb25lOiB0cnVlLFxuICAgICAgICAgICAgY3R4OiBjb250ZXh0IHx8IHRoaXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOe7keWumuS6i+S7tlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgICAgICBpZiAoIWhhbmRsZXIgfHwgIWV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghX2hbZXZlbnRdKSB7XG4gICAgICAgICAgICBfaFtldmVudF0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2hbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9oW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICAgIGg6IGhhbmRsZXIsXG4gICAgICAgICAgICBvbmU6IGZhbHNlLFxuICAgICAgICAgICAgY3R4OiBjb250ZXh0IHx8IHRoaXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOaYr+WQpue7keWumuS6huS6i+S7tlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1NpbGVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcbiAgICAgICAgcmV0dXJuIF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDop6Pnu5Hkuovku7ZcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl8kaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChfaFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gX2hbZXZlbnRdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldWydoJ10gIT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdC5wdXNoKF9oW2V2ZW50XVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2hbZXZlbnRdID0gbmV3TGlzdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfaFtldmVudF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog5LqL5Lu25YiG5Y+RXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICAgKi9cbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fJGhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKGFyZ0xlbiA+IDMpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShfaFtpXVsnY3R4J10sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICBfaC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDluKbmnIljb250ZXh055qE5LqL5Lu25YiG5Y+RLCDmnIDlkI7kuIDkuKrlj4LmlbDmmK/kuovku7blm57osIPnmoRjb250ZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAgICovXG4gICAgdHJpZ2dlcldpdGhDb250ZXh0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fJGhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKGFyZ0xlbiA+IDQpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSwgYXJncy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdHggPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICBfaC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbi8vIOWvueixoeWPr+S7pemAmui/hyBvbnh4eHgg57uR5a6a5LqL5Lu2XG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmNsaWNrXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdmVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdXRcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW1vdmVcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXdoZWVsXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vkb3duXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V1cFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnc3RhcnRcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW5kXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2VudGVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2xlYXZlXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ292ZXJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcm9wXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRmdWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL21peGluL0V2ZW50ZnVsLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogR3JvdXDmmK/kuIDkuKrlrrnlmajvvIzlj6/ku6Xmj5LlhaXlrZDoioLngrnvvIxHcm91cOeahOWPmOaNouS5n+S8muiiq+W6lOeUqOWIsOWtkOiKgueCueS4ilxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvR3JvdXBcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnenJlbmRlci9jb250YWluZXIvR3JvdXAnKTtcbiAqICAgICB2YXIgQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuICogICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gKiAgICAgZy5wb3NpdGlvblswXSA9IDEwMDtcbiAqICAgICBnLnBvc2l0aW9uWzFdID0gMTAwO1xuICogICAgIGcuYWRkKG5ldyBDaXJjbGUoe1xuICogICAgICAgICBzdHlsZToge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwLFxuICogICAgICAgICAgICAgcjogMjAsXG4gKiAgICAgICAgIH1cbiAqICAgICB9KSk7XG4gKiAgICAgenIuYWRkKGcpO1xuICovXG5cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICcuLi9jb3JlL3V0aWwnO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vRWxlbWVudCc7XG5pbXBvcnQgQm91bmRpbmdSZWN0IGZyb20gJy4uL2NvcmUvQm91bmRpbmdSZWN0JztcblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICovXG52YXIgR3JvdXAgPSBmdW5jdGlvbiAob3B0cykge1xuXG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0cykge1xuICAgICAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXG4gICAgdGhpcy5fX3N0b3JhZ2UgPSBudWxsO1xuXG4gICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbn07XG5cbkdyb3VwLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBHcm91cCxcblxuICAgIGlzR3JvdXA6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHR5cGU6ICdncm91cCcsXG5cbiAgICAvKipcbiAgICAgKiDmiYDmnInlrZDlrZnlhYPntKDmmK/lkKblk43lupTpvKDmoIfkuovku7ZcbiAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvY29udGFpbmVyL0dyb3VwI3NpbGVudFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgc2lsZW50OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9FbGVtZW50Pn1cbiAgICAgKi9cbiAgICBjaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uc2xpY2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5oyH5a6aIGluZGV4IOeahOWEv+WtkOiKgueCuVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gaWR4XG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgKi9cbiAgICBjaGlsZEF0OiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltpZHhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDojrflj5bmjIflrprlkI3lrZfnmoTlhL/lrZDoioLngrlcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgICAqL1xuICAgIGNoaWxkT2ZOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBjaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOa3u+WKoOWtkOiKgueCueWIsOacgOWQjlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gICAgICAgICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog5re75Yqg5a2Q6IqC54K55ZyoIG5leHRTaWJsaW5nIOS5i+WJjVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IG5leHRTaWJsaW5nXG4gICAgICovXG4gICAgYWRkQmVmb3JlOiBmdW5jdGlvbiAoY2hpbGQsIG5leHRTaWJsaW5nKSB7XG4gICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXNcbiAgICAgICAgICAgICYmIG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudCA9PT0gdGhpcykge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBpZHggPSBjaGlsZHJlbi5pbmRleE9mKG5leHRTaWJsaW5nKTtcblxuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMCwgY2hpbGQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZG9BZGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQucGFyZW50KSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICBpZiAoc3RvcmFnZSAmJiBzdG9yYWdlICE9PSBjaGlsZC5fX3N0b3JhZ2UpIHtcblxuICAgICAgICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgenIgJiYgenIucmVmcmVzaCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDnp7vpmaTlrZDoioLngrlcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YoY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHN0b3JhZ2UpIHtcblxuICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHpyICYmIHpyLnJlZnJlc2goKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog56e76Zmk5omA5pyJ5a2Q6IqC54K5XG4gICAgICovXG4gICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDpgY3ljobmiYDmnInlrZDoioLngrlcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAqL1xuICAgIGVhY2hDaGlsZDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDmt7HluqbkvJjlhYjpgY3ljobmiYDmnInlrZDlrZnoioLngrlcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAqL1xuICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFkZENoaWxkcmVuVG9TdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHN0b3JhZ2UuYWRkVG9TdG9yYWdlKGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlKGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAqL1xuICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKGluY2x1ZGVDaGlsZHJlbikge1xuICAgICAgICAvLyBUT0RPIENhY2hpbmdcbiAgICAgICAgdmFyIHJlY3QgPSBudWxsO1xuICAgICAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGluY2x1ZGVDaGlsZHJlbiB8fCB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgdmFyIHRtcE1hdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmlnbm9yZSB8fCBjaGlsZC5pbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGNoaWxkLmdldExvY2FsVHJhbnNmb3JtKHRtcE1hdCk7XG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyBUaGUgYm91bmRpbmdSZWN0IGNhY2x1YXRlZCBieSB0cmFuc2Zvcm1pbmcgb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIHJlY3QgbWF5IGJlIGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgYnVuZGluZ1JlY3Qgd2hlbiByb3RhdGlvblxuICAgICAgICAgICAgLy8gaXMgdXNlZC4gKENvbnNpZGVyIGEgY2lyY2xlIHJvdGF0ZWQgYWdpbnN0IGl0cyBjZW50ZXIsIHdoZXJlXG4gICAgICAgICAgICAvLyB0aGUgYWN0dWFsIGJvdW5kaW5nUmVjdCBzaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhhdCBub3QgYmVcbiAgICAgICAgICAgIC8vIHJvdGF0ZWQuKSBCdXQgd2UgY2FuIG5vdCBmaW5kIGJldHRlciBhcHByb2FjaCB0byBjYWxjdWxhdGVcbiAgICAgICAgICAgIC8vIGFjdHVhbCBib3VuZGluZ1JlY3QgeWV0LCBjb25zaWRlcmluZyBwZXJmb3JtYW5jZS5cbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICB0bXBSZWN0LmNvcHkoY2hpbGRSZWN0KTtcbiAgICAgICAgICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QgfHwgdG1wUmVjdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHJlY3QudW5pb24odG1wUmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWN0ID0gcmVjdCB8fCBjaGlsZFJlY3QuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICByZWN0LnVuaW9uKGNoaWxkUmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3QgfHwgdG1wUmVjdDtcbiAgICB9XG59O1xuXG56clV0aWwuaW5oZXJpdHMoR3JvdXAsIEVsZW1lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBHcm91cDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvY29udGFpbmVyL0dyb3VwLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog5LqL5Lu26L6F5Yqp57G7XG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9ldmVudFxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKi9cblxuaW1wb3J0IEV2ZW50ZnVsIGZyb20gJy4uL21peGluL0V2ZW50ZnVsJztcbmltcG9ydCBlbnYgZnJvbSAnLi9lbnYnO1xuXG52YXIgaXNEb21MZXZlbDIgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpICYmICEhd2luZG93LmFkZEV2ZW50TGlzdGVuZXI7XG5cbnZhciBNT1VTRV9FVkVOVF9SRUcgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay87XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCkge1xuICAgIC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSkgZG9uJ3QgaGF2ZSBnZXRCb3VuZGluZ1JlY3RcbiAgICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID8gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7bGVmdDogMCwgdG9wOiAwfTtcbn1cblxuLy8gYGNhbGN1bGF0ZWAgaXMgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2VcbmV4cG9ydCBmdW5jdGlvbiBjbGllbnRUb0xvY2FsKGVsLCBlLCBvdXQsIGNhbGN1bGF0ZSkge1xuICAgIG91dCA9IG91dCB8fCB7fTtcblxuICAgIC8vIEFjY29yZGluZyB0byB0aGUgVzNDIFdvcmtpbmcgRHJhZnQsIG9mZnNldFggYW5kIG9mZnNldFkgc2hvdWxkIGJlIHJlbGF0aXZlXG4gICAgLy8gdG8gdGhlIHBhZGRpbmcgZWRnZSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuIFRoZSBvbmx5IGJyb3dzZXIgdXNpbmcgdGhpcyBjb252ZW50aW9uXG4gICAgLy8gaXMgSUUuIFdlYmtpdCB1c2VzIHRoZSBib3JkZXIgZWRnZSwgT3BlcmEgdXNlcyB0aGUgY29udGVudCBlZGdlLCBhbmQgRmlyZUZveCBkb2VzXG4gICAgLy8gbm90IHN1cHBvcnQgdGhlIHByb3BlcnRpZXMuXG4gICAgLy8gKHNlZSBodHRwOi8vd3d3LmphY2tsbW9vcmUuY29tL25vdGVzL21vdXNlLXBvc2l0aW9uLylcbiAgICAvLyBJbiB6ciBwYWludGVyLmRvbSwgcGFkZGluZyBlZGdlIGVxdWFscyB0byBib3JkZXIgZWRnZS5cblxuICAgIC8vIEZJWE1FXG4gICAgLy8gV2hlbiBtb3VzZW1vdmUgZXZlbnQgdHJpZ2dlcmVkIG9uIGVjIHRvb2x0aXAsIHRhcmdldCBpcyBub3QgenIgcGFpbnRlci5kb20sIGFuZFxuICAgIC8vIG9mZnNldFgvWSBpcyByZWxhdGl2ZSB0byBlLnRhcmdldCwgd2hlcmUgdGhlIGNhbGN1bGF0aW9uIG9mIHpyWC9ZIHZpYSBvZmZzZXRYL1lcbiAgICAvLyBpcyB0b28gY29tcGxleC4gU28gY3NzLXRyYW5zZnJvbSBkb250IHN1cHBvcnQgaW4gdGhpcyBjYXNlIHRlbXBvcmFyaWx5LlxuICAgIGlmIChjYWxjdWxhdGUgfHwgIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCk7XG4gICAgfVxuICAgIC8vIENhdXRpb246IEluIEZpcmVGb3gsIGxheWVyWC9sYXllclkgTW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGNsb3Nlc3QgcG9zaXRpb25lZFxuICAgIC8vIGFuY2VzdG9yIGVsZW1lbnQsIHNvIHdlIHNob3VsZCBtYWtlIHN1cmUgZWwgaXMgcG9zaXRpb25lZCAoZS5nLiwgbm90IHBvc2l0aW9uOnN0YXRpYykuXG4gICAgLy8gQlRXMSwgV2Via2l0IGRvbid0IHJldHVybiB0aGUgc2FtZSByZXN1bHRzIGFzIEZGIGluIG5vbi1zaW1wbGUgY2FzZXMgKGxpa2UgYWRkXG4gICAgLy8gem9vbS1mYWN0b3IsIG92ZXJmbG93IC8gb3BhY2l0eSBsYXllcnMsIHRyYW5zZm9ybXMgLi4uKVxuICAgIC8vIEJUVzIsIChldi5vZmZzZXRZIHx8IGV2LnBhZ2VZIC0gJChldi50YXJnZXQpLm9mZnNldCgpLnRvcCkgaXMgbm90IGNvcnJlY3QgaW4gcHJlc2VydmUtM2QuXG4gICAgLy8gPGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84NTIzI2NvbW1lbnQ6MTQ+XG4gICAgLy8gQlRXMywgSW4gZmYsIG9mZnNldFgvb2Zmc2V0WSBpcyBhbHdheXMgMC5cbiAgICBlbHNlIGlmIChlbnYuYnJvd3Nlci5maXJlZm94ICYmIGUubGF5ZXJYICE9IG51bGwgJiYgZS5sYXllclggIT09IGUub2Zmc2V0WCkge1xuICAgICAgICBvdXQuenJYID0gZS5sYXllclg7XG4gICAgICAgIG91dC56clkgPSBlLmxheWVyWTtcbiAgICB9XG4gICAgLy8gRm9yIElFNissIGNocm9tZSwgc2FmYXJpLCBvcGVyYS4gKFdoZW4gd2lsbCBmZiBzdXBwb3J0IG9mZnNldFg/KVxuICAgIGVsc2UgaWYgKGUub2Zmc2V0WCAhPSBudWxsKSB7XG4gICAgICAgIG91dC56clggPSBlLm9mZnNldFg7XG4gICAgICAgIG91dC56clkgPSBlLm9mZnNldFk7XG4gICAgfVxuICAgIC8vIEZvciBzb21lIG90aGVyIGRldmljZSwgZS5nLiwgSU9TIHNhZmFyaS5cbiAgICBlbHNlIHtcbiAgICAgICAgZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCkge1xuICAgIC8vIFRoaXMgd2VsbC1rbm93biBtZXRob2QgYmVsb3cgZG9lcyBub3Qgc3VwcG9ydCBjc3MgdHJhbnNmb3JtLlxuICAgIHZhciBib3ggPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpO1xuICAgIG91dC56clggPSBlLmNsaWVudFggLSBib3gubGVmdDtcbiAgICBvdXQuenJZID0gZS5jbGllbnRZIC0gYm94LnRvcDtcbn1cblxuLyoqXG4gKiDlpoLmnpzlrZjlnKjnrKzkuInmlrnltYzlhaXnmoTkuIDkuptkb23op6blj5HnmoTkuovku7bvvIzmiJZ0b3VjaOS6i+S7tu+8jOmcgOimgei9rOaNouS4gOS4i+S6i+S7tuWdkOaghy5cbiAqIGBjYWxjdWxhdGVgIGlzIG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZWwsIGUsIGNhbGN1bGF0ZSkge1xuXG4gICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgaWYgKGUuenJYICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50VHlwZSA9IGUudHlwZTtcbiAgICB2YXIgaXNUb3VjaCA9IGV2ZW50VHlwZSAmJiBldmVudFR5cGUuaW5kZXhPZigndG91Y2gnKSA+PSAwO1xuXG4gICAgaWYgKCFpc1RvdWNoKSB7XG4gICAgICAgIGNsaWVudFRvTG9jYWwoZWwsIGUsIGUsIGNhbGN1bGF0ZSk7XG4gICAgICAgIGUuenJEZWx0YSA9IChlLndoZWVsRGVsdGEpID8gZS53aGVlbERlbHRhIC8gMTIwIDogLShlLmRldGFpbCB8fCAwKSAvIDM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdG91Y2ggPSBldmVudFR5cGUgIT0gJ3RvdWNoZW5kJ1xuICAgICAgICAgICAgPyBlLnRhcmdldFRvdWNoZXNbMF1cbiAgICAgICAgICAgIDogZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgdG91Y2ggJiYgY2xpZW50VG9Mb2NhbChlbCwgdG91Y2gsIGUsIGNhbGN1bGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodDsgb3RoZXJ3aXNlOiAwO1xuICAgIC8vIFNlZSBqUXVlcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuICAgIC8vIElmIGUud2hpY2ggaGFzIGJlZW4gZGVmaW5lZCwgaWYgbWF5IGJlIHJlYWRvbmx5LFxuICAgIC8vIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvd2hpY2hcbiAgICB2YXIgYnV0dG9uID0gZS5idXR0b247XG4gICAgaWYgKGUud2hpY2ggPT0gbnVsbCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBNT1VTRV9FVkVOVF9SRUcudGVzdChlLnR5cGUpKSB7XG4gICAgICAgIGUud2hpY2ggPSAoYnV0dG9uICYgMSA/IDEgOiAoYnV0dG9uICYgMiA/IDMgOiAoYnV0dG9uICYgNCA/IDIgOiAwKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlcikge1xuICAgIGlmIChpc0RvbUxldmVsMikge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoaXNEb21MZXZlbDIpIHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgICB9XG59XG5cbi8qKlxuICogcHJldmVudERlZmF1bHQgYW5kIHN0b3BQcm9wYWdhdGlvbi5cbiAqIE5vdGljZTogZG8gbm90IGRvIHRoYXQgaW4genJlbmRlci4gVXBwZXIgYXBwbGljYXRpb25cbiAqIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2V2ZW50XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge0V2ZW50fSBlIDogZXZlbnTlr7nosaFcbiAqL1xuZXhwb3J0IHZhciBzdG9wID0gaXNEb21MZXZlbDJcbiAgICA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cbiAgICA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3RMZWZ0TW91c2UoZSkge1xuICAgIC8vIElmIGUud2hpY2ggaXMgdW5kZWZpbmVkLCBjb25zaWRlcmVkIGFzIGxlZnQgbW91c2UgZXZlbnQuXG4gICAgcmV0dXJuIGUud2hpY2ggPiAxO1xufVxuXG4vLyDlgZrlkJHkuIrlhbzlrrlcbmV4cG9ydCB7RXZlbnRmdWwgYXMgRGlzcGF0Y2hlcn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvY29yZS9ldmVudC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOWPr+e7mOWItueahOWbvuW9ouWfuuexu1xuICogQmFzZSBjbGFzcyBvZiBhbGwgZGlzcGxheWFibGUgZ3JhcGhpYyBvYmplY3RzXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICovXG5cblxuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJy4uL2NvcmUvdXRpbCc7XG5pbXBvcnQgU3R5bGUgZnJvbSAnLi9TdHlsZSc7XG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi9FbGVtZW50JztcbmltcG9ydCBSZWN0VGV4dCBmcm9tICcuL21peGluL1JlY3RUZXh0JztcblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dFxuICovXG5mdW5jdGlvbiBEaXNwbGF5YWJsZShvcHRzKSB7XG5cbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgIC8vIEV4dGVuZCBwcm9wZXJ0aWVzXG4gICAgZm9yICh2YXIgbmFtZSBpbiBvcHRzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG9wdHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgIG5hbWUgIT09ICdzdHlsZSdcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gb3B0c1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfVxuICAgICAqL1xuICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob3B0cy5zdHlsZSwgdGhpcyk7XG5cbiAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICAvLyBTaGFwZXMgZm9yIGNhc2NhZGUgY2xpcHBpbmcuXG4gICAgdGhpcy5fX2NsaXBQYXRocyA9IFtdO1xuXG4gICAgLy8gRklYTUUgU3RhdGVmdWwgbXVzdCBiZSBtaXhpbmVkIGFmdGVyIHN0eWxlIGlzIHNldHRlZFxuICAgIC8vIFN0YXRlZnVsLmNhbGwodGhpcywgb3B0cyk7XG59XG5cbkRpc3BsYXlhYmxlLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBEaXNwbGF5YWJsZSxcblxuICAgIHR5cGU6ICdkaXNwbGF5YWJsZScsXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5YWJsZSDmmK/lkKbkuLrohI/vvIxQYWludGVyIOS4reS8muagueaNruivpeagh+iusOWIpOaWreaYr+WQpumcgOimgeaYr+WQpumcgOimgemHjeaWsOe7mOWItlxuICAgICAqIERpcnR5IGZsYWcuIEZyb20gd2hpY2ggcGFpbnRlciB3aWxsIGRldGVybWluZSBpZiB0aGlzIGRpc3BsYXlhYmxlIG9iamVjdCBuZWVkcyBicnVzaFxuICAgICAqIEBuYW1lIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjX19kaXJ0eVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIF9fZGlydHk6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiDlm77lvaLmmK/lkKblj6/op4HvvIzkuLp0cnVl5pe25LiN57uY5Yi25Zu+5b2i77yM5L2G5piv5LuN6IO96Kem5Y+R6byg5qCH5LqL5Lu2XG4gICAgICogSWYgaWdub3JlIGRyYXdpbmcgb2YgdGhlIGRpc3BsYXlhYmxlIG9iamVjdC4gTW91c2UgZXZlbnQgd2lsbCBzdGlsbCBiZSB0cmlnZ2VyZWRcbiAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNpbnZpc2libGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGludmlzaWJsZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgejogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB6MjogMCxcblxuICAgIC8qKlxuICAgICAqIHrlsYJsZXZlbO+8jOWGs+Wumue7mOeUu+WcqOWTquWxgmNhbnZhc+S4rVxuICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3psZXZlbFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHpsZXZlbDogMCxcblxuICAgIC8qKlxuICAgICAqIOaYr+WQpuWPr+aLluaLvVxuICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZHJhZ2dhYmxlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIOaYr+WQpuato+WcqOaLluaLvVxuICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICog5piv5ZCm55u45bqU6byg5qCH5LqL5Lu2XG4gICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjc2lsZW50XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBzaWxlbnQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSWYgZW5hYmxlIGN1bGxpbmdcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGN1bGxpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogTW91c2UgY3Vyc29yIHdoZW4gaG92ZXJlZFxuICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2N1cnNvclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgY3Vyc29yOiAncG9pbnRlcicsXG5cbiAgICAvKipcbiAgICAgKiBJZiBob3ZlciBhcmVhIGlzIGJvdW5kaW5nIHJlY3RcbiAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNyZWN0SG92ZXJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHJlY3RIb3ZlcjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGhlIGVsZW1lbnQgcHJvZ3Jlc3NpdmVseSB3aGVuIHRoZSB2YWx1ZSA+PSAwLFxuICAgICAqIHVzZWZ1bGwgZm9yIGxhcmdlIGRhdGEuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBwcm9ncmVzc2l2ZTogLTEsXG5cbiAgICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgICBhZnRlckJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAgIC8qKlxuICAgICAqIOWbvuW9oue7mOWItuaWueazlVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKi9cbiAgICAvLyBJbnRlcmZhY2VcbiAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7fSxcblxuICAgIC8qKlxuICAgICAqIOiOt+WPluacgOWwj+WMheWbtOebklxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAqL1xuICAgIC8vIEludGVyZmFjZVxuICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge30sXG5cbiAgICAvKipcbiAgICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLkuIpcbiAgICAgKiBJZiBkaXNwbGF5YWJsZSBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdENvbnRhaW4oeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAgICovXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLnmoTljIXlm7Tnm5LkuIpcbiAgICAgKiBJZiBib3VuZGluZyByZWN0IG9mIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICByZWN0Q29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGNvb3JkID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgcmV0dXJuIHJlY3QuY29udGFpbihjb29yZFswXSwgY29vcmRbMV0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDmoIforrDlm77lvaLlhYPntKDkuLrohI/vvIzlubbkuJTlnKjkuIvkuIDluKfph43nu5hcbiAgICAgKiBNYXJrIGRpc3BsYXlhYmxlIGVsZW1lbnQgZGlydHkgYW5kIHJlZnJlc2ggbmV4dCBmcmFtZVxuICAgICAqL1xuICAgIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOWbvuW9ouaYr+WQpuS8muinpuWPkeS6i+S7tlxuICAgICAqIElmIGRpc3BsYXlhYmxlIG9iamVjdCBiaW5kZWQgYW55IGV2ZW50XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICAvLyBUT0RPLCDpgJrov4cgYmluZCDnu5HlrprnmoTkuovku7ZcbiAgICAvLyBpc1NpbGVudDogZnVuY3Rpb24gKCkge1xuICAgIC8vICAgICByZXR1cm4gIShcbiAgICAvLyAgICAgICAgIHRoaXMuaG92ZXJhYmxlIHx8IHRoaXMuZHJhZ2dhYmxlXG4gICAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vtb3ZlIHx8IHRoaXMub25tb3VzZW92ZXIgfHwgdGhpcy5vbm1vdXNlb3V0XG4gICAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vkb3duIHx8IHRoaXMub25tb3VzZXVwIHx8IHRoaXMub25jbGlja1xuICAgIC8vICAgICAgICAgfHwgdGhpcy5vbmRyYWdlbnRlciB8fCB0aGlzLm9uZHJhZ292ZXIgfHwgdGhpcy5vbmRyYWdsZWF2ZVxuICAgIC8vICAgICAgICAgfHwgdGhpcy5vbmRyb3BcbiAgICAvLyAgICAgKTtcbiAgICAvLyB9LFxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBhbmltYXRlKCdzdHlsZScpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAgICovXG4gICAgYW5pbWF0ZVN0eWxlOiBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzdHlsZScsIGxvb3ApO1xuICAgIH0sXG5cbiAgICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgIT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIEVsZW1lbnQucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFN0eWxlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0eWxlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2UgZ2l2ZW4gc3R5bGUgb2JqZWN0XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAgICAgKi9cbiAgICB1c2VTdHlsZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9iaiwgdGhpcyk7XG4gICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG56clV0aWwuaW5oZXJpdHMoRGlzcGxheWFibGUsIEVsZW1lbnQpO1xuXG56clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFJlY3RUZXh0KTtcbi8vIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgU3RhdGVmdWwpO1xuXG5leHBvcnQgZGVmYXVsdCBEaXNwbGF5YWJsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbmltcG9ydCBMUlUgZnJvbSAnLi4vLi4vY29yZS9MUlUnO1xuXG52YXIgZ2xvYmFsSW1hZ2VDYWNoZSA9IG5ldyBMUlUoNTApO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBuZXdJbWFnZU9yU3JjXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gaW1hZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFeGlzdEltYWdlKG5ld0ltYWdlT3JTcmMpIHtcbiAgICBpZiAodHlwZW9mIG5ld0ltYWdlT3JTcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBjYWNoZWRJbWdPYmogPSBnbG9iYWxJbWFnZUNhY2hlLmdldChuZXdJbWFnZU9yU3JjKTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEltZ09iaiAmJiBjYWNoZWRJbWdPYmouaW1hZ2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3SW1hZ2VPclNyYztcbiAgICB9XG59XG5cbi8qKlxuICogQ2F1dGlvbjogVXNlciBzaG91bGQgY2FjaGUgbG9hZGVkIGltYWdlcywgYnV0IG5vdCBqdXN0IGNvdW50IG9uIExSVS5cbiAqIENvbnNpZGVyIGlmIHJlcXVpcmVkIGltYWdlcyBtb3JlIHRoYW4gTFJVIHNpemUsIHdpbGwgZGVhZCBsb29wIG9jY3VyP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBuZXdJbWFnZU9yU3JjXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZSBFeGlzdGVudCBpbWFnZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gW2hvc3RFbF0gRm9yIGNhbGxpbmcgYGRpcnR5YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gcGFyYW1zOiAoaW1hZ2UsIGNiUGF5bG9hZClcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY2JQYXlsb2FkXSBQYXlsb2FkIG9uIGNiIGNhbGxpbmcuXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gaW1hZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlSW1hZ2UobmV3SW1hZ2VPclNyYywgaW1hZ2UsIGhvc3RFbCwgY2IsIGNiUGF5bG9hZCkge1xuICAgIGlmICghbmV3SW1hZ2VPclNyYykge1xuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBuZXdJbWFnZU9yU3JjID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgIC8vIEltYWdlIHNob3VsZCBub3QgYmUgbG9hZGVkIHJlcGVhdGx5LlxuICAgICAgICBpZiAoKGltYWdlICYmIGltYWdlLl9fenJJbWFnZVNyYyA9PT0gbmV3SW1hZ2VPclNyYykgfHwgIWhvc3RFbCkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSB3aGVuIHRoZXJlIGlzIG5vIGV4aXN0ZW50IGltYWdlIG9yIGV4aXN0ZW50IGltYWdlIHNyY1xuICAgICAgICAvLyBpcyBkaWZmZXJlbnQsIHRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkLlxuICAgICAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQobmV3SW1hZ2VPclNyYyk7XG5cbiAgICAgICAgdmFyIHBlbmRpbmdXcmFwID0ge2hvc3RFbDogaG9zdEVsLCBjYjogY2IsIGNiUGF5bG9hZDogY2JQYXlsb2FkfTtcblxuICAgICAgICBpZiAoY2FjaGVkSW1nT2JqKSB7XG4gICAgICAgICAgICBpbWFnZSA9IGNhY2hlZEltZ09iai5pbWFnZTtcbiAgICAgICAgICAgICFpc0ltYWdlUmVhZHkoaW1hZ2UpICYmIGNhY2hlZEltZ09iai5wZW5kaW5nLnB1c2gocGVuZGluZ1dyYXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgIWltYWdlICYmIChpbWFnZSA9IG5ldyBJbWFnZSgpKTtcbiAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlT25Mb2FkO1xuXG4gICAgICAgICAgICBnbG9iYWxJbWFnZUNhY2hlLnB1dChcbiAgICAgICAgICAgICAgICBuZXdJbWFnZU9yU3JjLFxuICAgICAgICAgICAgICAgIGltYWdlLl9fY2FjaGVkSW1nT2JqID0ge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmc6IFtwZW5kaW5nV3JhcF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpbWFnZS5zcmMgPSBpbWFnZS5fX3pySW1hZ2VTcmMgPSBuZXdJbWFnZU9yU3JjO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH1cbiAgICAvLyBuZXdJbWFnZU9yU3JjIGlzIGFuIEhUTUxJbWFnZUVsZW1lbnQgb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzXG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXdJbWFnZU9yU3JjO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW1hZ2VPbkxvYWQoKSB7XG4gICAgdmFyIGNhY2hlZEltZ09iaiA9IHRoaXMuX19jYWNoZWRJbWdPYmo7XG4gICAgdGhpcy5vbmxvYWQgPSB0aGlzLl9fY2FjaGVkSW1nT2JqID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVkSW1nT2JqLnBlbmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBlbmRpbmdXcmFwID0gY2FjaGVkSW1nT2JqLnBlbmRpbmdbaV07XG4gICAgICAgIHZhciBjYiA9IHBlbmRpbmdXcmFwLmNiO1xuICAgICAgICBjYiAmJiBjYih0aGlzLCBwZW5kaW5nV3JhcC5jYlBheWxvYWQpO1xuICAgICAgICBwZW5kaW5nV3JhcC5ob3N0RWwuZGlydHkoKTtcbiAgICB9XG4gICAgY2FjaGVkSW1nT2JqLnBlbmRpbmcubGVuZ3RoID0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW1hZ2VSZWFkeShpbWFnZSkge1xuICAgIHJldHVybiBpbWFnZSAmJiBpbWFnZS53aWR0aCAmJiBpbWFnZS5oZWlnaHQ7XG59XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9ncmFwaGljL2hlbHBlci9pbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IENpcmNsZSBmcm9tIFwienJlbmRlci9zcmMvZ3JhcGhpYy9zaGFwZS9DaXJjbGVcIjtcclxuXHJcbmZ1bmN0aW9uIFBvaW50KG1vZGVsKXtcclxuICAgIENpcmNsZS5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5zaGFwZS5yID0gNTtcclxuICAgIHRoaXMuc2hhcGUuY3ggPSBtb2RlbC54O1xyXG4gICAgdGhpcy5zaGFwZS5jeSA9IG1vZGVsLnk7XHJcbiAgICB0aGlzLmRyYWdnYWJsZSA9IHRydWU7XHJcbiAgICB0aGlzLm9uZHJhZ2VuZCA9IChldnQpID0+IHtcclxuICAgICAgICBtb2RlbC54ID0gZXZ0Lm9mZnNldFg7XHJcbiAgICAgICAgbW9kZWwueSA9IGV2dC5vZmZzZXRZO1xyXG4gICAgICAgIHRoaXMucGFyZW50LmNyb3NzKCk7XHJcbiAgICB9O1xyXG59XHJcblBvaW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2lyY2xlLnByb3RvdHlwZSk7XHJcblxyXG5leHBvcnQge1BvaW50fVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Qb2ludC5qcyIsImltcG9ydCBndWlkIGZyb20gJy4vY29yZS9ndWlkJztcbmltcG9ydCBFdmVudGZ1bCBmcm9tICcuL21peGluL0V2ZW50ZnVsJztcbmltcG9ydCBUcmFuc2Zvcm1hYmxlIGZyb20gJy4vbWl4aW4vVHJhbnNmb3JtYWJsZSc7XG5pbXBvcnQgQW5pbWF0YWJsZSBmcm9tICcuL21peGluL0FuaW1hdGFibGUnO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJy4vY29yZS91dGlsJztcblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZX1cbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfVxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsfVxuICovXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRzKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgVHJhbnNmb3JtYWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIEV2ZW50ZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gICAgQW5pbWF0YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgLyoqXG4gICAgICog55S75biD5YWD57SgSURcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBvcHRzLmlkIHx8IGd1aWQoKTtcbn07XG5cbkVsZW1lbnQucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICog5YWD57Sg57G75Z6LXG4gICAgICogRWxlbWVudCB0eXBlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0eXBlOiAnZWxlbWVudCcsXG5cbiAgICAvKipcbiAgICAgKiDlhYPntKDlkI3lrZdcbiAgICAgKiBFbGVtZW50IG5hbWVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIG5hbWU6ICcnLFxuXG4gICAgLyoqXG4gICAgICogWlJlbmRlciDlrp7kvovlr7nosaHvvIzkvJrlnKggZWxlbWVudCDmt7vliqDliLAgenJlbmRlciDlrp7kvovkuK3lkI7oh6rliqjotYvlgLxcbiAgICAgKiBaUmVuZGVyIGluc3RhbmNlIHdpbGwgYmUgYXNzaWduZWQgd2hlbiBlbGVtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB6cmVuZGVyXG4gICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL0VsZW1lbnQjX196clxuICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgICAqL1xuICAgIF9fenI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiDlm77lvaLmmK/lkKblv73nlaXvvIzkuLp0cnVl5pe25b+955Wl5Zu+5b2i55qE57uY5Yi25Lul5Y+K5LqL5Lu26Kem5Y+RXG4gICAgICogSWYgaWdub3JlIGRyYXdpbmcgYW5kIGV2ZW50cyBvZiB0aGUgZWxlbWVudCBvYmplY3RcbiAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNpZ25vcmVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGlnbm9yZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiDnlKjkuo7oo4HliarnmoTot6/lvoQoc2hhcGUp77yM5omA5pyJIEdyb3VwIOWGheeahOi3r+W+hOWcqOe7mOWItuaXtumDveS8muiiq+i/meS4qui3r+W+hOijgeWJqlxuICAgICAqIOivpei3r+W+hOS8mue7p+aJv+iiq+ijgeWHj+WvueixoeeahOWPmOaNolxuICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9XG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvI2NsaXBwaW5nLXJlZ2lvblxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIGNsaXBQYXRoOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRHJpZnQgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gZHggZHggb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gZHkgZHkgb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgICAqL1xuICAgIGRyaWZ0OiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgICAgICAgICBkeCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBtWzRdICs9IGR4O1xuICAgICAgICBtWzVdICs9IGR5O1xuXG4gICAgICAgIHRoaXMuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIb29rIGJlZm9yZSB1cGRhdGVcbiAgICAgKi9cbiAgICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgIC8qKlxuICAgICAqIEhvb2sgYWZ0ZXIgdXBkYXRlXG4gICAgICovXG4gICAgYWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBlYWNoIGZyYW1lXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAgICovXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoa2V5ID09PSAncG9zaXRpb24nIHx8IGtleSA9PT0gJ3NjYWxlJyB8fCBrZXkgPT09ICdvcmlnaW4nKSB7XG4gICAgICAgICAgICAvLyBDb3B5IHRoZSBhcnJheVxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0WzBdID0gdmFsdWVbMF07XG4gICAgICAgICAgICAgICAgdGFyZ2V0WzFdID0gdmFsdWVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBlbGVtZW50XG4gICAgICovXG4gICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlnbm9yZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBlbGVtZW50XG4gICAgICovXG4gICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlnbm9yZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgYXR0cjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJLVihrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cktWKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBjbGlwUGF0aFxuICAgICAqL1xuICAgIHNldENsaXBQYXRoOiBmdW5jdGlvbiAoY2xpcFBhdGgpIHtcbiAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgIGNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjbGlwIHBhdGhcbiAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGggJiYgdGhpcy5jbGlwUGF0aCAhPT0gY2xpcFBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xpcFBhdGggPSBjbGlwUGF0aDtcbiAgICAgICAgY2xpcFBhdGguX196ciA9IHpyO1xuICAgICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKi9cbiAgICByZW1vdmVDbGlwUGF0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aC5fX3pyKSB7XG4gICAgICAgICAgICAgICAgY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acihjbGlwUGF0aC5fX3pyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xpcFBhdGguX196ciA9IG51bGw7XG4gICAgICAgICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jbGlwUGF0aCA9IG51bGw7XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgICAqL1xuICAgIGFkZFNlbGZUb1pyOiBmdW5jdGlvbiAoenIpIHtcbiAgICAgICAgdGhpcy5fX3pyID0genI7XG4gICAgICAgIC8vIOa3u+WKoOWKqOeUu1xuICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG4gICAgICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICAgICAgdGhpcy5jbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAgICovXG4gICAgcmVtb3ZlU2VsZkZyb21acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgICAgIHRoaXMuX196ciA9IG51bGw7XG4gICAgICAgIC8vIOenu+mZpOWKqOeUu1xuICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG4gICAgICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgenIuYW5pbWF0aW9uLnJlbW92ZUFuaW1hdG9yKGFuaW1hdG9yc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICAgICAgdGhpcy5jbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKHpyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnpyVXRpbC5taXhpbihFbGVtZW50LCBBbmltYXRhYmxlKTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBUcmFuc2Zvcm1hYmxlKTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBFdmVudGZ1bCk7XG5cbmV4cG9ydCBkZWZhdWx0IEVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL0VsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2FuaW1hdGlvbi9BbmltYXRvclxuICovXG5cbmltcG9ydCBDbGlwIGZyb20gJy4vQ2xpcCc7XG5pbXBvcnQgKiBhcyBjb2xvciBmcm9tICcuLi90b29sL2NvbG9yJztcbmltcG9ydCB7aXNBcnJheUxpa2V9IGZyb20gJy4uL2NvcmUvdXRpbCc7XG5cbnZhciBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBkZWZhdWx0R2V0dGVyKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIHRhcmdldFtrZXldO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U2V0dGVyKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKHAwLCBwMSwgcGVyY2VudCkge1xuICAgIHJldHVybiAocDEgLSBwMCkgKiBwZXJjZW50ICsgcDA7XG59XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBwMFxuICogQHBhcmFtICB7c3RyaW5nfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlU3RyaW5nKHAwLCBwMSwgcGVyY2VudCkge1xuICAgIHJldHVybiBwZXJjZW50ID4gMC41ID8gcDEgOiBwMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAqIEBwYXJhbSAge0FycmF5fSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcGVyY2VudCwgb3V0LCBhcnJEaW0pIHtcbiAgICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuICAgIGlmIChhcnJEaW0gPT0gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBpbnRlcnBvbGF0ZU51bWJlcihwMFtpXSwgcDFbaV0sIHBlcmNlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbGVuMiA9IGxlbiAmJiBwMFswXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldW2pdID0gaW50ZXJwb2xhdGVOdW1iZXIoXG4gICAgICAgICAgICAgICAgICAgIHAwW2ldW2pdLCBwMVtpXVtqXSwgcGVyY2VudFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGFycjAgaXMgc291cmNlIGFycmF5LCBhcnIxIGlzIHRhcmdldCBhcnJheS5cbi8vIERvIHNvbWUgcHJlcHJvY2VzcyB0byBhdm9pZCBlcnJvciBoYXBwZW5lZCB3aGVuIGludGVycG9sYXRpbmcgZnJvbSBhcnIwIHRvIGFycjFcbmZ1bmN0aW9uIGZpbGxBcnIoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gICAgdmFyIGFycjBMZW4gPSBhcnIwLmxlbmd0aDtcbiAgICB2YXIgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuICAgIGlmIChhcnIwTGVuICE9PSBhcnIxTGVuKSB7XG4gICAgICAgIC8vIEZJWE1FIE5vdCB3b3JrIGZvciBUeXBlZEFycmF5XG4gICAgICAgIHZhciBpc1ByZXZpb3VzTGFyZ2VyID0gYXJyMExlbiA+IGFycjFMZW47XG4gICAgICAgIGlmIChpc1ByZXZpb3VzTGFyZ2VyKSB7XG4gICAgICAgICAgICAvLyBDdXQgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICBhcnIwLmxlbmd0aCA9IGFycjFMZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGaWxsIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFycjBMZW47IGkgPCBhcnIxTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnIwLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGFyckRpbSA9PT0gMSA/IGFycjFbaV0gOiBhcnJheVNsaWNlLmNhbGwoYXJyMVtpXSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhhbmRsaW5nIE5hTiB2YWx1ZVxuICAgIHZhciBsZW4yID0gYXJyMFswXSAmJiBhcnIwWzBdLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycjAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyckRpbSA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGlzTmFOKGFycjBbaV0pKSB7XG4gICAgICAgICAgICAgICAgYXJyMFtpXSA9IGFycjFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihhcnIwW2ldW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICBhcnIwW2ldW2pdID0gYXJyMVtpXVtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtICB7QXJyYXl9IGFycjBcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNBcnJheVNhbWUoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gICAgaWYgKGFycjAgPT09IGFycjEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBsZW4gPSBhcnIwLmxlbmd0aDtcbiAgICBpZiAobGVuICE9PSBhcnIxLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGFycjBbaV0gIT09IGFycjFbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBsZW4yID0gYXJyMFswXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycjBbaV1bal0gIT09IGFycjFbaV1bal0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBhcnJheVxuICogQHBhcmFtICB7QXJyYXl9IHAwXG4gKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAqIEBwYXJhbSAge0FycmF5fSBwMlxuICogQHBhcmFtICB7QXJyYXl9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKi9cbmZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMsIG91dCwgYXJyRGltXG4pIHtcbiAgICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuICAgIGlmIChhcnJEaW0gPT0gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUoXG4gICAgICAgICAgICAgICAgcDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQsIHQyLCB0M1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGxlbjIgPSBwMFswXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldW2pdID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICBwMFtpXVtqXSwgcDFbaV1bal0sIHAyW2ldW2pdLCBwM1tpXVtqXSxcbiAgICAgICAgICAgICAgICAgICAgdCwgdDIsIHQzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBudW1iZXJcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gICAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0M1xuICAgICAgICAgICAgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MlxuICAgICAgICAgICAgKyB2MCAqIHQgKyBwMTtcbn1cblxuZnVuY3Rpb24gY2xvbmVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlWzBdKSkge1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGFycmF5U2xpY2UuY2FsbCh2YWx1ZVtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJheVNsaWNlLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmdiYTJTdHJpbmcocmdiYSkge1xuICAgIHJnYmFbMF0gPSBNYXRoLmZsb29yKHJnYmFbMF0pO1xuICAgIHJnYmFbMV0gPSBNYXRoLmZsb29yKHJnYmFbMV0pO1xuICAgIHJnYmFbMl0gPSBNYXRoLmZsb29yKHJnYmFbMl0pO1xuXG4gICAgcmV0dXJuICdyZ2JhKCcgKyByZ2JhLmpvaW4oJywnKSArICcpJztcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlEaW0oa2V5ZnJhbWVzKSB7XG4gICAgdmFyIGxhc3RWYWx1ZSA9IGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMV0udmFsdWU7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKGxhc3RWYWx1ZSAmJiBsYXN0VmFsdWVbMF0pID8gMiA6IDE7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYWNrQ2xpcChhbmltYXRvciwgZWFzaW5nLCBvbmVUcmFja0RvbmUsIGtleWZyYW1lcywgcHJvcE5hbWUsIGZvcmNlQW5pbWF0ZSkge1xuICAgIHZhciBnZXR0ZXIgPSBhbmltYXRvci5fZ2V0dGVyO1xuICAgIHZhciBzZXR0ZXIgPSBhbmltYXRvci5fc2V0dGVyO1xuICAgIHZhciB1c2VTcGxpbmUgPSBlYXNpbmcgPT09ICdzcGxpbmUnO1xuXG4gICAgdmFyIHRyYWNrTGVuID0ga2V5ZnJhbWVzLmxlbmd0aDtcbiAgICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gR3Vlc3MgZGF0YSB0eXBlXG4gICAgdmFyIGZpcnN0VmFsID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICAgIHZhciBpc1ZhbHVlQXJyYXkgPSBpc0FycmF5TGlrZShmaXJzdFZhbCk7XG4gICAgdmFyIGlzVmFsdWVDb2xvciA9IGZhbHNlO1xuICAgIHZhciBpc1ZhbHVlU3RyaW5nID0gZmFsc2U7XG5cbiAgICAvLyBGb3IgdmVydGljZXMgbW9ycGhpbmdcbiAgICB2YXIgYXJyRGltID0gaXNWYWx1ZUFycmF5ID8gZ2V0QXJyYXlEaW0oa2V5ZnJhbWVzKSA6IDA7XG5cbiAgICB2YXIgdHJhY2tNYXhUaW1lO1xuICAgIC8vIFNvcnQga2V5ZnJhbWUgYXMgYXNjZW5kaW5nXG4gICAga2V5ZnJhbWVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICAgIH0pO1xuXG4gICAgdHJhY2tNYXhUaW1lID0ga2V5ZnJhbWVzW3RyYWNrTGVuIC0gMV0udGltZTtcbiAgICAvLyBQZXJjZW50cyBvZiBlYWNoIGtleWZyYW1lXG4gICAgdmFyIGtmUGVyY2VudHMgPSBbXTtcbiAgICAvLyBWYWx1ZSBvZiBlYWNoIGtleWZyYW1lXG4gICAgdmFyIGtmVmFsdWVzID0gW107XG4gICAgdmFyIHByZXZWYWx1ZSA9IGtleWZyYW1lc1swXS52YWx1ZTtcbiAgICB2YXIgaXNBbGxWYWx1ZUVxdWFsID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuOyBpKyspIHtcbiAgICAgICAga2ZQZXJjZW50cy5wdXNoKGtleWZyYW1lc1tpXS50aW1lIC8gdHJhY2tNYXhUaW1lKTtcbiAgICAgICAgLy8gQXNzdW1lIHZhbHVlIGlzIGEgY29sb3Igd2hlbiBpdCBpcyBhIHN0cmluZ1xuICAgICAgICB2YXIgdmFsdWUgPSBrZXlmcmFtZXNbaV0udmFsdWU7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgZXF1YWwsIGRlZXAgY2hlY2sgaWYgdmFsdWUgaXMgYXJyYXlcbiAgICAgICAgaWYgKCEoKGlzVmFsdWVBcnJheSAmJiBpc0FycmF5U2FtZSh2YWx1ZSwgcHJldlZhbHVlLCBhcnJEaW0pKVxuICAgICAgICAgICAgfHwgKCFpc1ZhbHVlQXJyYXkgJiYgdmFsdWUgPT09IHByZXZWYWx1ZSkpKSB7XG4gICAgICAgICAgICBpc0FsbFZhbHVlRXF1YWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBUcnkgY29udmVydGluZyBhIHN0cmluZyB0byBhIGNvbG9yIGFycmF5XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBjb2xvckFycmF5ID0gY29sb3IucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvbG9yQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbG9yQXJyYXk7XG4gICAgICAgICAgICAgICAgaXNWYWx1ZUNvbG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzVmFsdWVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtmVmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIWZvcmNlQW5pbWF0ZSAmJiBpc0FsbFZhbHVlRXF1YWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsYXN0VmFsdWUgPSBrZlZhbHVlc1t0cmFja0xlbiAtIDFdO1xuICAgIC8vIFBvbHlmaWxsIGFycmF5IGFuZCBOYU4gdmFsdWVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgIGZpbGxBcnIoa2ZWYWx1ZXNbaV0sIGxhc3RWYWx1ZSwgYXJyRGltKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc05hTihrZlZhbHVlc1tpXSkgJiYgIWlzTmFOKGxhc3RWYWx1ZSkgJiYgIWlzVmFsdWVTdHJpbmcgJiYgIWlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgIGtmVmFsdWVzW2ldID0gbGFzdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlzVmFsdWVBcnJheSAmJiBmaWxsQXJyKGdldHRlcihhbmltYXRvci5fdGFyZ2V0LCBwcm9wTmFtZSksIGxhc3RWYWx1ZSwgYXJyRGltKTtcblxuICAgIC8vIENhY2hlIHRoZSBrZXkgb2YgbGFzdCBmcmFtZSB0byBzcGVlZCB1cCB3aGVuXG4gICAgLy8gYW5pbWF0aW9uIHBsYXliYWNrIGlzIHNlcXVlbmN5XG4gICAgdmFyIGxhc3RGcmFtZSA9IDA7XG4gICAgdmFyIGxhc3RGcmFtZVBlcmNlbnQgPSAwO1xuICAgIHZhciBzdGFydDtcbiAgICB2YXIgdztcbiAgICB2YXIgcDA7XG4gICAgdmFyIHAxO1xuICAgIHZhciBwMjtcbiAgICB2YXIgcDM7XG5cbiAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgIHZhciByZ2JhID0gWzAsIDAsIDAsIDBdO1xuICAgIH1cblxuICAgIHZhciBvbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgICAgICAvLyBGaW5kIHRoZSByYW5nZSBrZXlmcmFtZXNcbiAgICAgICAgLy8ga2YxLS0tLS1rZjItLS0tLS0tLS1jdXJyZW50LS0tLS0tLS1rZjNcbiAgICAgICAgLy8gZmluZCBrZjIgYW5kIGtmMyBhbmQgZG8gaW50ZXJwb2xhdGlvblxuICAgICAgICB2YXIgZnJhbWU7XG4gICAgICAgIC8vIEluIHRoZSBlYXNpbmcgZnVuY3Rpb24gbGlrZSBlbGFzdGljT3V0LCBwZXJjZW50IG1heSBsZXNzIHRoYW4gMFxuICAgICAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgIGZyYW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwZXJjZW50IDwgbGFzdEZyYW1lUGVyY2VudCkge1xuICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSBuZXh0IGtleVxuICAgICAgICAgICAgLy8gUEVORElORyBzdGFydCBmcm9tIGxhc3RGcmFtZSA/XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWluKGxhc3RGcmFtZSArIDEsIHRyYWNrTGVuIC0gMSk7XG4gICAgICAgICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2ZQZXJjZW50c1tmcmFtZV0gPD0gcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQRU5ESU5HIHJlYWxseSBuZWVkIHRvIGRvIHRoaXMgP1xuICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSwgdHJhY2tMZW4gLSAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgdHJhY2tMZW47IGZyYW1lKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoa2ZQZXJjZW50c1tmcmFtZV0gPiBwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUgLSAxLCB0cmFja0xlbiAtIDIpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RGcmFtZSA9IGZyYW1lO1xuICAgICAgICBsYXN0RnJhbWVQZXJjZW50ID0gcGVyY2VudDtcblxuICAgICAgICB2YXIgcmFuZ2UgPSAoa2ZQZXJjZW50c1tmcmFtZSArIDFdIC0ga2ZQZXJjZW50c1tmcmFtZV0pO1xuICAgICAgICBpZiAocmFuZ2UgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHcgPSAocGVyY2VudCAtIGtmUGVyY2VudHNbZnJhbWVdKSAvIHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VTcGxpbmUpIHtcbiAgICAgICAgICAgIHAxID0ga2ZWYWx1ZXNbZnJhbWVdO1xuICAgICAgICAgICAgcDAgPSBrZlZhbHVlc1tmcmFtZSA9PT0gMCA/IGZyYW1lIDogZnJhbWUgLSAxXTtcbiAgICAgICAgICAgIHAyID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDIgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDFdO1xuICAgICAgICAgICAgcDMgPSBrZlZhbHVlc1tmcmFtZSA+IHRyYWNrTGVuIC0gMyA/IHRyYWNrTGVuIC0gMSA6IGZyYW1lICsgMl07XG4gICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgIHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3LFxuICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgIGFyckRpbVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZ2JhLCAxXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcocDEsIHAyLCB3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAga2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3LFxuICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgIGFyckRpbVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAga2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmdiYSwgMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJnYmEyU3RyaW5nKHJnYmEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldHRlcihcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjbGlwID0gbmV3IENsaXAoe1xuICAgICAgICB0YXJnZXQ6IGFuaW1hdG9yLl90YXJnZXQsXG4gICAgICAgIGxpZmU6IHRyYWNrTWF4VGltZSxcbiAgICAgICAgbG9vcDogYW5pbWF0b3IuX2xvb3AsXG4gICAgICAgIGRlbGF5OiBhbmltYXRvci5fZGVsYXksXG4gICAgICAgIG9uZnJhbWU6IG9uZnJhbWUsXG4gICAgICAgIG9uZGVzdHJveTogb25lVHJhY2tEb25lXG4gICAgfSk7XG5cbiAgICBpZiAoZWFzaW5nICYmIGVhc2luZyAhPT0gJ3NwbGluZScpIHtcbiAgICAgICAgY2xpcC5lYXNpbmcgPSBlYXNpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXA7XG59XG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyXG4gKi9cbnZhciBBbmltYXRvciA9IGZ1bmN0aW9uKHRhcmdldCwgbG9vcCwgZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgICB0aGlzLl90cmFja3MgPSB7fTtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICB0aGlzLl9sb29wID0gbG9vcCB8fCBmYWxzZTtcblxuICAgIHRoaXMuX2dldHRlciA9IGdldHRlciB8fCBkZWZhdWx0R2V0dGVyO1xuICAgIHRoaXMuX3NldHRlciA9IHNldHRlciB8fCBkZWZhdWx0U2V0dGVyO1xuXG4gICAgdGhpcy5fY2xpcENvdW50ID0gMDtcblxuICAgIHRoaXMuX2RlbGF5ID0gMDtcblxuICAgIHRoaXMuX2RvbmVMaXN0ID0gW107XG5cbiAgICB0aGlzLl9vbmZyYW1lTGlzdCA9IFtdO1xuXG4gICAgdGhpcy5fY2xpcExpc3QgPSBbXTtcbn07XG5cbkFuaW1hdG9yLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiDorr7nva7liqjnlLvlhbPplK7luKdcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWUg5YWz6ZSu5bin5pe26Ze077yM5Y2V5L2N5pivbXNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzIOWFs+mUruW4p+eahOWxnuaAp+WAvO+8jGtleS12YWx1ZeihqOekulxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgKi9cbiAgICB3aGVuOiBmdW5jdGlvbih0aW1lIC8qIG1zICovLCBwcm9wcykge1xuICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzO1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0cmFja3NbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIEludmFsaWQgdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXR0ZXIodGhpcy5fdGFyZ2V0LCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8genJMb2coJ0ludmFsaWQgcHJvcGVydHkgJyArIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRpbWUgaXMgMFxuICAgICAgICAgICAgICAgIC8vICBUaGVuIHByb3BzIGlzIGdpdmVuIGluaXRpYWxpemUgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyBFbHNlXG4gICAgICAgICAgICAgICAgLy8gIEluaXRpYWxpemUgdmFsdWUgZnJvbSBjdXJyZW50IHByb3AgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAodGltZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjbG9uZVZhbHVlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb3BzW3Byb3BOYW1lXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDmt7vliqDliqjnlLvmr4/kuIDluKfnmoTlm57osIPlh73mlbBcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICovXG4gICAgZHVyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25mcmFtZUxpc3QucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlwTGlzdFtpXS5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlwTGlzdFtpXS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgaXNQYXVzZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fcGF1c2VkO1xuICAgIH0sXG5cbiAgICBfZG9uZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENsZWFyIGFsbCB0cmFja3NcbiAgICAgICAgdGhpcy5fdHJhY2tzID0ge307XG4gICAgICAgIC8vIENsZWFyIGFsbCBjbGlwc1xuICAgICAgICB0aGlzLl9jbGlwTGlzdC5sZW5ndGggPSAwO1xuXG4gICAgICAgIHZhciBkb25lTGlzdCA9IHRoaXMuX2RvbmVMaXN0O1xuICAgICAgICB2YXIgbGVuID0gZG9uZUxpc3QubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBkb25lTGlzdFtpXS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDlvIDlp4vmiafooYzliqjnlLtcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd8RnVuY3Rpb259IFtlYXNpbmddXG4gICAgICogICAgICAgICDliqjnlLvnvJPliqjlh73mlbDvvIzor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ31cbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBmb3JjZUFuaW1hdGVcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICovXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChlYXNpbmcsIGZvcmNlQW5pbWF0ZSkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGNsaXBDb3VudCA9IDA7XG5cbiAgICAgICAgdmFyIG9uZVRyYWNrRG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xpcENvdW50LS07XG4gICAgICAgICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsYXN0Q2xpcDtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdGhpcy5fdHJhY2tzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYWNrcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjbGlwID0gY3JlYXRlVHJhY2tDbGlwKFxuICAgICAgICAgICAgICAgIHRoaXMsIGVhc2luZywgb25lVHJhY2tEb25lLFxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrc1twcm9wTmFtZV0sIHByb3BOYW1lLCBmb3JjZUFuaW1hdGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsaXBMaXN0LnB1c2goY2xpcCk7XG4gICAgICAgICAgICAgICAgY2xpcENvdW50Kys7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBzdGFydCBhZnRlciBhZGRlZCB0byBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uYWRkQ2xpcChjbGlwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsYXN0Q2xpcCA9IGNsaXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgZHVyaW5nIGNhbGxiYWNrIG9uIHRoZSBsYXN0IGNsaXBcbiAgICAgICAgaWYgKGxhc3RDbGlwKSB7XG4gICAgICAgICAgICB2YXIgb2xkT25GcmFtZSA9IGxhc3RDbGlwLm9uZnJhbWU7XG4gICAgICAgICAgICBsYXN0Q2xpcC5vbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgICAgICAgICAgICAgIG9sZE9uRnJhbWUodGFyZ2V0LCBwZXJjZW50KTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fb25mcmFtZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25mcmFtZUxpc3RbaV0odGFyZ2V0LCBwZXJjZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBvcHRpbWl6YXRpb24gd2lsbCBoZWxwIHRoZSBjYXNlIHRoYXQgaW4gdGhlIHVwcGVyIGFwcGxpY2F0aW9uXG4gICAgICAgIC8vIHRoZSB2aWV3IG1heSBiZSByZWZyZXNoZWQgZnJlcXVlbnRseSwgd2hlcmUgYW5pbWF0aW9uIHdpbGwgYmVcbiAgICAgICAgLy8gY2FsbGVkIHJlcGVhdGx5IGJ1dCBub3RoaW5nIGNoYW5nZWQuXG4gICAgICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLl9kb25lQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOWBnOatouWKqOeUu1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICB2YXIgY2xpcExpc3QgPSB0aGlzLl9jbGlwTGlzdDtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2xpcCA9IGNsaXBMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgICAgICAgICAgICBjbGlwLm9uZnJhbWUodGhpcy5fdGFyZ2V0LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucmVtb3ZlQ2xpcChjbGlwKTtcbiAgICAgICAgfVxuICAgICAgICBjbGlwTGlzdC5sZW5ndGggPSAwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog6K6+572u5Yqo55S75bu26L+f5byA5aeL55qE5pe26Ze0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWNleS9jW1zXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAqL1xuICAgIGRlbGF5OiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICB0aGlzLl9kZWxheSA9IHRpbWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog5re75Yqg5Yqo55S757uT5p2f55qE5Zue6LCDXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAqL1xuICAgIGRvbmU6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgdGhpcy5fZG9uZUxpc3QucHVzaChjYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcD59XG4gICAgICovXG4gICAgZ2V0Q2xpcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaXBMaXN0O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdG9yO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9hbmltYXRpb24vQW5pbWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuZXhwb3J0IGRlZmF1bHQgKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgKFxuICAgICAgICAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2lzc3Vlcy8xODkjaXNzdWVjb21tZW50LTIyNDkxOTgwOVxuICAgICAgICB8fCAod2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykpXG4gICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgIClcbikgfHwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmMsIDE2KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBCb3VuZGluZ1JlY3QgZnJvbSAnLi4vY29yZS9Cb3VuZGluZ1JlY3QnO1xuaW1wb3J0ICogYXMgaW1hZ2VIZWxwZXIgZnJvbSAnLi4vZ3JhcGhpYy9oZWxwZXIvaW1hZ2UnO1xuaW1wb3J0IHtcbiAgICBnZXRDb250ZXh0LFxuICAgIGV4dGVuZCxcbiAgICByZXRyaWV2ZTIsXG4gICAgcmV0cmlldmUzXG59IGZyb20gJy4uL2NvcmUvdXRpbCc7XG5cbnZhciB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xudmFyIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG5cbnZhciBURVhUX0NBQ0hFX01BWCA9IDUwMDA7XG52YXIgU1RZTEVfUkVHID0gL1xceyhbYS16QS1aMC05X10rKVxcfChbXn1dKilcXH0vZztcblxuZXhwb3J0IHZhciBERUZBVUxUX0ZPTlQgPSAnMTJweCBzYW5zLXNlcmlmJztcblxuLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cbnZhciBtZXRob2RzID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiAkb3ZlcnJpZGUobmFtZSwgZm4pIHtcbiAgICBtZXRob2RzW25hbWVdID0gZm47XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXaWR0aCh0ZXh0LCBmb250KSB7XG4gICAgZm9udCA9IGZvbnQgfHwgREVGQVVMVF9GT05UO1xuICAgIHZhciBrZXkgPSB0ZXh0ICsgJzonICsgZm9udDtcbiAgICBpZiAodGV4dFdpZHRoQ2FjaGVba2V5XSkge1xuICAgICAgICByZXR1cm4gdGV4dFdpZHRoQ2FjaGVba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgLy8gdGV4dENvbnRhaW4ubWVhc3VyZVRleHQgbWF5IGJlIG92ZXJyaWRlZCBpbiBTVkcgb3IgVk1MXG4gICAgICAgIHdpZHRoID0gTWF0aC5tYXgobWVhc3VyZVRleHQodGV4dExpbmVzW2ldLCBmb250KS53aWR0aCwgd2lkdGgpO1xuICAgIH1cblxuICAgIGlmICh0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPiBURVhUX0NBQ0hFX01BWCkge1xuICAgICAgICB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPSAwO1xuICAgICAgICB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgIH1cbiAgICB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIrKztcbiAgICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG5cbiAgICByZXR1cm4gd2lkdGg7XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRWZXJ0aWNhbEFsaWduPSd0b3AnXVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW3RleHRQYWRkaW5nXVxuICogQHBhcmFtIHtPYmplY3R9IFtyaWNoXVxuICogQHBhcmFtIHtPYmplY3R9IFt0cnVuY2F0ZV1cbiAqIEByZXR1cm4ge09iamVjdH0ge3gsIHksIHdpZHRoLCBoZWlnaHQsIGxpbmVIZWlnaHR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHJpY2gsIHRydW5jYXRlKSB7XG4gICAgcmV0dXJuIHJpY2hcbiAgICAgICAgPyBnZXRSaWNoVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHJpY2gsIHRydW5jYXRlKVxuICAgICAgICA6IGdldFBsYWluVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRydW5jYXRlKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGxhaW5UZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgdHJ1bmNhdGUpIHtcbiAgICB2YXIgY29udGVudEJsb2NrID0gcGFyc2VQbGFpblRleHQodGV4dCwgZm9udCwgdGV4dFBhZGRpbmcsIHRydW5jYXRlKTtcbiAgICB2YXIgb3V0ZXJXaWR0aCA9IGdldFdpZHRoKHRleHQsIGZvbnQpO1xuICAgIGlmICh0ZXh0UGFkZGluZykge1xuICAgICAgICBvdXRlcldpZHRoICs9IHRleHRQYWRkaW5nWzFdICsgdGV4dFBhZGRpbmdbM107XG4gICAgfVxuICAgIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcblxuICAgIHZhciB4ID0gYWRqdXN0VGV4dFgoMCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgICB2YXIgeSA9IGFkanVzdFRleHRZKDAsIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG5cbiAgICB2YXIgcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQpO1xuICAgIHJlY3QubGluZUhlaWdodCA9IGNvbnRlbnRCbG9jay5saW5lSGVpZ2h0O1xuXG4gICAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldFJpY2hUZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgcmljaCwgdHJ1bmNhdGUpIHtcbiAgICB2YXIgY29udGVudEJsb2NrID0gcGFyc2VSaWNoVGV4dCh0ZXh0LCB7XG4gICAgICAgIHJpY2g6IHJpY2gsXG4gICAgICAgIHRydW5jYXRlOiB0cnVuY2F0ZSxcbiAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRQYWRkaW5nOiB0ZXh0UGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBvdXRlcldpZHRoID0gY29udGVudEJsb2NrLm91dGVyV2lkdGg7XG4gICAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuXG4gICAgdmFyIHggPSBhZGp1c3RUZXh0WCgwLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICAgIHZhciB5ID0gYWRqdXN0VGV4dFkoMCwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcblxuICAgIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHgsIHksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFkanVzdGVkIHguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RUZXh0WCh4LCB3aWR0aCwgdGV4dEFsaWduKSB7XG4gICAgLy8gRklYTUUgUmlnaHQgdG8gbGVmdCBsYW5ndWFnZVxuICAgIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeCAtPSB3aWR0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICB4IC09IHdpZHRoIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dFZlcnRpY2FsQWxpZ249J3RvcCddXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFkanVzdGVkIHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RUZXh0WSh5LCBoZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnbWlkZGxlJykge1xuICAgICAgICB5IC09IGhlaWdodCAvIDI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICB5IC09IGhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIHk7XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdGlybmd9IHRleHRQb3NpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHJlY3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAqIEByZXR1cm4ge09iamVjdH0ge3gsIHksIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3QodGV4dFBvc2l0aW9uLCByZWN0LCBkaXN0YW5jZSkge1xuXG4gICAgdmFyIHggPSByZWN0Lng7XG4gICAgdmFyIHkgPSByZWN0Lnk7XG5cbiAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG5cbiAgICB2YXIgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9ICd0b3AnO1xuXG4gICAgc3dpdGNoICh0ZXh0UG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICB4IC09IGRpc3RhbmNlO1xuICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgeCArPSBkaXN0YW5jZSArIHdpZHRoO1xuICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICB5IC09IGRpc3RhbmNlO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgIHkgKz0gaGVpZ2h0ICsgZGlzdGFuY2U7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5zaWRlTGVmdCc6XG4gICAgICAgICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbnNpZGVSaWdodCc6XG4gICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbnNpZGVUb3AnOlxuICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5zaWRlQm90dG9tJzpcbiAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgeSArPSBoZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbnNpZGVUb3BMZWZ0JzpcbiAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luc2lkZVRvcFJpZ2h0JzpcbiAgICAgICAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgICAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luc2lkZUJvdHRvbUxlZnQnOlxuICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luc2lkZUJvdHRvbVJpZ2h0JzpcbiAgICAgICAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogdGV4dFZlcnRpY2FsQWxpZ25cbiAgICB9O1xufVxuXG4vKipcbiAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRhaW5lcldpZHRoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gW2VsbGlwc2lzPScuLi4nXVxuICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWF4SXRlcmF0aW9ucz0zXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyPTBdIElmIHRydW5jYXRlIHJlc3VsdCBhcmUgbGVzc1xuICogICAgICAgICAgICAgICAgICB0aGVuIG1pbkNoYXIsIGVsbGlwc2lzIHdpbGwgbm90IHNob3csIHdoaWNoIGlzXG4gKiAgICAgICAgICAgICAgICAgIGJldHRlciBmb3IgdXNlciBoaW50IGluIHNvbWUgY2FzZXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnBsYWNlaG9sZGVyPScnXSBXaGVuIGFsbCB0cnVuY2F0ZWQsIHVzZSB0aGUgcGxhY2Vob2xkZXIuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnVuY2F0ZVRleHQodGV4dCwgY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFjb250YWluZXJXaWR0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgICBvcHRpb25zID0gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyhjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpO1xuXG4gICAgLy8gRklYTUVcbiAgICAvLyBJdCBpcyBub3QgYXBwcm9wcmlhdGUgdGhhdCBldmVyeSBsaW5lIGhhcyAnLi4uJyB3aGVuIHRydW5jYXRlIG11bHRpcGxlIGxpbmVzLlxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGV4dExpbmVzW2ldID0gdHJ1bmNhdGVTaW5nbGVMaW5lKHRleHRMaW5lc1tpXSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHRMaW5lcy5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyhjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMuZm9udCA9IGZvbnQ7XG4gICAgdmFyIGVsbGlwc2lzID0gcmV0cmlldmUyKGVsbGlwc2lzLCAnLi4uJyk7XG4gICAgb3B0aW9ucy5tYXhJdGVyYXRpb25zID0gcmV0cmlldmUyKG9wdGlvbnMubWF4SXRlcmF0aW9ucywgMik7XG4gICAgdmFyIG1pbkNoYXIgPSBvcHRpb25zLm1pbkNoYXIgPSByZXRyaWV2ZTIob3B0aW9ucy5taW5DaGFyLCAwKTtcbiAgICAvLyBGSVhNRVxuICAgIC8vIE90aGVyIGxhbmd1YWdlcz9cbiAgICBvcHRpb25zLmNuQ2hhcldpZHRoID0gZ2V0V2lkdGgoJ+WbvScsIGZvbnQpO1xuICAgIC8vIEZJWE1FXG4gICAgLy8gQ29uc2lkZXIgcHJvcG9ydGlvbmFsIGZvbnQ/XG4gICAgdmFyIGFzY0NoYXJXaWR0aCA9IG9wdGlvbnMuYXNjQ2hhcldpZHRoID0gZ2V0V2lkdGgoJ2EnLCBmb250KTtcbiAgICBvcHRpb25zLnBsYWNlaG9sZGVyID0gcmV0cmlldmUyKG9wdGlvbnMucGxhY2Vob2xkZXIsICcnKTtcblxuICAgIC8vIEV4YW1wbGUgMTogbWluQ2hhcjogMywgdGV4dDogJ2FzZGZ6eGN2JywgdHJ1bmNhdGUgcmVzdWx0OiAnYXNkZicsIGJ1dCBub3Q6ICdhLi4uJy5cbiAgICAvLyBFeGFtcGxlIDI6IG1pbkNoYXI6IDMsIHRleHQ6ICfnu7TluqYnLCB0cnVuY2F0ZSByZXN1bHQ6ICfnu7QnLCBidXQgbm90OiAnLi4uJy5cbiAgICB2YXIgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggPSBNYXRoLm1heCgwLCBjb250YWluZXJXaWR0aCAtIDEpOyAvLyBSZXNlcnZlIHNvbWUgZ2FwLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluQ2hhciAmJiBjb250ZW50V2lkdGggPj0gYXNjQ2hhcldpZHRoOyBpKyspIHtcbiAgICAgICAgY29udGVudFdpZHRoIC09IGFzY0NoYXJXaWR0aDtcbiAgICB9XG5cbiAgICB2YXIgZWxsaXBzaXNXaWR0aCA9IGdldFdpZHRoKGVsbGlwc2lzKTtcbiAgICBpZiAoZWxsaXBzaXNXaWR0aCA+IGNvbnRlbnRXaWR0aCkge1xuICAgICAgICBlbGxpcHNpcyA9ICcnO1xuICAgICAgICBlbGxpcHNpc1dpZHRoID0gMDtcbiAgICB9XG5cbiAgICBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCAtIGVsbGlwc2lzV2lkdGg7XG5cbiAgICBvcHRpb25zLmVsbGlwc2lzID0gZWxsaXBzaXM7XG4gICAgb3B0aW9ucy5lbGxpcHNpc1dpZHRoID0gZWxsaXBzaXNXaWR0aDtcbiAgICBvcHRpb25zLmNvbnRlbnRXaWR0aCA9IGNvbnRlbnRXaWR0aDtcbiAgICBvcHRpb25zLmNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyV2lkdGg7XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGVTaW5nbGVMaW5lKHRleHRMaW5lLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRhaW5lcldpZHRoID0gb3B0aW9ucy5jb250YWluZXJXaWR0aDtcbiAgICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgICB2YXIgY29udGVudFdpZHRoID0gb3B0aW9ucy5jb250ZW50V2lkdGg7XG5cbiAgICBpZiAoIWNvbnRhaW5lcldpZHRoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgbGluZVdpZHRoID0gZ2V0V2lkdGgodGV4dExpbmUsIGZvbnQpO1xuXG4gICAgaWYgKGxpbmVXaWR0aCA8PSBjb250YWluZXJXaWR0aCkge1xuICAgICAgICByZXR1cm4gdGV4dExpbmU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7OyBqKyspIHtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCA8PSBjb250ZW50V2lkdGggfHwgaiA+PSBvcHRpb25zLm1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHRleHRMaW5lICs9IG9wdGlvbnMuZWxsaXBzaXM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdWJMZW5ndGggPSBqID09PSAwXG4gICAgICAgICAgICA/IGVzdGltYXRlTGVuZ3RoKHRleHRMaW5lLCBjb250ZW50V2lkdGgsIG9wdGlvbnMuYXNjQ2hhcldpZHRoLCBvcHRpb25zLmNuQ2hhcldpZHRoKVxuICAgICAgICAgICAgOiBsaW5lV2lkdGggPiAwXG4gICAgICAgICAgICA/IE1hdGguZmxvb3IodGV4dExpbmUubGVuZ3RoICogY29udGVudFdpZHRoIC8gbGluZVdpZHRoKVxuICAgICAgICAgICAgOiAwO1xuXG4gICAgICAgIHRleHRMaW5lID0gdGV4dExpbmUuc3Vic3RyKDAsIHN1Ykxlbmd0aCk7XG4gICAgICAgIGxpbmVXaWR0aCA9IGdldFdpZHRoKHRleHRMaW5lLCBmb250KTtcbiAgICB9XG5cbiAgICBpZiAodGV4dExpbmUgPT09ICcnKSB7XG4gICAgICAgIHRleHRMaW5lID0gb3B0aW9ucy5wbGFjZWhvbGRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dExpbmU7XG59XG5cbmZ1bmN0aW9uIGVzdGltYXRlTGVuZ3RoKHRleHQsIGNvbnRlbnRXaWR0aCwgYXNjQ2hhcldpZHRoLCBjbkNoYXJXaWR0aCkge1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAodmFyIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuICYmIHdpZHRoIDwgY29udGVudFdpZHRoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB3aWR0aCArPSAoMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAxMjcpID8gYXNjQ2hhcldpZHRoIDogY25DaGFyV2lkdGg7XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtudW1iZXJ9IGxpbmUgaGVpZ2h0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMaW5lSGVpZ2h0KGZvbnQpIHtcbiAgICAvLyBGSVhNRSBBIHJvdWdoIGFwcHJvYWNoLlxuICAgIHJldHVybiBnZXRXaWR0aCgn5Zu9JywgZm9udCk7XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpZHRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWFzdXJlVGV4dCh0ZXh0LCBmb250KSB7XG4gICAgcmV0dXJuIG1ldGhvZHMubWVhc3VyZVRleHQodGV4dCwgZm9udCk7XG59XG5cbi8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5tZXRob2RzLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGZvbnQpIHtcbiAgICB2YXIgY3R4ID0gZ2V0Q29udGV4dCgpO1xuICAgIGN0eC5mb250ID0gZm9udCB8fCBERUZBVUxUX0ZPTlQ7XG4gICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbn07XG5cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcGFyYW0ge09iamVjdH0gW3RydW5jYXRlXVxuICogQHJldHVybiB7T2JqZWN0fSBibG9jazoge2xpbmVIZWlnaHQsIGxpbmVzLCBoZWlnaHQsIG91dGVySGVpZ2h0fVxuICogIE5vdGljZTogZm9yIHBlcmZvcm1hbmNlLCBkbyBub3QgY2FsY3VsYXRlIG91dGVyV2lkdGggdXRpbCBuZWVkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCBwYWRkaW5nLCB0cnVuY2F0ZSkge1xuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICB2YXIgbGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQoZm9udCk7XG4gICAgdmFyIGxpbmVzID0gdGV4dCA/IHRleHQuc3BsaXQoJ1xcbicpIDogW107XG4gICAgdmFyIGhlaWdodCA9IGxpbmVzLmxlbmd0aCAqIGxpbmVIZWlnaHQ7XG4gICAgdmFyIG91dGVySGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgb3V0ZXJIZWlnaHQgKz0gcGFkZGluZ1swXSArIHBhZGRpbmdbMl07XG4gICAgfVxuXG4gICAgaWYgKHRleHQgJiYgdHJ1bmNhdGUpIHtcbiAgICAgICAgdmFyIHRydW5jT3V0ZXJIZWlnaHQgPSB0cnVuY2F0ZS5vdXRlckhlaWdodDtcbiAgICAgICAgdmFyIHRydW5jT3V0ZXJXaWR0aCA9IHRydW5jYXRlLm91dGVyV2lkdGg7XG4gICAgICAgIGlmICh0cnVuY091dGVySGVpZ2h0ICE9IG51bGwgJiYgb3V0ZXJIZWlnaHQgPiB0cnVuY091dGVySGVpZ2h0KSB7XG4gICAgICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICAgICAgICBsaW5lcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRydW5jT3V0ZXJXaWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHByZXBhcmVUcnVuY2F0ZU9wdGlvbnMoXG4gICAgICAgICAgICAgICAgdHJ1bmNPdXRlcldpZHRoIC0gKHBhZGRpbmcgPyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSA6IDApLFxuICAgICAgICAgICAgICAgIGZvbnQsXG4gICAgICAgICAgICAgICAgdHJ1bmNhdGUuZWxsaXBzaXMsXG4gICAgICAgICAgICAgICAge21pbkNoYXI6IHRydW5jYXRlLm1pbkNoYXIsIHBsYWNlaG9sZGVyOiB0cnVuY2F0ZS5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBJdCBpcyBub3QgYXBwcm9wcmlhdGUgdGhhdCBldmVyeSBsaW5lIGhhcyAnLi4uJyB3aGVuIHRydW5jYXRlIG11bHRpcGxlIGxpbmVzLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGluZXNbaV0gPSB0cnVuY2F0ZVNpbmdsZUxpbmUobGluZXNbaV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZXM6IGxpbmVzLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgb3V0ZXJIZWlnaHQ6IG91dGVySGVpZ2h0LFxuICAgICAgICBsaW5lSGVpZ2h0OiBsaW5lSGVpZ2h0XG4gICAgfTtcbn1cblxuLyoqXG4gKiBGb3IgZXhhbXBsZTogJ3NvbWUgdGV4dCB7YXxzb21lIHRleHR9b3RoZXIgdGV4dHtifHNvbWUgdGV4dH14eHh7Y3x9eHh4J1xuICogQWxzbyBjb25zaWRlciAnYmJiYnthfHh4eFxcbnp6en14eHh4XFxuYWFhYScuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICogQHJldHVybiB7T2JqZWN0fSBibG9ja1xuICoge1xuICogICAgICB3aWR0aCxcbiAqICAgICAgaGVpZ2h0LFxuICogICAgICBsaW5lczogW3tcbiAqICAgICAgICAgIGxpbmVIZWlnaHQsXG4gKiAgICAgICAgICB3aWR0aCxcbiAqICAgICAgICAgIHRva2VuczogW1t7XG4gKiAgICAgICAgICAgICAgc3R5bGVOYW1lLFxuICogICAgICAgICAgICAgIHRleHQsXG4gKiAgICAgICAgICAgICAgd2lkdGgsICAgICAgLy8gaW5jbHVkZSB0ZXh0UGFkZGluZ1xuICogICAgICAgICAgICAgIGhlaWdodCwgICAgIC8vIGluY2x1ZGUgdGV4dFBhZGRpbmdcbiAqICAgICAgICAgICAgICB0ZXh0V2lkdGgsIC8vIHB1cmUgdGV4dCB3aWR0aFxuICogICAgICAgICAgICAgIHRleHRIZWlnaHQsIC8vIHB1cmUgdGV4dCBoZWlnaHRcbiAqICAgICAgICAgICAgICBsaW5lSGVpaGd0LFxuICogICAgICAgICAgICAgIGZvbnQsXG4gKiAgICAgICAgICAgICAgdGV4dEFsaWduLFxuICogICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduXG4gKiAgICAgICAgICB9XSwgWy4uLl0sIC4uLl1cbiAqICAgICAgfSwgLi4uXVxuICogfVxuICogSWYgc3R5bGVOYW1lIGlzIHVuZGVmaW5lZCwgaXQgaXMgcGxhaW4gdGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmljaFRleHQodGV4dCwgc3R5bGUpIHtcbiAgICB2YXIgY29udGVudEJsb2NrID0ge2xpbmVzOiBbXSwgd2lkdGg6IDAsIGhlaWdodDogMH07XG5cbiAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuICAgIGlmICghdGV4dCkge1xuICAgICAgICByZXR1cm4gY29udGVudEJsb2NrO1xuICAgIH1cblxuICAgIHZhciBsYXN0SW5kZXggPSBTVFlMRV9SRUcubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHdoaWxlICgocmVzdWx0ID0gU1RZTEVfUkVHLmV4ZWModGV4dCkpICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1hdGNoZWRJbmRleCA9IHJlc3VsdC5pbmRleDtcbiAgICAgICAgaWYgKG1hdGNoZWRJbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgcHVzaFRva2Vucyhjb250ZW50QmxvY2ssIHRleHQuc3Vic3RyaW5nKGxhc3RJbmRleCwgbWF0Y2hlZEluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaFRva2Vucyhjb250ZW50QmxvY2ssIHJlc3VsdFsyXSwgcmVzdWx0WzFdKTtcbiAgICAgICAgbGFzdEluZGV4ID0gU1RZTEVfUkVHLmxhc3RJbmRleDtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgcHVzaFRva2Vucyhjb250ZW50QmxvY2ssIHRleHQuc3Vic3RyaW5nKGxhc3RJbmRleCwgdGV4dC5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICB2YXIgbGluZXMgPSBjb250ZW50QmxvY2subGluZXM7XG4gICAgdmFyIGNvbnRlbnRIZWlnaHQgPSAwO1xuICAgIHZhciBjb250ZW50V2lkdGggPSAwO1xuICAgIC8vIEZvciBgdGV4dFdpZHRoOiAxMDAlYFxuICAgIHZhciBwZW5kaW5nTGlzdCA9IFtdO1xuXG4gICAgdmFyIHN0bFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcblxuICAgIHZhciB0cnVuY2F0ZSA9IHN0eWxlLnRydW5jYXRlO1xuICAgIHZhciB0cnVuY2F0ZVdpZHRoID0gdHJ1bmNhdGUgJiYgdHJ1bmNhdGUub3V0ZXJXaWR0aDtcbiAgICB2YXIgdHJ1bmNhdGVIZWlnaHQgPSB0cnVuY2F0ZSAmJiB0cnVuY2F0ZS5vdXRlckhlaWdodDtcbiAgICBpZiAoc3RsUGFkZGluZykge1xuICAgICAgICB0cnVuY2F0ZVdpZHRoICE9IG51bGwgJiYgKHRydW5jYXRlV2lkdGggLT0gc3RsUGFkZGluZ1sxXSArIHN0bFBhZGRpbmdbM10pO1xuICAgICAgICB0cnVuY2F0ZUhlaWdodCAhPSBudWxsICYmICh0cnVuY2F0ZUhlaWdodCAtPSBzdGxQYWRkaW5nWzBdICsgc3RsUGFkZGluZ1syXSk7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGxheW91dCBpbmZvIG9mIHRva2Vucy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLnRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gbGluZS50b2tlbnNbal07XG4gICAgICAgICAgICB2YXIgdG9rZW5TdHlsZSA9IHRva2VuLnN0eWxlTmFtZSAmJiBzdHlsZS5yaWNoW3Rva2VuLnN0eWxlTmFtZV0gfHwge307XG4gICAgICAgICAgICAvLyB0ZXh0UGFkZGluZyBzaG91bGQgbm90IGluaGVyaXQgZnJvbSBzdHlsZS5cbiAgICAgICAgICAgIHZhciB0ZXh0UGFkZGluZyA9IHRva2VuLnRleHRQYWRkaW5nID0gdG9rZW5TdHlsZS50ZXh0UGFkZGluZztcblxuICAgICAgICAgICAgLy8gdGV4dEZvbnQgaGFzIGJlZW4gYXNpZ25lZCB0byBmb250IGJ5IGBub3JtYWxpemVTdHlsZWAuXG4gICAgICAgICAgICB2YXIgZm9udCA9IHRva2VuLmZvbnQgPSB0b2tlblN0eWxlLmZvbnQgfHwgc3R5bGUuZm9udDtcblxuICAgICAgICAgICAgLy8gdGV4dEhlaWdodCBjYW4gYmUgdXNlZCB3aGVuIHRleHRWZXJ0aWNhbEFsaWduIGlzIHNwZWNpZmllZCBpbiB0b2tlbi5cbiAgICAgICAgICAgIHZhciB0b2tlbkhlaWdodCA9IHRva2VuLnRleHRIZWlnaHQgPSByZXRyaWV2ZTIoXG4gICAgICAgICAgICAgICAgLy8gdGV4dEhlaWdodCBzaG91bGQgbm90IGJlIGluaGVyaXRlZCwgY29uc2lkZXIgaXQgY2FuIGJlIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgIC8vIGFzIGJveCBoZWlnaHQgb2YgdGhlIGJsb2NrLlxuICAgICAgICAgICAgICAgIHRva2VuU3R5bGUudGV4dEhlaWdodCwgZ2V0TGluZUhlaWdodChmb250KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRleHRQYWRkaW5nICYmICh0b2tlbkhlaWdodCArPSB0ZXh0UGFkZGluZ1swXSArIHRleHRQYWRkaW5nWzJdKTtcbiAgICAgICAgICAgIHRva2VuLmhlaWdodCA9IHRva2VuSGVpZ2h0O1xuICAgICAgICAgICAgdG9rZW4ubGluZUhlaWdodCA9IHJldHJpZXZlMyhcbiAgICAgICAgICAgICAgICB0b2tlblN0eWxlLnRleHRMaW5lSGVpZ2h0LCBzdHlsZS50ZXh0TGluZUhlaWdodCwgdG9rZW5IZWlnaHRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRva2VuLnRleHRBbGlnbiA9IHRva2VuU3R5bGUgJiYgdG9rZW5TdHlsZS50ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgdG9rZW4udGV4dFZlcnRpY2FsQWxpZ24gPSB0b2tlblN0eWxlICYmIHRva2VuU3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gfHwgJ21pZGRsZSc7XG5cbiAgICAgICAgICAgIGlmICh0cnVuY2F0ZUhlaWdodCAhPSBudWxsICYmIGNvbnRlbnRIZWlnaHQgKyB0b2tlbi5saW5lSGVpZ2h0ID4gdHJ1bmNhdGVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2xpbmVzOiBbXSwgd2lkdGg6IDAsIGhlaWdodDogMH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRva2VuLnRleHRXaWR0aCA9IGdldFdpZHRoKHRva2VuLnRleHQsIGZvbnQpO1xuICAgICAgICAgICAgdmFyIHRva2VuV2lkdGggPSB0b2tlblN0eWxlLnRleHRXaWR0aDtcbiAgICAgICAgICAgIHZhciB0b2tlbldpZHRoTm90U3BlY2lmaWVkID0gdG9rZW5XaWR0aCA9PSBudWxsIHx8IHRva2VuV2lkdGggPT09ICdhdXRvJztcblxuICAgICAgICAgICAgLy8gUGVyY2VudCB3aWR0aCwgY2FuIGJlIGAxMDAlYCwgY2FuIGJlIHVzZWQgaW4gZHJhd2luZyBzZXBhcmF0ZVxuICAgICAgICAgICAgLy8gbGluZSB3aGVuIGJveCB3aWR0aCBpcyBuZWVkZWQgdG8gYmUgYXV0by5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5XaWR0aCA9PT0gJ3N0cmluZycgJiYgdG9rZW5XaWR0aC5jaGFyQXQodG9rZW5XaWR0aC5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ucGVyY2VudFdpZHRoID0gdG9rZW5XaWR0aDtcbiAgICAgICAgICAgICAgICBwZW5kaW5nTGlzdC5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB0b2tlbldpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgdHJ1bmNhdGUgaW4gdGhpcyBjYXNlLCBiZWNhdXNlIHRoZXJlIGlzIG5vIHVzZXIgY2FzZVxuICAgICAgICAgICAgICAgIC8vIGFuZCBpdCBpcyB0b28gY29tcGxpY2F0ZWQuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5XaWR0aE5vdFNwZWNpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbldpZHRoID0gdG9rZW4udGV4dFdpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBJZiBpbWFnZSBpcyBub3QgbG9hZGVkIGFuZCB0ZXh0V2lkdGggaXMgbm90IHNwZWNpZmllZCwgY2FsbGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBgZ2V0Qm91bmRpbmdSZWN0KClgIHdpbGwgbm90IGdldCBjb3JyZWN0IHJlc3VsdC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSB0b2tlblN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZ0ltZyA9IHRleHRCYWNrZ3JvdW5kQ29sb3IgJiYgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgY2FzZXM6XG4gICAgICAgICAgICAgICAgICAgIC8vICgxKSBJZiBpbWFnZSBpcyBub3QgbG9hZGVkLCBpdCB3aWxsIGJlIGxvYWRlZCBhdCByZW5kZXIgcGhhc2UgYW5kIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gYGRpcnR5KClgIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2UsIGFuZCB0aGVuIHRoZSByaWdodCBzaXplIHdpbGwgYmUgY2FsY3VsYXRlZCBoZXJlIGF0IHRoZSBuZXh0IHRpY2suXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBgZ3JhcGhpYy9oZWxwZXIvdGV4dC5qc2AuXG4gICAgICAgICAgICAgICAgICAgIC8vICgyKSBJZiBpbWFnZSBsb2FkZWQsIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgaXMgaW1hZ2Ugc3JjIHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGBpbWFnZUhlbHBlci5maW5kRXhpc3RJbWFnZWAgdG8gZmluZCBjYWNoZWQgaW1hZ2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIGBpbWFnZUhlbHBlci5maW5kRXhpc3RJbWFnZWAgd2lsbCBhbHdheXMgYmUgY2FsbGVkIGhlcmUgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIGBpbWFnZUhlbHBlci5jcmVhdGVPclVwZGF0ZUltYWdlYCBpbiBgZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcyNyZW5kZXJSaWNoVGV4dGBcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggZW5zdXJlcyB0aGF0IGltYWdlIHdpbGwgbm90IGJlIHJlbmRlcmVkIGJlZm9yZSBjb3JyZWN0IHNpemUgY2FsY3VhbHRlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJnSW1nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZ0ltZyA9IGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlKGJnSW1nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoYmdJbWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5XaWR0aCA9IE1hdGgubWF4KHRva2VuV2lkdGgsIGJnSW1nLndpZHRoICogdG9rZW5IZWlnaHQgLyBiZ0ltZy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdXID0gdGV4dFBhZGRpbmcgPyB0ZXh0UGFkZGluZ1sxXSArIHRleHRQYWRkaW5nWzNdIDogMDtcbiAgICAgICAgICAgICAgICB0b2tlbldpZHRoICs9IHBhZGRpbmdXO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlbWlhblRydW5jV2lkdGggPSB0cnVuY2F0ZVdpZHRoICE9IG51bGwgPyB0cnVuY2F0ZVdpZHRoIC0gbGluZVdpZHRoIDogbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChyZW1pYW5UcnVuY1dpZHRoICE9IG51bGwgJiYgcmVtaWFuVHJ1bmNXaWR0aCA8IHRva2VuV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0b2tlbldpZHRoTm90U3BlY2lmaWVkIHx8IHJlbWlhblRydW5jV2lkdGggPCBwYWRkaW5nVykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udGV4dFdpZHRoID0gdG9rZW5XaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi50ZXh0ID0gdHJ1bmNhdGVUZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnRleHQsIHJlbWlhblRydW5jV2lkdGggLSBwYWRkaW5nVywgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge21pbkNoYXI6IHRydW5jYXRlLm1pbkNoYXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udGV4dFdpZHRoID0gZ2V0V2lkdGgodG9rZW4udGV4dCwgZm9udCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbldpZHRoID0gdG9rZW4udGV4dFdpZHRoICsgcGFkZGluZ1c7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmVXaWR0aCArPSAodG9rZW4ud2lkdGggPSB0b2tlbldpZHRoKTtcbiAgICAgICAgICAgIHRva2VuU3R5bGUgJiYgKGxpbmVIZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCB0b2tlbi5saW5lSGVpZ2h0KSk7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lLndpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBsaW5lLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICBjb250ZW50SGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGNvbnRlbnRXaWR0aCA9IE1hdGgubWF4KGNvbnRlbnRXaWR0aCwgbGluZVdpZHRoKTtcbiAgICB9XG5cbiAgICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay53aWR0aCA9IHJldHJpZXZlMihzdHlsZS50ZXh0V2lkdGgsIGNvbnRlbnRXaWR0aCk7XG4gICAgY29udGVudEJsb2NrLm91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLmhlaWdodCA9IHJldHJpZXZlMihzdHlsZS50ZXh0SGVpZ2h0LCBjb250ZW50SGVpZ2h0KTtcblxuICAgIGlmIChzdGxQYWRkaW5nKSB7XG4gICAgICAgIGNvbnRlbnRCbG9jay5vdXRlcldpZHRoICs9IHN0bFBhZGRpbmdbMV0gKyBzdGxQYWRkaW5nWzNdO1xuICAgICAgICBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQgKz0gc3RsUGFkZGluZ1swXSArIHN0bFBhZGRpbmdbMl07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZW5kaW5nTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSBwZW5kaW5nTGlzdFtpXTtcbiAgICAgICAgdmFyIHBlcmNlbnRXaWR0aCA9IHRva2VuLnBlcmNlbnRXaWR0aDtcbiAgICAgICAgLy8gU2hvdWxkIG5vdCBiYXNlIG9uIG91dGVyV2lkdGgsIGJlY2F1c2UgdG9rZW4gY2FuIG5vdCBiZSBwbGFjZWQgb3V0IG9mIHBhZGRpbmcuXG4gICAgICAgIHRva2VuLndpZHRoID0gcGFyc2VJbnQocGVyY2VudFdpZHRoLCAxMCkgLyAxMDAgKiBjb250ZW50V2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnRCbG9jaztcbn1cblxuZnVuY3Rpb24gcHVzaFRva2VucyhibG9jaywgc3RyLCBzdHlsZU5hbWUpIHtcbiAgICB2YXIgaXNFbXB0eVN0ciA9IHN0ciA9PT0gJyc7XG4gICAgdmFyIHN0cnMgPSBzdHIuc3BsaXQoJ1xcbicpO1xuICAgIHZhciBsaW5lcyA9IGJsb2NrLmxpbmVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gc3Ryc1tpXTtcbiAgICAgICAgdmFyIHRva2VuID0ge1xuICAgICAgICAgICAgc3R5bGVOYW1lOiBzdHlsZU5hbWUsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgaXNMaW5lSG9sZGVyOiAhdGV4dCAmJiAhaXNFbXB0eVN0clxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRoZSBmaXJzdCB0b2tlbiBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGxhc3QgbGluZS5cbiAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gKGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdIHx8IChsaW5lc1swXSA9IHt0b2tlbnM6IFtdfSkpLnRva2VucztcblxuICAgICAgICAgICAgLy8gQ29uc2lkZXIgY2FzZXM6XG4gICAgICAgICAgICAvLyAoMSkgJycuc3BsaXQoJ1xcbicpID0+IFsnJywgJ1xcbicsICcnXSwgdGhlICcnIGF0IHRoZSBmaXJzdCBpdGVtXG4gICAgICAgICAgICAvLyAod2hpY2ggaXMgYSBwbGFjZWhvbGRlcikgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IG5ldyB0b2tlbi5cbiAgICAgICAgICAgIC8vICgyKSBBIGltYWdlIGJhY2thZ2UsIHdoZXJlIHRva2VuIGxpa2VzIHthfH0uXG4gICAgICAgICAgICAvLyAoMykgQSByZWR1bmRhbnQgJycgd2lsbCBhZmZlY3QgdGV4dEFsaWduIGluIGxpbmUuXG4gICAgICAgICAgICAvLyAoNCkgdG9rZW5zIHdpdGggdGhlIHNhbWUgdHBsTmFtZSBzaG91bGQgbm90IGJlIG1lcmdlZCwgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhleSBzaG91bGQgYmUgZGlzcGxheWVkIGluIGRpZmZlcmVudCBib3ggKHdpdGggYm9yZGVyIGFuZCBwYWRkaW5nKS5cbiAgICAgICAgICAgIHZhciB0b2tlbnNMZW4gPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgKHRva2Vuc0xlbiA9PT0gMSAmJiB0b2tlbnNbMF0uaXNMaW5lSG9sZGVyKVxuICAgICAgICAgICAgICAgID8gKHRva2Vuc1swXSA9IHRva2VuKVxuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRleHQgaXMgJycsIG9ubHkgaW5zZXJ0IHdoZW4gaXQgaXMgdGhlIFwibGluZUhvbGRlclwiIG9yXG4gICAgICAgICAgICAgICAgLy8gXCJlbXB0eVN0clwiLiBPdGhlcndpc2UgYSByZWR1bmRhbnQgJycgd2lsbCBhZmZlY3QgdGV4dEFsaWduIGluIGxpbmUuXG4gICAgICAgICAgICAgICAgOiAoKHRleHQgfHwgIXRva2Vuc0xlbiB8fCBpc0VtcHR5U3RyKSAmJiB0b2tlbnMucHVzaCh0b2tlbikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyIHRva2VucyBhbHdheXMgc3RhcnQgYSBuZXcgbGluZS5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyAnJywgaW5zZXJ0IGl0IGFzIGEgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgICBsaW5lcy5wdXNoKHt0b2tlbnM6IFt0b2tlbl19KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGb250KHN0eWxlKSB7XG4gICAgLy8gRklYTUUgaW4gbm9kZS1jYW52YXMgZm9udFdlaWdodCBpcyBiZWZvcmUgZm9udFN0eWxlXG4gICAgLy8gVXNlIGBmb250U2l6ZWAgYGZvbnRGYW1pbHlgIHRvIGNoZWNrIHdoZXRoZXIgZm9udCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICAgIHJldHVybiAoc3R5bGUuZm9udFNpemUgfHwgc3R5bGUuZm9udEZhbWlseSkgJiYgW1xuICAgICAgICBzdHlsZS5mb250U3R5bGUsXG4gICAgICAgIHN0eWxlLmZvbnRXZWlnaHQsXG4gICAgICAgIChzdHlsZS5mb250U2l6ZSB8fCAxMikgKyAncHgnLFxuICAgICAgICAvLyBJZiBmb250IHByb3BlcnRpZXMgYXJlIGRlZmluZWQsIGBmb250RmFtaWx5YCBzaG91bGQgbm90IGJlIGlnbm9yZWQuXG4gICAgICAgIHN0eWxlLmZvbnRGYW1pbHkgfHwgJ3NhbnMtc2VyaWYnXG4gICAgXS5qb2luKCcgJykgfHwgc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9jb250YWluL3RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUmFkaWFuKGFuZ2xlKSB7XG4gICAgYW5nbGUgJT0gUEkyO1xuICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgYW5nbGUgKz0gUEkyO1xuICAgIH1cbiAgICByZXR1cm4gYW5nbGU7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL2NvbnRhaW4vdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gU2ltcGxlIExSVSBjYWNoZSB1c2UgZG91Ymx5IGxpbmtlZCBsaXN0XG4vLyBAbW9kdWxlIHpyZW5kZXIvY29yZS9MUlVcblxuLyoqXG4gKiBTaW1wbGUgZG91YmxlIGxpbmtlZCBsaXN0LiBDb21wYXJlZCB3aXRoIGFycmF5LCBpdCBoYXMgTygxKSByZW1vdmUgb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gbnVsbDtcblxuICAgIHRoaXMuX2xlbiA9IDA7XG59O1xuXG52YXIgbGlua2VkTGlzdFByb3RvID0gTGlua2VkTGlzdC5wcm90b3R5cGU7XG4vKipcbiAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgdGFpbFxuICogQHBhcmFtICB7fSB2YWxcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICovXG5saW5rZWRMaXN0UHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhciBlbnRyeSA9IG5ldyBFbnRyeSh2YWwpO1xuICAgIHRoaXMuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgIHJldHVybiBlbnRyeTtcbn07XG5cbi8qKlxuICogSW5zZXJ0IGFuIGVudHJ5IGF0IHRoZSB0YWlsXG4gKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAqL1xubGlua2VkTGlzdFByb3RvLmluc2VydEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gZW50cnk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgICAgICBlbnRyeS5wcmV2ID0gdGhpcy50YWlsO1xuICAgICAgICBlbnRyeS5uZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgfVxuICAgIHRoaXMuX2xlbisrO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgZW50cnkuXG4gKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAqL1xubGlua2VkTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHZhciBwcmV2ID0gZW50cnkucHJldjtcbiAgICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XG4gICAgaWYgKHByZXYpIHtcbiAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElzIGhlYWRcbiAgICAgICAgdGhpcy5oZWFkID0gbmV4dDtcbiAgICB9XG4gICAgaWYgKG5leHQpIHtcbiAgICAgICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElzIHRhaWxcbiAgICAgICAgdGhpcy50YWlsID0gcHJldjtcbiAgICB9XG4gICAgZW50cnkubmV4dCA9IGVudHJ5LnByZXYgPSBudWxsO1xuICAgIHRoaXMuX2xlbi0tO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmxpbmtlZExpc3RQcm90by5sZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbjtcbn07XG5cbi8qKlxuICogQ2xlYXIgbGlzdFxuICovXG5saW5rZWRMaXN0UHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLl9sZW4gPSAwO1xufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7fSB2YWxcbiAqL1xudmFyIEVudHJ5ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHt9XG4gICAgICovXG4gICAgdGhpcy52YWx1ZSA9IHZhbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICovXG4gICAgdGhpcy5wcmV2O1xufTtcblxuLyoqXG4gKiBMUlUgQ2FjaGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvTFJVXG4gKi9cbnZhciBMUlUgPSBmdW5jdGlvbiAobWF4U2l6ZSkge1xuXG4gICAgdGhpcy5fbGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG5cbiAgICB0aGlzLl9tYXAgPSB7fTtcblxuICAgIHRoaXMuX21heFNpemUgPSBtYXhTaXplIHx8IDEwO1xuXG4gICAgdGhpcy5fbGFzdFJlbW92ZWRFbnRyeSA9IG51bGw7XG59O1xuXG52YXIgTFJVUHJvdG8gPSBMUlUucHJvdG90eXBlO1xuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0gIHt9IHZhbHVlXG4gKiBAcmV0dXJuIHt9IFJlbW92ZWQgdmFsdWVcbiAqL1xuTFJVUHJvdG8ucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICB2YXIgcmVtb3ZlZCA9IG51bGw7XG4gICAgaWYgKG1hcFtrZXldID09IG51bGwpIHtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuKCk7XG4gICAgICAgIC8vIFJldXNlIGxhc3QgcmVtb3ZlZCBlbnRyeVxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5O1xuXG4gICAgICAgIGlmIChsZW4gPj0gdGhpcy5fbWF4U2l6ZSAmJiBsZW4gPiAwKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWRcbiAgICAgICAgICAgIHZhciBsZWFzdFVzZWRFbnRyeSA9IGxpc3QuaGVhZDtcbiAgICAgICAgICAgIGxpc3QucmVtb3ZlKGxlYXN0VXNlZEVudHJ5KTtcbiAgICAgICAgICAgIGRlbGV0ZSBtYXBbbGVhc3RVc2VkRW50cnkua2V5XTtcblxuICAgICAgICAgICAgcmVtb3ZlZCA9IGxlYXN0VXNlZEVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFJlbW92ZWRFbnRyeSA9IGxlYXN0VXNlZEVudHJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW50cnkgPSBuZXcgRW50cnkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5LmtleSA9IGtleTtcbiAgICAgICAgbGlzdC5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgICAgIG1hcFtrZXldID0gZW50cnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbW92ZWQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHt9XG4gKi9cbkxSVVByb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLl9tYXBba2V5XTtcbiAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAgICAgLy8gUHV0IHRoZSBsYXRlc3QgdXNlZCBlbnRyeSBpbiB0aGUgdGFpbFxuICAgICAgICBpZiAoZW50cnkgIT09IGxpc3QudGFpbCkge1xuICAgICAgICAgICAgbGlzdC5yZW1vdmUoZW50cnkpO1xuICAgICAgICAgICAgbGlzdC5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgY2FjaGVcbiAqL1xuTFJVUHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbGlzdC5jbGVhcigpO1xuICAgIHRoaXMuX21hcCA9IHt9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTFJVO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9jb3JlL0xSVS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBQYXRoIOS7o+eQhu+8jOWPr+S7peWcqGBidWlsZFBhdGhg5Lit55So5LqO5pu/5LujYGN0eGAsIOS8muS/neWtmOavj+S4qnBhdGjmk43kvZznmoTlkb3ku6TliLBwYXRoQ29tbWFuZHPlsZ7mgKfkuK1cbiAqIOWPr+S7peeUqOS6jiBpc0luc2lkZVBhdGgg5Yik5pat5Lul5Y+K6I635Y+WYm91bmRpbmdSZWN0XG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvUGF0aFByb3h5XG4gKiBAYXV0aG9yIFlpIFNoZW4gKGh0dHA6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cbi8vIFRPRE8gZ2V0VG90YWxMZW5ndGgsIGdldFBvaW50QXRMZW5ndGhcblxuaW1wb3J0ICogYXMgY3VydmUgZnJvbSAnLi9jdXJ2ZSc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4vdmVjdG9yJztcbmltcG9ydCAqIGFzIGJib3ggZnJvbSAnLi9iYm94JztcbmltcG9ydCBCb3VuZGluZ1JlY3QgZnJvbSAnLi9Cb3VuZGluZ1JlY3QnO1xuaW1wb3J0IHtkZXZpY2VQaXhlbFJhdGlvIGFzIGRwcn0gZnJvbSAnLi4vY29uZmlnJztcblxudmFyIENNRCA9IHtcbiAgICBNOiAxLFxuICAgIEw6IDIsXG4gICAgQzogMyxcbiAgICBROiA0LFxuICAgIEE6IDUsXG4gICAgWjogNixcbiAgICAvLyBSZWN0XG4gICAgUjogN1xufTtcblxuLy8gdmFyIENNRF9NRU1fU0laRSA9IHtcbi8vICAgICBNOiAzLFxuLy8gICAgIEw6IDMsXG4vLyAgICAgQzogNyxcbi8vICAgICBROiA1LFxuLy8gICAgIEE6IDksXG4vLyAgICAgUjogNSxcbi8vICAgICBaOiAxXG4vLyB9O1xuXG52YXIgbWluID0gW107XG52YXIgbWF4ID0gW107XG52YXIgbWluMiA9IFtdO1xudmFyIG1heDIgPSBbXTtcbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG52YXIgaGFzVHlwZWRBcnJheSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFBhdGhQcm94eSA9IGZ1bmN0aW9uIChub3RTYXZlRGF0YSkge1xuXG4gICAgdGhpcy5fc2F2ZURhdGEgPSAhKG5vdFNhdmVEYXRhIHx8IGZhbHNlKTtcblxuICAgIGlmICh0aGlzLl9zYXZlRGF0YSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUGF0aCBkYXRhLiBTdG9yZWQgYXMgZmxhdCBhcnJheVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdHggPSBudWxsO1xufTtcblxuLyoqXG4gKiDlv6vpgJ/orqHnrpdQYXRo5YyF5Zu055uS77yI5bm25LiN5piv5pyA5bCP5YyF5Zu055uS77yJXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblBhdGhQcm94eS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogUGF0aFByb3h5LFxuXG4gICAgX3hpOiAwLFxuICAgIF95aTogMCxcblxuICAgIF94MDogMCxcbiAgICBfeTA6IDAsXG4gICAgLy8gVW5pdCB4LCBVbml0IHkuIFByb3ZpZGUgZm9yIGF2b2lkaW5nIGRyYXdpbmcgdGhhdCB0b28gc2hvcnQgbGluZSBzZWdtZW50XG4gICAgX3V4OiAwLFxuICAgIF91eTogMCxcblxuICAgIF9sZW46IDAsXG5cbiAgICBfbGluZURhc2g6IG51bGwsXG5cbiAgICBfZGFzaE9mZnNldDogMCxcblxuICAgIF9kYXNoSWR4OiAwLFxuXG4gICAgX2Rhc2hTdW06IDAsXG5cbiAgICAvKipcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICBzZXRTY2FsZTogZnVuY3Rpb24gKHN4LCBzeSkge1xuICAgICAgICB0aGlzLl91eCA9IG1hdGhBYnMoMSAvIGRwciAvIHN4KSB8fCAwO1xuICAgICAgICB0aGlzLl91eSA9IG1hdGhBYnMoMSAvIGRwciAvIHN5KSB8fCAwO1xuICAgIH0sXG5cbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdHg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICovXG4gICAgYmVnaW5QYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG5cbiAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuXG4gICAgICAgIGN0eCAmJiBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgY3R4ICYmICh0aGlzLmRwciA9IGN0eC5kcHIpO1xuXG4gICAgICAgIC8vIFJlc2V0XG4gICAgICAgIGlmICh0aGlzLl9zYXZlRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9saW5lRGFzaCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZURhc2ggPSBudWxsO1xuXG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgKi9cbiAgICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHRoaXMuYWRkRGF0YShDTUQuTSwgeCwgeSk7XG4gICAgICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHgubW92ZVRvKHgsIHkpO1xuXG4gICAgICAgIC8vIHgwLCB5MCwgeGksIHlpIOaYr+iusOW9leWcqCBfZGFzaGVkWFhYWFRvIOaWueazleS4reS9v+eUqFxuICAgICAgICAvLyB4aSwgeWkg6K6w5b2V5b2T5YmN54K5LCB4MCwgeTAg5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnlm57liLDotbflp4vngrnjgIJcbiAgICAgICAgLy8g5pyJ5Y+v6IO95ZyoIGJlZ2luUGF0aCDkuYvlkI7nm7TmjqXosIPnlKggbGluZVRv77yM6L+Z5pe25YCZIHgwLCB5MCDpnIDopoFcbiAgICAgICAgLy8g5ZyoIGxpbmVUbyDmlrnms5XkuK3orrDlvZXvvIzov5nph4zlhYjkuI3ogIPomZHov5nnp43mg4XlhrXvvIxkYXNoZWQgbGluZSDkuZ/lj6rlnKggSUUxMC0g5Lit5LiN5pSv5oyBXG4gICAgICAgIHRoaXMuX3gwID0geDtcbiAgICAgICAgdGhpcy5feTAgPSB5O1xuXG4gICAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgICAgdGhpcy5feWkgPSB5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgKi9cbiAgICBsaW5lVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBleGNlZWRVbml0ID0gbWF0aEFicyh4IC0gdGhpcy5feGkpID4gdGhpcy5fdXhcbiAgICAgICAgICAgIHx8IG1hdGhBYnMoeSAtIHRoaXMuX3lpKSA+IHRoaXMuX3V5XG4gICAgICAgICAgICAvLyBGb3JjZSBkcmF3IHRoZSBmaXJzdCBzZWdtZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9sZW4gPCA1O1xuXG4gICAgICAgIHRoaXMuYWRkRGF0YShDTUQuTCwgeCwgeSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2N0eCAmJiBleGNlZWRVbml0KSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZExpbmVUbyh4LCB5KVxuICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhjZWVkVW5pdCkge1xuICAgICAgICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5M1xuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAqL1xuICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgIHRoaXMuYWRkRGF0YShDTUQuQywgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MylcbiAgICAgICAgICAgICAgICA6IHRoaXMuX2N0eC5iZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3hpID0geDM7XG4gICAgICAgIHRoaXMuX3lpID0geTM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSAge251bWJlcn0geDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICovXG4gICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHRoaXMuYWRkRGF0YShDTUQuUSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZFF1YWRyYXRpY1RvKHgxLCB5MSwgeDIsIHkyKVxuICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3hpID0geDI7XG4gICAgICAgIHRoaXMuX3lpID0geTI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN4XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBjeVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gc3RhcnRBbmdsZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gZW5kQW5nbGVcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBhbnRpY2xvY2t3aXNlXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICovXG4gICAgYXJjOiBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICB0aGlzLmFkZERhdGEoXG4gICAgICAgICAgICBDTUQuQSwgY3gsIGN5LCByLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUsIDAsIGFudGljbG9ja3dpc2UgPyAwIDogMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LmFyYyhjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKTtcblxuICAgICAgICB0aGlzLl94aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogciArIGN4O1xuICAgICAgICB0aGlzLl95aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogciArIGN4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gVE9ET1xuICAgIGFyY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgICAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICAgICAgICB0aGlzLl9jdHguYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRPRE9cbiAgICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuYWRkRGF0YShDTUQuUiwgeCwgeSwgdywgaCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgKi9cbiAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hZGREYXRhKENNRC5aKTtcblxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICB2YXIgeDAgPSB0aGlzLl94MDtcbiAgICAgICAgdmFyIHkwID0gdGhpcy5feTA7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpICYmIHRoaXMuX2Rhc2hlZExpbmVUbyh4MCwgeTApO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5feGkgPSB4MDtcbiAgICAgICAgdGhpcy5feWkgPSB5MDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnRleHQg5LuO5aSW6YOo5Lyg5YWl77yM5Zug5Li65pyJ5Y+v6IO95pivIHJlYnVpbGRQYXRoIOWujOS5i+WQjuWGjSBmaWxs44CCXG4gICAgICogc3Ryb2tlIOWQjOagt1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgKi9cbiAgICBmaWxsOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIGN0eCAmJiBjdHguZmlsbCgpO1xuICAgICAgICB0aGlzLnRvU3RhdGljKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgKi9cbiAgICBzdHJva2U6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgY3R4ICYmIGN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy50b1N0YXRpYygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAqL1xuICAgIHNldExpbmVEYXNoOiBmdW5jdGlvbiAobGluZURhc2gpIHtcbiAgICAgICAgaWYgKGxpbmVEYXNoIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVEYXNoID0gbGluZURhc2g7XG5cbiAgICAgICAgICAgIHRoaXMuX2Rhc2hJZHggPSAwO1xuXG4gICAgICAgICAgICB2YXIgbGluZURhc2hTdW0gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lRGFzaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxpbmVEYXNoU3VtICs9IGxpbmVEYXNoW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGFzaFN1bSA9IGxpbmVEYXNoU3VtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAqL1xuICAgIHNldExpbmVEYXNoT2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgbGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOebtOaOpeiuvue9riBQYXRoIOaVsOaNrlxuICAgICAqL1xuICAgIHNldERhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICAgICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgIGlmICghICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCA9PSBsZW4pICYmIGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IGRhdGFbaV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sZW4gPSBsZW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOa3u+WKoOWtkOi3r+W+hFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl8QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5Pn0gcGF0aFxuICAgICAqL1xuICAgIGFwcGVuZFBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBbcGF0aF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgICAgICB2YXIgYXBwZW5kU2l6ZSA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9sZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGFwcGVuZFNpemUgKz0gcGF0aFtpXS5sZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzVHlwZWRBcnJheSAmJiAodGhpcy5kYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKyBhcHBlbmRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXBwZW5kUGF0aERhdGEgPSBwYXRoW2ldLmRhdGE7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFwcGVuZFBhdGhEYXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW29mZnNldCsrXSA9IGFwcGVuZFBhdGhEYXRhW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbiA9IG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog5aGr5YWFIFBhdGgg5pWw5o2u44CCXG4gICAgICog5bC96YeP5aSN55So6ICM5LiN55Sz5piO5paw55qE5pWw57uE44CC5aSn6YOo5YiG5Zu+5b2i6YeN57uY55qE5oyH5Luk5pWw5o2u6ZW/5bqm6YO95piv5LiN5Y+Y55qE44CCXG4gICAgICovXG4gICAgYWRkRGF0YTogZnVuY3Rpb24gKGNtZCkge1xuICAgICAgICBpZiAoIXRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuX2xlbiArIGFyZ3VtZW50cy5sZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8g5Zug5Li65LmL5YmN55qE5pWw57uE5bey57uP6L2s5o2i5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheVxuICAgICAgICAgICAgLy8g5omA5Lul5LiN5aSf55So5pe26ZyA6KaB5omp5bGV5LiA5Liq5paw55qE5Yqo5oCB5pWw57uEXG4gICAgICAgICAgICB0aGlzLl9leHBhbmREYXRhKCk7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhW3RoaXMuX2xlbisrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ByZXZDbWQgPSBjbWQ7XG4gICAgfSxcblxuICAgIF9leHBhbmREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE9ubHkgaWYgZGF0YSBpcyBGbG9hdDMyQXJyYXlcbiAgICAgICAgaWYgKCEodGhpcy5kYXRhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICB2YXIgbmV3RGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG5ld0RhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXdEYXRhO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIG5lZWRzIGpzIGltcGxlbWVudGVkIGRhc2hlZCBsaW5lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9uZWVkc0Rhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVEYXNoO1xuICAgIH0sXG5cbiAgICBfZGFzaGVkTGluZVRvOiBmdW5jdGlvbiAoeDEsIHkxKSB7XG4gICAgICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gICAgICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgICAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICAgICAgdmFyIGR4ID0geDEgLSB4MDtcbiAgICAgICAgdmFyIGR5ID0geTEgLSB5MDtcbiAgICAgICAgdmFyIGRpc3QgPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIHZhciB4ID0geDA7XG4gICAgICAgIHZhciB5ID0geTA7XG4gICAgICAgIHZhciBkYXNoO1xuICAgICAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG4gICAgICAgIHZhciBpZHg7XG4gICAgICAgIGR4IC89IGRpc3Q7XG4gICAgICAgIGR5IC89IGRpc3Q7XG5cbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgICAgICB4IC09IG9mZnNldCAqIGR4O1xuICAgICAgICB5IC09IG9mZnNldCAqIGR5O1xuXG4gICAgICAgIHdoaWxlICgoZHggPiAwICYmIHggPD0geDEpIHx8IChkeCA8IDAgJiYgeCA+PSB4MSlcbiAgICAgICAgfHwgKGR4ID09IDAgJiYgKChkeSA+IDAgJiYgeSA8PSB5MSkgfHwgKGR5IDwgMCAmJiB5ID49IHkxKSkpKSB7XG4gICAgICAgICAgICBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgICAgICAgICAgZGFzaCA9IGxpbmVEYXNoW2lkeF07XG4gICAgICAgICAgICB4ICs9IGR4ICogZGFzaDtcbiAgICAgICAgICAgIHkgKz0gZHkgKiBkYXNoO1xuICAgICAgICAgICAgdGhpcy5fZGFzaElkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgICAgICAgICAgLy8gU2tpcCBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgICAgICAgIGlmICgoZHggPiAwICYmIHggPCB4MCkgfHwgKGR4IDwgMCAmJiB4ID4geDApIHx8IChkeSA+IDAgJiYgeSA8IHkwKSB8fCAoZHkgPCAwICYmIHkgPiB5MCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eFtpZHggJSAyID8gJ21vdmVUbycgOiAnbGluZVRvJ10oXG4gICAgICAgICAgICAgICAgZHggPj0gMCA/IG1hdGhNaW4oeCwgeDEpIDogbWF0aE1heCh4LCB4MSksXG4gICAgICAgICAgICAgICAgZHkgPj0gMCA/IG1hdGhNaW4oeSwgeTEpIDogbWF0aE1heCh5LCB5MSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT2Zmc2V0IGZvciBuZXh0IGxpbmVUb1xuICAgICAgICBkeCA9IHggLSB4MTtcbiAgICAgICAgZHkgPSB5IC0geTE7XG4gICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH0sXG5cbiAgICAvLyBOb3QgYWNjdXJhdGUgZGFzaGVkIGxpbmUgdG9cbiAgICBfZGFzaGVkQmV6aWVyVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gICAgICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgICAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHZhciBkeDtcbiAgICAgICAgdmFyIGR5O1xuICAgICAgICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gICAgICAgIHZhciBiZXppZXJMZW4gPSAwO1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5fZGFzaElkeDtcbiAgICAgICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuXG4gICAgICAgIHZhciB4O1xuICAgICAgICB2YXIgeTtcblxuICAgICAgICB2YXIgdG1wTGVuID0gMDtcblxuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0byBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgICAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICU9IGRhc2hTdW07XG4gICAgICAgIC8vIEJlemllciBhcHByb3ggbGVuZ3RoXG4gICAgICAgIGZvciAodCA9IDA7IHQgPCAxOyB0ICs9IDAuMSkge1xuICAgICAgICAgICAgZHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0ICsgMC4xKVxuICAgICAgICAgICAgICAgIC0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICBkeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQgKyAwLjEpXG4gICAgICAgICAgICAgICAgLSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgICAgICAgIGJlemllckxlbiArPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIGlkeCBhZnRlciBhZGQgb2Zmc2V0XG4gICAgICAgIGZvciAoOyBpZHggPCBuRGFzaDsgaWR4KyspIHtcbiAgICAgICAgICAgIHRtcExlbiArPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgICAgICAgaWYgKHRtcExlbiA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHQgPSAodG1wTGVuIC0gb2Zmc2V0KSAvIGJlemllckxlbjtcblxuICAgICAgICB3aGlsZSAodCA8PSAxKSB7XG5cbiAgICAgICAgICAgIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcblxuICAgICAgICAgICAgLy8gVXNlIGxpbmUgdG8gYXBwcm94aW1hdGUgZGFzaGVkIGJlemllclxuICAgICAgICAgICAgLy8gQmFkIHJlc3VsdCBpZiBkYXNoIGlzIGxvbmdcbiAgICAgICAgICAgIGlkeCAlIDIgPyBjdHgubW92ZVRvKHgsIHkpXG4gICAgICAgICAgICAgICAgOiBjdHgubGluZVRvKHgsIHkpO1xuXG4gICAgICAgICAgICB0ICs9IGxpbmVEYXNoW2lkeF0gLyBiZXppZXJMZW47XG5cbiAgICAgICAgICAgIGlkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluaXNoIHRoZSBsYXN0IHNlZ21lbnQgYW5kIGNhbGN1bGF0ZSB0aGUgbmV3IG9mZnNldFxuICAgICAgICAoaWR4ICUgMiAhPT0gMCkgJiYgY3R4LmxpbmVUbyh4MywgeTMpO1xuICAgICAgICBkeCA9IHgzIC0geDtcbiAgICAgICAgZHkgPSB5MyAtIHk7XG4gICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH0sXG5cbiAgICBfZGFzaGVkUXVhZHJhdGljVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICAvLyBDb252ZXJ0IHF1YWRyYXRpYyB0byBjdWJpYyB1c2luZyBkZWdyZWUgZWxldmF0aW9uXG4gICAgICAgIHZhciB4MyA9IHgyO1xuICAgICAgICB2YXIgeTMgPSB5MjtcbiAgICAgICAgeDIgPSAoeDIgKyAyICogeDEpIC8gMztcbiAgICAgICAgeTIgPSAoeTIgKyAyICogeTEpIC8gMztcbiAgICAgICAgeDEgPSAodGhpcy5feGkgKyAyICogeDEpIC8gMztcbiAgICAgICAgeTEgPSAodGhpcy5feWkgKyAyICogeTEpIC8gMztcblxuICAgICAgICB0aGlzLl9kYXNoZWRCZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog6L2s5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheSDlh4/lsJHloIblhoXlrZjljaDnlKhcbiAgICAgKiBDb252ZXJ0IGR5bmFtaWMgYXJyYXkgdG8gc3RhdGljIEZsb2F0MzJBcnJheVxuICAgICAqL1xuICAgIHRvU3RhdGljOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBkYXRhLmxlbmd0aCA9IHRoaXMuX2xlbjtcbiAgICAgICAgICAgIGlmIChoYXNUeXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWluWzBdID0gbWluWzFdID0gbWluMlswXSA9IG1pbjJbMV0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBtYXhbMF0gPSBtYXhbMV0gPSBtYXgyWzBdID0gbWF4MlsxXSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICB2YXIgeWkgPSAwO1xuICAgICAgICB2YXIgeDAgPSAwO1xuICAgICAgICB2YXIgeTAgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgICAgICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgICAgICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgbWluMlswXSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICBtaW4yWzFdID0geTA7XG4gICAgICAgICAgICAgICAgICAgIG1heDJbMF0gPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgbWF4MlsxXSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21MaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUN1YmljKFxuICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluMiwgbWF4MlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgICAgICAgICAgIGJib3guZnJvbVF1YWRyYXRpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluMiwgbWF4MlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOWIpOaWreeahOW8gOmUgOavlOi+g+Wkp1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBkYXRhW2krK10gKyBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDml4vovaxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tQXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZSwgbWluMiwgbWF4MlxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB5aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgZnJvbUxpbmVcbiAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tTGluZSh4MCwgeTAsIHgwICsgd2lkdGgsIHkwICsgaGVpZ2h0LCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVuaW9uXG4gICAgICAgICAgICB2ZWMyLm1pbihtaW4sIG1pbiwgbWluMik7XG4gICAgICAgICAgICB2ZWMyLm1heChtYXgsIG1heCwgbWF4Mik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyBkYXRhXG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBtaW5bMF0gPSBtaW5bMV0gPSBtYXhbMF0gPSBtYXhbMV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICBtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV1cbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVidWlsZCBwYXRoIGZyb20gY3VycmVudCBkYXRhXG4gICAgICogUmVidWlsZCBwYXRoIHdpbGwgbm90IGNvbnNpZGVyIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZSBkYXNoLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKi9cbiAgICByZWJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgZCA9IHRoaXMuZGF0YTtcbiAgICAgICAgdmFyIHgwLCB5MDtcbiAgICAgICAgdmFyIHhpLCB5aTtcbiAgICAgICAgdmFyIHgsIHk7XG4gICAgICAgIHZhciB1eCA9IHRoaXMuX3V4O1xuICAgICAgICB2YXIgdXkgPSB0aGlzLl91eTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2xlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICB2YXIgY21kID0gZFtpKytdO1xuXG4gICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgIHhpID0gZFtpXTtcbiAgICAgICAgICAgICAgICB5aSA9IGRbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHhpLCB5aSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgICAgICAgICAgIHggPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgIHkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBkcmF3IHRvbyBzbWFsbCBzZWcgYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0aEFicyh4IC0geGkpID4gdXggfHwgbWF0aEFicyh5IC0geWkpID4gdXkgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK11cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciByeCA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ5ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBkVGhldGEgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBwc2kgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcyA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSAocnggPiByeSkgPyByeCA6IHJ5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVYID0gKHJ4ID4gcnkpID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVkgPSAocnggPiByeSkgPyByeSAvIHJ4IDogMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzRWxsaXBzZSA9IE1hdGguYWJzKHJ4IC0gcnkpID4gMWUtMztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gdGhldGEgKyBkVGhldGE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0VsbGlwc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoY3gsIGN5LCByLCB0aGV0YSwgZW5kQW5nbGUsIDEgLSBmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDnm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IG1hdGhDb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0gbWF0aFNpbih0aGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB5aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4aSA9IGRbaV07XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuUGF0aFByb3h5LkNNRCA9IENNRDtcblxuZXhwb3J0IGRlZmF1bHQgUGF0aFByb3h5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9jb3JlL1BhdGhQcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiB6cmVuZGVyOiDnlJ/miJDllK/kuIBpZFxuICpcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG52YXIgaWRTdGFydCA9IDB4MDkwNztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpZFN0YXJ0Kys7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL2NvcmUvZ3VpZC5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtkZWJ1Z01vZGV9IGZyb20gJy4uL2NvbmZpZyc7XG5cbnZhciBsb2cgPSBmdW5jdGlvbiAoKSB7XG59O1xuXG5pZiAoZGVidWdNb2RlID09PSAxKSB7XG4gICAgbG9nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3VtZW50c1trXSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZWxzZSBpZiAoZGVidWdNb2RlID4gMSkge1xuICAgIGxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50c1trXSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBsb2c7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL2NvcmUvbG9nLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIDN4MuefqemYteaTjeS9nOexu1xuICogQGV4cG9ydHMgenJlbmRlci90b29sL21hdHJpeFxuICovXG5cbnZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJ1xuICAgID8gQXJyYXlcbiAgIDogRmxvYXQzMkFycmF5O1xuXG4vKipcbiAqIOWIm+W7uuS4gOS4quWNleS9jeefqemYtVxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDYpO1xuICAgIGlkZW50aXR5KG91dCk7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIOiuvue9ruefqemYteS4uuWNleS9jeefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiDlpI3liLbnn6npmLVcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgbSkge1xuICAgIG91dFswXSA9IG1bMF07XG4gICAgb3V0WzFdID0gbVsxXTtcbiAgICBvdXRbMl0gPSBtWzJdO1xuICAgIG91dFszXSA9IG1bM107XG4gICAgb3V0WzRdID0gbVs0XTtcbiAgICBvdXRbNV0gPSBtWzVdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICog55+p6Zi155u45LmYXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTFcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsKG91dCwgbTEsIG0yKSB7XG4gICAgLy8gQ29uc2lkZXIgbWF0cml4Lm11bChtLCBtMiwgbSk7XG4gICAgLy8gd2hlcmUgb3V0IGlzIHRoZSBzYW1lIGFzIG0yLlxuICAgIC8vIFNvIHVzZSB0ZW1wIHZhcmlhYmxlIHRvIGVzY2FwZSBlcnJvci5cbiAgICB2YXIgb3V0MCA9IG0xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdO1xuICAgIHZhciBvdXQxID0gbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV07XG4gICAgdmFyIG91dDIgPSBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXTtcbiAgICB2YXIgb3V0MyA9IG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdO1xuICAgIHZhciBvdXQ0ID0gbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XTtcbiAgICB2YXIgb3V0NSA9IG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV07XG4gICAgb3V0WzBdID0gb3V0MDtcbiAgICBvdXRbMV0gPSBvdXQxO1xuICAgIG91dFsyXSA9IG91dDI7XG4gICAgb3V0WzNdID0gb3V0MztcbiAgICBvdXRbNF0gPSBvdXQ0O1xuICAgIG91dFs1XSA9IG91dDU7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiDlubPnp7vlj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XSArIHZbMF07XG4gICAgb3V0WzVdID0gYVs1XSArIHZbMV07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiDml4vovazlj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYWEgPSBhWzBdO1xuICAgIHZhciBhYyA9IGFbMl07XG4gICAgdmFyIGF0eCA9IGFbNF07XG4gICAgdmFyIGFiID0gYVsxXTtcbiAgICB2YXIgYWQgPSBhWzNdO1xuICAgIHZhciBhdHkgPSBhWzVdO1xuICAgIHZhciBzdCA9IE1hdGguc2luKHJhZCk7XG4gICAgdmFyIGN0ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGFhICogY3QgKyBhYiAqIHN0O1xuICAgIG91dFsxXSA9IC1hYSAqIHN0ICsgYWIgKiBjdDtcbiAgICBvdXRbMl0gPSBhYyAqIGN0ICsgYWQgKiBzdDtcbiAgICBvdXRbM10gPSAtYWMgKiBzdCArIGN0ICogYWQ7XG4gICAgb3V0WzRdID0gY3QgKiBhdHggKyBzdCAqIGF0eTtcbiAgICBvdXRbNV0gPSBjdCAqIGF0eSAtIHN0ICogYXR4O1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICog57yp5pS+5Y+Y5o2iXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICAgIHZhciB2eCA9IHZbMF07XG4gICAgdmFyIHZ5ID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhWzBdICogdng7XG4gICAgb3V0WzFdID0gYVsxXSAqIHZ5O1xuICAgIG91dFsyXSA9IGFbMl0gKiB2eDtcbiAgICBvdXRbM10gPSBhWzNdICogdnk7XG4gICAgb3V0WzRdID0gYVs0XSAqIHZ4O1xuICAgIG91dFs1XSA9IGFbNV0gKiB2eTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIOaxgumAhuefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcblxuICAgIHZhciBhYSA9IGFbMF07XG4gICAgdmFyIGFjID0gYVsyXTtcbiAgICB2YXIgYXR4ID0gYVs0XTtcbiAgICB2YXIgYWIgPSBhWzFdO1xuICAgIHZhciBhZCA9IGFbM107XG4gICAgdmFyIGF0eSA9IGFbNV07XG5cbiAgICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG4gICAgaWYgKCFkZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IGFkICogZGV0O1xuICAgIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gICAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICAgIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL2NvcmUvbWF0cml4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbXppY2NhcmQvbm9kZS10aW1zb3J0XG52YXIgREVGQVVMVF9NSU5fTUVSR0UgPSAzMjtcblxudmFyIERFRkFVTFRfTUlOX0dBTExPUElORyA9IDc7XG5cbnZhciBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCA9IDI1NjtcblxuZnVuY3Rpb24gbWluUnVuTGVuZ3RoKG4pIHtcbiAgICB2YXIgciA9IDA7XG5cbiAgICB3aGlsZSAobiA+PSBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICByIHw9IG4gJiAxO1xuICAgICAgICBuID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuICsgcjtcbn1cblxuZnVuY3Rpb24gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKSB7XG4gICAgdmFyIHJ1bkhpID0gbG8gKyAxO1xuXG4gICAgaWYgKHJ1bkhpID09PSBoaSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoY29tcGFyZShhcnJheVtydW5IaSsrXSwgYXJyYXlbbG9dKSA8IDApIHtcbiAgICAgICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgICAgICAgcnVuSGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldmVyc2VSdW4oYXJyYXksIGxvLCBydW5IaSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPj0gMCkge1xuICAgICAgICAgICAgcnVuSGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBydW5IaSAtIGxvO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlUnVuKGFycmF5LCBsbywgaGkpIHtcbiAgICBoaS0tO1xuXG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgdmFyIHQgPSBhcnJheVtsb107XG4gICAgICAgIGFycmF5W2xvKytdID0gYXJyYXlbaGldO1xuICAgICAgICBhcnJheVtoaS0tXSA9IHQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIHN0YXJ0LCBjb21wYXJlKSB7XG4gICAgaWYgKHN0YXJ0ID09PSBsbykge1xuICAgICAgICBzdGFydCsrO1xuICAgIH1cblxuICAgIGZvciAoOyBzdGFydCA8IGhpOyBzdGFydCsrKSB7XG4gICAgICAgIHZhciBwaXZvdCA9IGFycmF5W3N0YXJ0XTtcblxuICAgICAgICB2YXIgbGVmdCA9IGxvO1xuICAgICAgICB2YXIgcmlnaHQgPSBzdGFydDtcbiAgICAgICAgdmFyIG1pZDtcblxuICAgICAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgICAgICBtaWQgPSBsZWZ0ICsgcmlnaHQgPj4+IDE7XG5cbiAgICAgICAgICAgIGlmIChjb21wYXJlKHBpdm90LCBhcnJheVttaWRdKSA8IDApIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG4gPSBzdGFydCAtIGxlZnQ7XG5cbiAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIDNdID0gYXJyYXlbbGVmdCArIDJdO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIDJdID0gYXJyYXlbbGVmdCArIDFdO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIDFdID0gYXJyYXlbbGVmdF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgbl0gPSBhcnJheVtsZWZ0ICsgbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbbGVmdF0gPSBwaXZvdDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdhbGxvcExlZnQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgIHZhciBtYXhPZmZzZXQgPSAwO1xuICAgIHZhciBvZmZzZXQgPSAxO1xuXG4gICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pID4gMCkge1xuICAgICAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPiAwKSB7XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8PSAwKSB7XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gICAgfVxuXG4gICAgbGFzdE9mZnNldCsrO1xuICAgIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPiAwKSB7XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGdhbGxvcFJpZ2h0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICAgIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gMTtcblxuICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA8IDApIHtcbiAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8IDApIHtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID49IDApIHtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgICBvZmZzZXQgKz0gaGludDtcbiAgICB9XG5cbiAgICBsYXN0T2Zmc2V0Kys7XG5cbiAgICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgICAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pIDwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpIHtcbiAgICB2YXIgbWluR2FsbG9wID0gREVGQVVMVF9NSU5fR0FMTE9QSU5HO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHZhciB0bXBTdG9yYWdlTGVuZ3RoID0gREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEg7XG4gICAgdmFyIHN0YWNrTGVuZ3RoID0gMDtcbiAgICB2YXIgcnVuU3RhcnQ7XG4gICAgdmFyIHJ1bkxlbmd0aDtcbiAgICB2YXIgc3RhY2tTaXplID0gMDtcblxuICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIGlmIChsZW5ndGggPCAyICogREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEgpIHtcbiAgICAgICAgdG1wU3RvcmFnZUxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcbiAgICB9XG5cbiAgICB2YXIgdG1wID0gW107XG5cbiAgICBzdGFja0xlbmd0aCA9IGxlbmd0aCA8IDEyMCA/IDUgOiBsZW5ndGggPCAxNTQyID8gMTAgOiBsZW5ndGggPCAxMTkxNTEgPyAxOSA6IDQwO1xuXG4gICAgcnVuU3RhcnQgPSBbXTtcbiAgICBydW5MZW5ndGggPSBbXTtcblxuICAgIGZ1bmN0aW9uIHB1c2hSdW4oX3J1blN0YXJ0LCBfcnVuTGVuZ3RoKSB7XG4gICAgICAgIHJ1blN0YXJ0W3N0YWNrU2l6ZV0gPSBfcnVuU3RhcnQ7XG4gICAgICAgIHJ1bkxlbmd0aFtzdGFja1NpemVdID0gX3J1bkxlbmd0aDtcbiAgICAgICAgc3RhY2tTaXplICs9IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VSdW5zKCkge1xuICAgICAgICB3aGlsZSAoc3RhY2tTaXplID4gMSkge1xuICAgICAgICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICAgICAgICBpZiAobiA+PSAxICYmIHJ1bkxlbmd0aFtuIC0gMV0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gKyAxXSB8fCBuID49IDIgJiYgcnVuTGVuZ3RoW24gLSAyXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiAtIDFdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChydW5MZW5ndGhbbl0gPiBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXJnZUF0KG4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9yY2VNZXJnZVJ1bnMoKSB7XG4gICAgICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgICAgIGlmIChuID4gMCAmJiBydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWVyZ2VBdChuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlQXQoaSkge1xuICAgICAgICB2YXIgc3RhcnQxID0gcnVuU3RhcnRbaV07XG4gICAgICAgIHZhciBsZW5ndGgxID0gcnVuTGVuZ3RoW2ldO1xuICAgICAgICB2YXIgc3RhcnQyID0gcnVuU3RhcnRbaSArIDFdO1xuICAgICAgICB2YXIgbGVuZ3RoMiA9IHJ1bkxlbmd0aFtpICsgMV07XG5cbiAgICAgICAgcnVuTGVuZ3RoW2ldID0gbGVuZ3RoMSArIGxlbmd0aDI7XG5cbiAgICAgICAgaWYgKGkgPT09IHN0YWNrU2l6ZSAtIDMpIHtcbiAgICAgICAgICAgIHJ1blN0YXJ0W2kgKyAxXSA9IHJ1blN0YXJ0W2kgKyAyXTtcbiAgICAgICAgICAgIHJ1bkxlbmd0aFtpICsgMV0gPSBydW5MZW5ndGhbaSArIDJdO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhY2tTaXplLS07XG5cbiAgICAgICAgdmFyIGsgPSBnYWxsb3BSaWdodChhcnJheVtzdGFydDJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcbiAgICAgICAgc3RhcnQxICs9IGs7XG4gICAgICAgIGxlbmd0aDEgLT0gaztcblxuICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoMiA9IGdhbGxvcExlZnQoYXJyYXlbc3RhcnQxICsgbGVuZ3RoMSAtIDFdLCBhcnJheSwgc3RhcnQyLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGgxIDw9IGxlbmd0aDIpIHtcbiAgICAgICAgICAgIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQxICsgaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3Vyc29yMSA9IDA7XG4gICAgICAgIHZhciBjdXJzb3IyID0gc3RhcnQyO1xuICAgICAgICB2YXIgZGVzdCA9IHN0YXJ0MTtcblxuICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG4gICAgICAgIHZhciBjb3VudDEsIGNvdW50MiwgZXhpdDtcblxuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgY291bnQxID0gMDtcbiAgICAgICAgICAgIGNvdW50MiA9IDA7XG4gICAgICAgICAgICBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShhcnJheVtjdXJzb3IyXSwgdG1wW2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG4gICAgICAgICAgICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgICAgICAgICAgICBjb3VudDEgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY291bnQxID0gZ2FsbG9wUmlnaHQoYXJyYXlbY3Vyc29yMl0sIHRtcCwgY3Vyc29yMSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRlc3QgKz0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IxICs9IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvdW50MiA9IGdhbGxvcExlZnQodG1wW2N1cnNvcjFdLCBhcnJheSwgY3Vyc29yMiwgbGVuZ3RoMiwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGVzdCArPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcjIgKz0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG5cbiAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICAgICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgbWluR2FsbG9wID0gX21pbkdhbGxvcDtcblxuICAgICAgICBtaW5HYWxsb3AgPCAxICYmIChtaW5HYWxsb3AgPSAxKTtcblxuICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VMb3cgcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VIaWdoIChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQyICsgaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3Vyc29yMSA9IHN0YXJ0MSArIGxlbmd0aDEgLSAxO1xuICAgICAgICB2YXIgY3Vyc29yMiA9IGxlbmd0aDIgLSAxO1xuICAgICAgICB2YXIgZGVzdCA9IHN0YXJ0MiArIGxlbmd0aDIgLSAxO1xuICAgICAgICB2YXIgY3VzdG9tQ3Vyc29yID0gMDtcbiAgICAgICAgdmFyIGN1c3RvbURlc3QgPSAwO1xuXG4gICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBjb3VudDEgPSAwO1xuICAgICAgICAgICAgdmFyIGNvdW50MiA9IDA7XG4gICAgICAgICAgICB2YXIgZXhpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUodG1wW2N1cnNvcjJdLCBhcnJheVtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuICAgICAgICAgICAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuICAgICAgICAgICAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICAgICAgICAgICAgY291bnQxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb3VudDEgPSBsZW5ndGgxIC0gZ2FsbG9wUmlnaHQodG1wW2N1cnNvcjJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCBsZW5ndGgxIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3QgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gY291bnQxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG5cbiAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb3VudDIgPSBsZW5ndGgyIC0gZ2FsbG9wTGVmdChhcnJheVtjdXJzb3IxXSwgdG1wLCAwLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3QgLT0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IyIC09IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMiArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSB0bXBbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICAgICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgbWluR2FsbG9wID0gX21pbkdhbGxvcDtcblxuICAgICAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgICAgICAgbWluR2FsbG9wID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUhpZ2ggcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tZXJnZVJ1bnMgPSBtZXJnZVJ1bnM7XG4gICAgdGhpcy5mb3JjZU1lcmdlUnVucyA9IGZvcmNlTWVyZ2VSdW5zO1xuICAgIHRoaXMucHVzaFJ1biA9IHB1c2hSdW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNvcnQoYXJyYXksIGNvbXBhcmUsIGxvLCBoaSkge1xuICAgIGlmICghbG8pIHtcbiAgICAgICAgbG8gPSAwO1xuICAgIH1cbiAgICBpZiAoIWhpKSB7XG4gICAgICAgIGhpID0gYXJyYXkubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciByZW1haW5pbmcgPSBoaSAtIGxvO1xuXG4gICAgaWYgKHJlbWFpbmluZyA8IDIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBydW5MZW5ndGggPSAwO1xuXG4gICAgaWYgKHJlbWFpbmluZyA8IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG4gICAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuXG4gICAgdmFyIG1pblJ1biA9IG1pblJ1bkxlbmd0aChyZW1haW5pbmcpO1xuXG4gICAgZG8ge1xuICAgICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgICAgICBpZiAocnVuTGVuZ3RoIDwgbWluUnVuKSB7XG4gICAgICAgICAgICB2YXIgZm9yY2UgPSByZW1haW5pbmc7XG4gICAgICAgICAgICBpZiAoZm9yY2UgPiBtaW5SdW4pIHtcbiAgICAgICAgICAgICAgICBmb3JjZSA9IG1pblJ1bjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGxvICsgZm9yY2UsIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgICAgICAgIHJ1bkxlbmd0aCA9IGZvcmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHMucHVzaFJ1bihsbywgcnVuTGVuZ3RoKTtcbiAgICAgICAgdHMubWVyZ2VSdW5zKCk7XG5cbiAgICAgICAgcmVtYWluaW5nIC09IHJ1bkxlbmd0aDtcbiAgICAgICAgbG8gKz0gcnVuTGVuZ3RoO1xuICAgIH0gd2hpbGUgKHJlbWFpbmluZyAhPT0gMCk7XG5cbiAgICB0cy5mb3JjZU1lcmdlUnVucygpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL2NvcmUvdGltc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IERpc3BsYXlhYmxlIGZyb20gJy4vRGlzcGxheWFibGUnO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJy4uL2NvcmUvdXRpbCc7XG5pbXBvcnQgUGF0aFByb3h5IGZyb20gJy4uL2NvcmUvUGF0aFByb3h5JztcbmltcG9ydCAqIGFzIHBhdGhDb250YWluIGZyb20gJy4uL2NvbnRhaW4vcGF0aCc7XG5pbXBvcnQgUGF0dGVybiBmcm9tICcuL1BhdHRlcm4nO1xuXG52YXIgZ2V0Q2FudmFzUGF0dGVybiA9IFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm47XG5cbnZhciBhYnMgPSBNYXRoLmFicztcblxudmFyIHBhdGhQcm94eUZvckRyYXcgPSBuZXcgUGF0aFByb3h5KHRydWUpO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmZ1bmN0aW9uIFBhdGgob3B0cykge1xuICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5wYXRoID0gbnVsbDtcbn1cblxuUGF0aC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogUGF0aCxcblxuICAgIHR5cGU6ICdwYXRoJyxcblxuICAgIF9fZGlydHlQYXRoOiB0cnVlLFxuXG4gICAgc3Ryb2tlQ29udGFpblRocmVzaG9sZDogNSxcblxuICAgIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGggfHwgcGF0aFByb3h5Rm9yRHJhdztcbiAgICAgICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpO1xuICAgICAgICB2YXIgaGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKTtcbiAgICAgICAgdmFyIGZpbGwgPSBzdHlsZS5maWxsO1xuICAgICAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgICAgICB2YXIgaGFzRmlsbEdyYWRpZW50ID0gaGFzRmlsbCAmJiAhIShmaWxsLmNvbG9yU3RvcHMpO1xuICAgICAgICB2YXIgaGFzU3Ryb2tlR3JhZGllbnQgPSBoYXNTdHJva2UgJiYgISEoc3Ryb2tlLmNvbG9yU3RvcHMpO1xuICAgICAgICB2YXIgaGFzRmlsbFBhdHRlcm4gPSBoYXNGaWxsICYmICEhKGZpbGwuaW1hZ2UpO1xuICAgICAgICB2YXIgaGFzU3Ryb2tlUGF0dGVybiA9IGhhc1N0cm9rZSAmJiAhIShzdHJva2UuaW1hZ2UpO1xuXG4gICAgICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9fZGlydHkpIHtcbiAgICAgICAgICAgIHZhciByZWN0O1xuICAgICAgICAgICAgLy8gVXBkYXRlIGdyYWRpZW50IGJlY2F1c2UgYm91bmRpbmcgcmVjdCBtYXkgY2hhbmdlZFxuICAgICAgICAgICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbEdyYWRpZW50ID0gc3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBmaWxsLCByZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Ryb2tlR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIHN0cm9rZSwgcmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHRoZSBncmFkaWVudCBvciBwYXR0ZXJuXG4gICAgICAgIGlmIChoYXNGaWxsR3JhZGllbnQpIHtcbiAgICAgICAgICAgIC8vIFBFTkRJTkcgSWYgbWF5IGhhdmUgYWZmZWN0IHRoZSBzdGF0ZVxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2ZpbGxHcmFkaWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNGaWxsUGF0dGVybikge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChmaWxsLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlR3JhZGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzU3Ryb2tlUGF0dGVybikge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZ2V0Q2FudmFzUGF0dGVybi5jYWxsKHN0cm9rZSwgY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lRGFzaCA9IHN0eWxlLmxpbmVEYXNoO1xuICAgICAgICB2YXIgbGluZURhc2hPZmZzZXQgPSBzdHlsZS5saW5lRGFzaE9mZnNldDtcblxuICAgICAgICB2YXIgY3R4TGluZURhc2ggPSAhIWN0eC5zZXRMaW5lRGFzaDtcblxuICAgICAgICAvLyBVcGRhdGUgcGF0aCBzeCwgc3lcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRHbG9iYWxTY2FsZSgpO1xuICAgICAgICBwYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7XG5cbiAgICAgICAgLy8gUHJveHkgY29udGV4dFxuICAgICAgICAvLyBSZWJ1aWxkIHBhdGggaW4gZm9sbG93aW5nIDIgY2FzZXNcbiAgICAgICAgLy8gMS4gUGF0aCBpcyBkaXJ0eVxuICAgICAgICAvLyAyLiBQYXRoIG5lZWRzIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZURhc2ggc3Ryb2tpbmcuXG4gICAgICAgIC8vICAgIEluIHRoaXMgY2FzZSwgbGluZURhc2ggaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgc2F2ZWQgaW4gUGF0aFByb3h5XG4gICAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoXG4gICAgICAgICAgICB8fCAobGluZURhc2ggJiYgIWN0eExpbmVEYXNoICYmIGhhc1N0cm9rZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBwYXRoLmJlZ2luUGF0aChjdHgpO1xuXG4gICAgICAgICAgICAvLyBTZXR0aW5nIGxpbmUgZGFzaCBiZWZvcmUgYnVpbGQgcGF0aFxuICAgICAgICAgICAgaWYgKGxpbmVEYXNoICYmICFjdHhMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIHBhdGguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICAgICAgICAgIHBhdGguc2V0TGluZURhc2hPZmZzZXQobGluZURhc2hPZmZzZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIHBhdGggZGlydHkgZmxhZ1xuICAgICAgICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlcGxheSBwYXRoIGJ1aWxkaW5nXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICB0aGlzLnBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc0ZpbGwgJiYgcGF0aC5maWxsKGN0eCk7XG5cbiAgICAgICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNTdHJva2UgJiYgcGF0aC5zdHJva2UoY3R4KTtcblxuICAgICAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIC8vIFJlbW92ZSBsaW5lRGFzaFxuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgIC8vIERyYXcgcmVjdCB0ZXh0XG4gICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gV2hlbiBidW5kbGluZyBwYXRoLCBzb21lIHNoYXBlIG1heSBkZWNpZGUgaWYgdXNlIG1vdmVUbyB0byBiZWdpbiBhIG5ldyBzdWJwYXRoIG9yIGNsb3NlUGF0aFxuICAgIC8vIExpa2UgaW4gY2lyY2xlXG4gICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZUNmZywgaW5CdW5kbGUpIHt9LFxuXG4gICAgY3JlYXRlUGF0aFByb3h5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgdmFyIG5lZWRzVXBkYXRlUmVjdCA9ICFyZWN0O1xuICAgICAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwYXRoIG9uIGRlbWFuZC5cbiAgICAgICAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRQYXRoKHBhdGgsIHRoaXMuc2hhcGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuXG4gICAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgLy8gTmVlZHMgdXBkYXRlIHJlY3Qgd2l0aCBzdHJva2UgbGluZVdpZHRoIHdoZW5cbiAgICAgICAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgICAgICAgIC8vIDIuIFNoYXBlIGlzIGNoYW5nZWRcbiAgICAgICAgICAgIHZhciByZWN0V2l0aFN0cm9rZSA9IHRoaXMuX3JlY3RXaXRoU3Ryb2tlIHx8ICh0aGlzLl9yZWN0V2l0aFN0cm9rZSA9IHJlY3QuY2xvbmUoKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5IHx8IG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLmNvcHkocmVjdCk7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgTXVzdCBhZnRlciB1cGRhdGVUcmFuc2Zvcm1cbiAgICAgICAgICAgICAgICB2YXIgdyA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HLCBNaW4gbGluZSB3aWR0aCBpcyBuZWVkZWQgd2hlbiBsaW5lIGlzIGhvcml6b250YWwgb3IgdmVydGljYWxcbiAgICAgICAgICAgICAgICB2YXIgbGluZVNjYWxlID0gc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IHRoaXMuZ2V0TGluZVNjYWxlKCkgOiAxO1xuXG4gICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZXh0cmEgaG92ZXIgbGluZVdpZHRoIHdoZW4gdGhlcmUgYXJlIG5vIGZpbGxcbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlLmhhc0ZpbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgodywgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkIHx8IDQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBsaW5lIHdpZHRoXG4gICAgICAgICAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS53aWR0aCArPSB3IC8gbGluZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS5oZWlnaHQgKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UueCAtPSB3IC8gbGluZVNjYWxlIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UueSAtPSB3IC8gbGluZVNjYWxlIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiByZWN0IHdpdGggc3Ryb2tlXG4gICAgICAgICAgICByZXR1cm4gcmVjdFdpdGhTdHJva2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9LFxuXG4gICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGxvY2FsUG9zID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgeCA9IGxvY2FsUG9zWzBdO1xuICAgICAgICB5ID0gbG9jYWxQb3NbMV07XG5cbiAgICAgICAgaWYgKHJlY3QuY29udGFpbih4LCB5KSkge1xuICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gdGhpcy5wYXRoLmRhdGE7XG4gICAgICAgICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7XG4gICAgICAgICAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBleHRyYSBob3ZlciBsaW5lV2lkdGggd2hlbiB0aGVyZSBhcmUgbm8gZmlsbFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0eWxlLmhhc0ZpbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gTWF0aC5tYXgobGluZVdpZHRoLCB0aGlzLnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoQ29udGFpbi5jb250YWluU3Ryb2tlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aERhdGEsIGxpbmVXaWR0aCAvIGxpbmVTY2FsZSwgeCwgeVxuICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aENvbnRhaW4uY29udGFpbihwYXRoRGF0YSwgeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBkaXJ0eVBhdGhcbiAgICAgKi9cbiAgICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgICAgICBpZiAoZGlydHlQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIGRpcnR5UGF0aCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBtYXJrIGRpcnR5LCBub3QgbWFyayBjbGVhblxuICAgICAgICBpZiAoZGlydHlQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZGlydHlQYXRoO1xuICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuXG4gICAgICAgIC8vIFVzZWQgYXMgYSBjbGlwcGluZyBwYXRoXG4gICAgICAgIGlmICh0aGlzLl9fY2xpcFRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5fX2NsaXBUYXJnZXQuZGlydHkoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc2hhcGUnKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgICAqL1xuICAgIGFuaW1hdGVTaGFwZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc2hhcGUnLCBsb29wKTtcbiAgICB9LFxuXG4gICAgLy8gT3ZlcndyaXRlIGF0dHJLVlxuICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgaWYgKGtleSA9PT0gJ3NoYXBlJykge1xuICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgRGlzcGxheWFibGUucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFNoYXBlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAvLyBQYXRoIGZyb20gc3RyaW5nIG1heSBub3QgaGF2ZSBzaGFwZVxuICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlW25hbWVdID0ga2V5W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXJ0eSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0TGluZVNjYWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAgICAgLy8gRGV0ZXJtaW5hbnQgb2YgYG1gIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgICAgICAvLyB0cmFuc2Zvcm1hdGlvbi4gU28gaXRzIHNxdWFyZSByb290IGNhbiBiZSB1c2VkIGFzIGEgc2NhbGUgZmFjdG9yXG4gICAgICAgIC8vIGZvciB3aWR0aC5cbiAgICAgICAgcmV0dXJuIG0gJiYgYWJzKG1bMF0gLSAxKSA+IDFlLTEwICYmIGFicyhtWzNdIC0gMSkgPiAxZS0xMFxuICAgICAgICAgICAgPyBNYXRoLnNxcnQoYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pKVxuICAgICAgICAgICAgOiAxO1xuICAgIH1cbn07XG5cbi8qKlxuICog5omp5bGV5LiA5LiqIFBhdGggZWxlbWVudCwg5q+U5aaC5pif5b2i77yM5ZyG562J44CCXG4gKiBFeHRlbmQgYSBwYXRoIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLnR5cGUgUGF0aCB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5pbml0IEluaXRpYWxpemVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3BzLmJ1aWxkUGF0aCBPdmVyd3JpdGUgYnVpbGRQYXRoIG1ldGhvZFxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zdHlsZV0gRXh0ZW5kZWQgZGVmYXVsdCBzdHlsZSBjb25maWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc2hhcGVdIEV4dGVuZGVkIGRlZmF1bHQgc2hhcGUgY29uZmlnXG4gKi9cblBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIFBhdGguY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICBpZiAoZGVmYXVsdHMuc3R5bGUpIHtcbiAgICAgICAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHN0eWxlXG4gICAgICAgICAgICB0aGlzLnN0eWxlLmV4dGVuZEZyb20oZGVmYXVsdHMuc3R5bGUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHNoYXBlXG4gICAgICAgIHZhciBkZWZhdWx0U2hhcGUgPSBkZWZhdWx0cy5zaGFwZTtcbiAgICAgICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IHRoaXMuc2hhcGUgfHwge307XG4gICAgICAgICAgICB2YXIgdGhpc1NoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhIHRoaXNTaGFwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgICAgICAgICAgICAgICAmJiBkZWZhdWx0U2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1NoYXBlW25hbWVdID0gZGVmYXVsdFNoYXBlW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHRzLmluaXQgJiYgZGVmYXVsdHMuaW5pdC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoU3ViLCBQYXRoKTtcblxuICAgIC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgLy8gRXh0ZW5kaW5nIHByb3RvdHlwZSB2YWx1ZXMgYW5kIG1ldGhvZHNcbiAgICAgICAgaWYgKG5hbWUgIT09ICdzdHlsZScgJiYgbmFtZSAhPT0gJ3NoYXBlJykge1xuICAgICAgICAgICAgU3ViLnByb3RvdHlwZVtuYW1lXSA9IGRlZmF1bHRzW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFN1Yjtcbn07XG5cbnpyVXRpbC5pbmhlcml0cyhQYXRoLCBEaXNwbGF5YWJsZSk7XG5cbmV4cG9ydCBkZWZhdWx0IFBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL2dyYXBoaWMvUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgUGF0dGVybiA9IGZ1bmN0aW9uIChpbWFnZSwgcmVwZWF0KSB7XG4gICAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAgIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7aW1hZ2U6IC4uLn1gLCB3aGVyZSB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cblxuICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICB0aGlzLnJlcGVhdCA9IHJlcGVhdDtcblxuICAgIC8vIENhbiBiZSBjbG9uZWRcbiAgICB0aGlzLnR5cGUgPSAncGF0dGVybic7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0aGlzLmltYWdlLCB0aGlzLnJlcGVhdCB8fCAncmVwZWF0Jyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQYXR0ZXJuO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9ncmFwaGljL1BhdHRlcm4uanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxudmFyIFNUWUxFX0NPTU1PTl9QUk9QUyA9IFtcbiAgICBbJ3NoYWRvd0JsdXInLCAwXSwgWydzaGFkb3dPZmZzZXRYJywgMF0sIFsnc2hhZG93T2Zmc2V0WScsIDBdLCBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSxcbiAgICBbJ2xpbmVDYXAnLCAnYnV0dCddLCBbJ2xpbmVKb2luJywgJ21pdGVyJ10sIFsnbWl0ZXJMaW1pdCcsIDEwXVxuXTtcblxuLy8gdmFyIFNIQURPV19QUk9QUyA9IFNUWUxFX0NPTU1PTl9QUk9QUy5zbGljZSgwLCA0KTtcbi8vIHZhciBMSU5FX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDQpO1xuXG52YXIgU3R5bGUgPSBmdW5jdGlvbiAob3B0cywgaG9zdCkge1xuICAgIHRoaXMuZXh0ZW5kRnJvbShvcHRzLCBmYWxzZSk7XG4gICAgdGhpcy5ob3N0ID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVhckdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gICAgdmFyIHggPSBvYmoueCA9PSBudWxsID8gMCA6IG9iai54O1xuICAgIHZhciB4MiA9IG9iai54MiA9PSBudWxsID8gMSA6IG9iai54MjtcbiAgICB2YXIgeSA9IG9iai55ID09IG51bGwgPyAwIDogb2JqLnk7XG4gICAgdmFyIHkyID0gb2JqLnkyID09IG51bGwgPyAwIDogb2JqLnkyO1xuXG4gICAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgICAgIHggPSB4ICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICAgICAgeDIgPSB4MiAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgICAgIHkgPSB5ICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgIHkyID0geTIgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeDIsIHkyKTtcblxuICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmFkaWFsR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICB2YXIgbWluID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG5cbiAgICB2YXIgeCA9IG9iai54ID09IG51bGwgPyAwLjUgOiBvYmoueDtcbiAgICB2YXIgeSA9IG9iai55ID09IG51bGwgPyAwLjUgOiBvYmoueTtcbiAgICB2YXIgciA9IG9iai5yID09IG51bGwgPyAwLjUgOiBvYmoucjtcbiAgICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICAgICAgeCA9IHggKiB3aWR0aCArIHJlY3QueDtcbiAgICAgICAgeSA9IHkgKiBoZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgIHIgPSByICogbWluO1xuICAgIH1cblxuICAgIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCB4LCB5LCByKTtcblxuICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbn1cblxuXG5TdHlsZS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogU3R5bGUsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX1cbiAgICAgKi9cbiAgICBob3N0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBmaWxsOiAnIzAwMCcsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0cm9rZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgb3BhY2l0eTogMSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICBsaW5lRGFzaDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGluZURhc2hPZmZzZXQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNoYWRvd0JsdXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNoYWRvd09mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNoYWRvd09mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpbmVXaWR0aDogMSxcblxuICAgIC8qKlxuICAgICAqIElmIHN0cm9rZSBpZ25vcmUgc2NhbGVcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdHJva2VOb1NjYWxlOiBmYWxzZSxcblxuICAgIC8vIEJvdW5kaW5nIHJlY3QgdGV4dCBjb25maWd1cmF0aW9uXG4gICAgLy8gTm90IGFmZmVjdGVkIGJ5IGVsZW1lbnQgdHJhbnNmb3JtXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0ZXh0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSWYgYGZvbnRTaXplYCBvciBgZm9udEZhbWlseWAgZXhpc3RzLCBgZm9udGAgd2lsbCBiZSByZXNldCBieVxuICAgICAqIGBmb250U2l6ZWAsIGBmb250U3R5bGVgLCBgZm9udFdlaWdodGAsIGBmb250RmFtaWx5YC5cbiAgICAgKiBTbyBkbyBub3QgdmlzaXQgaXQgZGlyZWN0bHkgaW4gdXBwZXIgYXBwbGljYXRpb24gKGxpa2UgZWNoYXJ0cyksXG4gICAgICogYnV0IHVzZSBgY29udGFpbi90ZXh0I21ha2VGb250YCBpbnN0ZWFkLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9udDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIGZvbnQuIFVzZSBmb250IHBsZWFzZS5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGV4dEZvbnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBmb250U3R5bGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBmb250V2VpZ2h0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgICAqIFNob3VsZCBiZSAxMiBidXQgbm90ICcxMnB4Jy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZvbnRTaXplOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9udEZhbWlseTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFJlc2VydmVkIGZvciBzcGVjaWFsIGZ1bmN0aW5hbGl0eSwgbGlrZSAnaHInLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGV4dFRhZzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGV4dEZpbGw6ICcjMDAwJyxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGV4dFN0cm9rZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGV4dFdpZHRoOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT25seSBmb3IgdGV4dEJhY2tncm91bmQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0ZXh0SGVpZ2h0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogdGV4dFN0cm9rZSBtYXkgYmUgc2V0IGFzIHNvbWUgY29sb3IgYXMgYSBkZWZhdWx0XG4gICAgICogdmFsdWUgaW4gdXBwZXIgYXBwbGljYWlvbiwgd2hlcmUgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBvZiB0ZXh0U3Ryb2tlV2lkdGggc2hvdWxkIGJlIDAgdG8gbWFrZSBzdXJlIHRoYXRcbiAgICAgKiB1c2VyIGNhbiBjaG9vc2UgdG8gZG8gbm90IHVzZSB0ZXh0IHN0cm9rZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRleHRTdHJva2VXaWR0aDogMCxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGV4dExpbmVIZWlnaHQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiAnaW5zaWRlJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSdcbiAgICAgKiBbeCwgeV1cbiAgICAgKiBCYXNlZCBvbiB4LCB5IG9mIHJlY3QuXG4gICAgICogQHR5cGUge3N0cmluZ3xBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCAnaW5zaWRlJ1xuICAgICAqL1xuICAgIHRleHRQb3NpdGlvbjogJ2luc2lkZScsXG5cbiAgICAvKipcbiAgICAgKiBJZiBub3Qgc3BlY2lmaWVkLCB1c2UgdGhlIGJvdW5kaW5nUmVjdCBvZiBhIGBkaXNwbGF5YWJsZWAuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0ZXh0UmVjdDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFt4LCB5XVxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0ZXh0T2Zmc2V0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0ZXh0QWxpZ246IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRleHRWZXJ0aWNhbEFsaWduOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0ZXh0RGlzdGFuY2U6IDUsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRleHRTaGFkb3dDb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGV4dFNoYWRvd0JsdXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRleHRTaGFkb3dPZmZzZXRYOiAwLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0ZXh0U2hhZG93T2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGV4dEJveFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0ZXh0Qm94U2hhZG93Qmx1cjogMCxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGV4dEJveFNoYWRvd09mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRleHRCb3hTaGFkb3dPZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0cmFuc2Zvcm0gdGV4dC5cbiAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdHJhbnNmb3JtVGV4dDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IHJvdGF0ZSBhcm91bmQgcG9zaXRpb24gb2YgUGF0aCBvciBJbWFnZVxuICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQgYW5kIHRyYW5zZm9ybVRleHQgaXMgZmFsc2UuXG4gICAgICovXG4gICAgdGV4dFJvdGF0aW9uOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBvcmlnaW4gb2YgdGV4dCByb3RhdGlvbiwgbGlrZSBbMTAsIDQwXS5cbiAgICAgKiBCYXNlZCBvbiB4LCB5IG9mIHJlY3QuXG4gICAgICogVXNlZnVsIGluIGxhYmVsIHJvdGF0aW9uIG9mIGNpcmN1bGFyIHN5bWJvbC5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIG9yaWdpbiBpcyB0ZXh0UG9zaXRpb24uXG4gICAgICogQ2FuIGJlICdjZW50ZXInLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdGV4dE9yaWdpbjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGV4dEJhY2tncm91bmRDb2xvcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGV4dEJvcmRlckNvbG9yOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0ZXh0Qm9yZGVyV2lkdGg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRleHRCb3JkZXJSYWRpdXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgYDJgIG9yIGBbMiwgNF1gIG9yIGBbMiwgMywgNCwgNV1gXG4gICAgICogQHR5cGUge251bWJlcnxBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0ZXh0UGFkZGluZzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRleHQgc3R5bGVzIGZvciByaWNoIHRleHQuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICByaWNoOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICoge291dGVyV2lkdGgsIG91dGVySGVpZ2h0LCBlbGxpcHNpcywgcGxhY2Vob2xkZXJ9XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0cnVuY2F0ZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBibGVuZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKi9cbiAgICBiaW5kOiBmdW5jdGlvbiAoY3R4LCBlbCwgcHJldkVsKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXM7XG4gICAgICAgIHZhciBwcmV2U3R5bGUgPSBwcmV2RWwgJiYgcHJldkVsLnN0eWxlO1xuICAgICAgICB2YXIgZmlyc3REcmF3ID0gIXByZXZTdHlsZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgICAgICAgICB2YXIgc3R5bGVOYW1lID0gcHJvcFswXTtcblxuICAgICAgICAgICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZVtzdHlsZU5hbWVdICE9PSBwcmV2U3R5bGVbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIEludmFsaWQgcHJvcGVydHkgdmFsdWUgd2lsbCBjYXVzZSBzdHlsZSBsZWFrIGZyb20gcHJldmlvdXMgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBjdHhbc3R5bGVOYW1lXSA9IHN0eWxlW3N0eWxlTmFtZV0gfHwgcHJvcFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLmZpbGwgIT09IHByZXZTdHlsZS5maWxsKSkge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmZpbGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUuc3Ryb2tlICE9PSBwcmV2U3R5bGUuc3Ryb2tlKSkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLm9wYWNpdHkgIT09IHByZXZTdHlsZS5vcGFjaXR5KSkge1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUub3BhY2l0eSA9PSBudWxsID8gMSA6IHN0eWxlLm9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5ibGVuZCAhPT0gcHJldlN0eWxlLmJsZW5kKSkge1xuICAgICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHN0eWxlLmJsZW5kIHx8ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIC8gKFxuICAgICAgICAgICAgICAgICh0aGlzLnN0cm9rZU5vU2NhbGUgJiYgZWwgJiYgZWwuZ2V0TGluZVNjYWxlKSA/IGVsLmdldExpbmVTY2FsZSgpIDogMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYXNGaWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWxsID0gdGhpcy5maWxsO1xuICAgICAgICByZXR1cm4gZmlsbCAhPSBudWxsICYmIGZpbGwgIT09ICdub25lJztcbiAgICB9LFxuXG4gICAgaGFzU3Ryb2tlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHJva2UgPSB0aGlzLnN0cm9rZTtcbiAgICAgICAgcmV0dXJuIHN0cm9rZSAhPSBudWxsICYmIHN0cm9rZSAhPT0gJ25vbmUnICYmIHRoaXMubGluZVdpZHRoID4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIGZyb20gb3RoZXIgc3R5bGVcbiAgICAgKiBAcGFyYW0ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gb3RoZXJTdHlsZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcndyaXRlIHRydWU6IG92ZXJ3cmlydGUgYW55IHdheS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZTogb3ZlcndyaXRlIG9ubHkgd2hlbiAhdGFyZ2V0Lmhhc093blByb3BlcnR5XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJzOiBvdmVyd3JpdGUgd2hlbiBwcm9wZXJ0eSBpcyBub3QgbnVsbC91bmRlZmluZWQuXG4gICAgICovXG4gICAgZXh0ZW5kRnJvbTogZnVuY3Rpb24gKG90aGVyU3R5bGUsIG92ZXJ3cml0ZSkge1xuICAgICAgICBpZiAob3RoZXJTdHlsZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvdGhlclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyU3R5bGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgJiYgKG92ZXJ3cml0ZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJ3cml0ZSA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAhdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG90aGVyU3R5bGVbbmFtZV0gIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBvdGhlclN0eWxlW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCYXRjaCBzZXR0aW5nIHN0eWxlIHdpdGggYSBnaXZlbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IG9ialxuICAgICAqIEBwYXJhbSB7Kn0gW29ial1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpc1tvYmpdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4dGVuZEZyb20ob2JqLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbG9uZVxuICAgICAqIEByZXR1cm4ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdTdHlsZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgIG5ld1N0eWxlLmV4dGVuZEZyb20odGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBuZXdTdHlsZTtcbiAgICB9LFxuXG4gICAgZ2V0R3JhZGllbnQ6IGZ1bmN0aW9uIChjdHgsIG9iaiwgcmVjdCkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqLnR5cGUgPT09ICdyYWRpYWwnID8gY3JlYXRlUmFkaWFsR3JhZGllbnQgOiBjcmVhdGVMaW5lYXJHcmFkaWVudDtcbiAgICAgICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gbWV0aG9kKGN0eCwgb2JqLCByZWN0KTtcbiAgICAgICAgdmFyIGNvbG9yU3RvcHMgPSBvYmouY29sb3JTdG9wcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvclN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3AoXG4gICAgICAgICAgICAgICAgY29sb3JTdG9wc1tpXS5vZmZzZXQsIGNvbG9yU3RvcHNbaV0uY29sb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xuICAgIH1cblxufTtcblxudmFyIHN0eWxlUHJvdG8gPSBTdHlsZS5wcm90b3R5cGU7XG5mb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gU1RZTEVfQ09NTU9OX1BST1BTW2ldO1xuICAgIGlmICghKHByb3BbMF0gaW4gc3R5bGVQcm90bykpIHtcbiAgICAgICAgc3R5bGVQcm90b1twcm9wWzBdXSA9IHByb3BbMV07XG4gICAgfVxufVxuXG4vLyBQcm92aWRlIGZvciBvdGhlcnNcblN0eWxlLmdldEdyYWRpZW50ID0gc3R5bGVQcm90by5nZXRHcmFkaWVudDtcblxuZXhwb3J0IGRlZmF1bHQgU3R5bGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL2dyYXBoaWMvU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuaW1wb3J0IHtcbiAgICByZXRyaWV2ZTIsXG4gICAgcmV0cmlldmUzLFxuICAgIGVhY2gsXG4gICAgbm9ybWFsaXplQ3NzQXJyYXksXG4gICAgaXNTdHJpbmcsXG4gICAgaXNPYmplY3Rcbn0gZnJvbSAnLi4vLi4vY29yZS91dGlsJztcbmltcG9ydCAqIGFzIHRleHRDb250YWluIGZyb20gJy4uLy4uL2NvbnRhaW4vdGV4dCc7XG5pbXBvcnQgKiBhcyByb3VuZFJlY3RIZWxwZXIgZnJvbSAnLi9yb3VuZFJlY3QnO1xuaW1wb3J0ICogYXMgaW1hZ2VIZWxwZXIgZnJvbSAnLi9pbWFnZSc7XG5cbi8vIFRPRE86IEhhdmUgbm90IHN1cHBvcnQgJ3N0YXJ0JywgJ2VuZCcgeWV0LlxudmFyIFZBTElEX1RFWFRfQUxJR04gPSB7bGVmdDogMSwgcmlnaHQ6IDEsIGNlbnRlcjogMX07XG52YXIgVkFMSURfVEVYVF9WRVJUSUNBTF9BTElHTiA9IHt0b3A6IDEsIGJvdHRvbTogMSwgbWlkZGxlOiAxfTtcblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IHN0eWxlXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBUaGUgaW5wdXQgc3R5bGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUpIHtcbiAgICBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gICAgZWFjaChzdHlsZS5yaWNoLCBub3JtYWxpemVTdHlsZSk7XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZShzdHlsZSkge1xuICAgIGlmIChzdHlsZSkge1xuXG4gICAgICAgIHN0eWxlLmZvbnQgPSB0ZXh0Q29udGFpbi5tYWtlRm9udChzdHlsZSk7XG5cbiAgICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgICAgdGV4dEFsaWduID09PSAnbWlkZGxlJyAmJiAodGV4dEFsaWduID0gJ2NlbnRlcicpO1xuICAgICAgICBzdHlsZS50ZXh0QWxpZ24gPSAoXG4gICAgICAgICAgICB0ZXh0QWxpZ24gPT0gbnVsbCB8fCBWQUxJRF9URVhUX0FMSUdOW3RleHRBbGlnbl1cbiAgICAgICAgKSA/IHRleHRBbGlnbiA6ICdsZWZ0JztcblxuICAgICAgICAvLyBDb21wYXRpYmxlIHdpdGggdGV4dEJhc2VsaW5lLlxuICAgICAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiB8fCBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID09PSAnY2VudGVyJyAmJiAodGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJyk7XG4gICAgICAgIHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduID0gKFxuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPT0gbnVsbCB8fCBWQUxJRF9URVhUX1ZFUlRJQ0FMX0FMSUdOW3RleHRWZXJ0aWNhbEFsaWduXVxuICAgICAgICApID8gdGV4dFZlcnRpY2FsQWxpZ24gOiAndG9wJztcblxuICAgICAgICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgICAgICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICAgICAgICBzdHlsZS50ZXh0UGFkZGluZyA9IG5vcm1hbGl6ZUNzc0FycmF5KHN0eWxlLnRleHRQYWRkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBzdHlsZVxuICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gW3JlY3RdIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogICAgICAgICAgICAgICAgICBJZiBzZXQgZmFsc2UsIHJlY3QgdGV4dCBpcyBub3QgdXNlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSB7XG4gICAgc3R5bGUucmljaFxuICAgICAgICA/IHJlbmRlclJpY2hUZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdClcbiAgICAgICAgOiByZW5kZXJQbGFpblRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUGxhaW5UZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCkge1xuICAgIHZhciBmb250ID0gc2V0Q3R4KGN0eCwgJ2ZvbnQnLCBzdHlsZS5mb250IHx8IHRleHRDb250YWluLkRFRkFVTFRfRk9OVCk7XG5cbiAgICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcblxuICAgIHZhciBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2s7XG4gICAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHkpIHtcbiAgICAgICAgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VQbGFpblRleHQoXG4gICAgICAgICAgICB0ZXh0LCBmb250LCB0ZXh0UGFkZGluZywgc3R5bGUudHJ1bmNhdGVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQ7XG5cbiAgICB2YXIgdGV4dExpbmVzID0gY29udGVudEJsb2NrLmxpbmVzO1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gY29udGVudEJsb2NrLmxpbmVIZWlnaHQ7XG5cbiAgICB2YXIgYm94UG9zID0gZ2V0Qm94UG9zaXRpb24ob3V0ZXJIZWlnaHQsIHN0eWxlLCByZWN0KTtcbiAgICB2YXIgYmFzZVggPSBib3hQb3MuYmFzZVg7XG4gICAgdmFyIGJhc2VZID0gYm94UG9zLmJhc2VZO1xuICAgIHZhciB0ZXh0QWxpZ24gPSBib3hQb3MudGV4dEFsaWduO1xuICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IGJveFBvcy50ZXh0VmVydGljYWxBbGlnbjtcblxuICAgIC8vIE9yaWdpbiBvZiB0ZXh0Um90YXRpb24gc2hvdWxkIGJlIHRoZSBiYXNlIHBvaW50IG9mIHRleHQgZHJhd2luZy5cbiAgICBhcHBseVRleHRSb3RhdGlvbihjdHgsIHN0eWxlLCByZWN0LCBiYXNlWCwgYmFzZVkpO1xuXG4gICAgdmFyIGJveFkgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WShiYXNlWSwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgICB2YXIgdGV4dFggPSBiYXNlWDtcbiAgICB2YXIgdGV4dFkgPSBib3hZO1xuXG4gICAgdmFyIG5lZWREcmF3QmcgPSBuZWVkRHJhd0JhY2tncm91bmQoc3R5bGUpO1xuICAgIGlmIChuZWVkRHJhd0JnIHx8IHRleHRQYWRkaW5nKSB7XG4gICAgICAgIC8vIENvbnNpZGVyIHBlcmZvcm1hbmNlLCBkbyBub3QgY2FsbCBnZXRUZXh0V2lkdGggdXRpbCBuZWNlc3NhcnkuXG4gICAgICAgIHZhciB0ZXh0V2lkdGggPSB0ZXh0Q29udGFpbi5nZXRXaWR0aCh0ZXh0LCBmb250KTtcbiAgICAgICAgdmFyIG91dGVyV2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgICAgIHRleHRQYWRkaW5nICYmIChvdXRlcldpZHRoICs9IHRleHRQYWRkaW5nWzFdICsgdGV4dFBhZGRpbmdbM10pO1xuICAgICAgICB2YXIgYm94WCA9IHRleHRDb250YWluLmFkanVzdFRleHRYKGJhc2VYLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuXG4gICAgICAgIG5lZWREcmF3QmcgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHN0eWxlLCBib3hYLCBib3hZLCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG5cbiAgICAgICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICAgICAgICB0ZXh0WCA9IGdldFRleHRYRm9yUGFkZGluZyhiYXNlWCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZyk7XG4gICAgICAgICAgICB0ZXh0WSArPSB0ZXh0UGFkZGluZ1swXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEN0eChjdHgsICd0ZXh0QWxpZ24nLCB0ZXh0QWxpZ24gfHwgJ2xlZnQnKTtcbiAgICAvLyBGb3JjZSBiYXNlbGluZSB0byBiZSBcIm1pZGRsZVwiLiBPdGhlcndpc2UsIGlmIHVzaW5nIFwidG9wXCIsIHRoZVxuICAgIC8vIHRleHQgd2lsbCBvZmZzZXQgZG93bndhcmQgYSBsaXR0bGUgYml0IGluIGZvbnQgXCJNaWNyb3NvZnQgWWFIZWlcIi5cbiAgICBzZXRDdHgoY3R4LCAndGV4dEJhc2VsaW5lJywgJ21pZGRsZScpO1xuXG4gICAgLy8gQWx3YXlzIHNldCBzaGFkb3dCbHVyIGFuZCBzaGFkb3dPZmZzZXQgdG8gYXZvaWQgbGVhayBmcm9tIGRpc3BsYXlhYmxlLlxuICAgIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgc3R5bGUudGV4dFNoYWRvd0JsdXIgfHwgMCk7XG4gICAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgc3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICAgIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRYJywgc3R5bGUudGV4dFNoYWRvd09mZnNldFggfHwgMCk7XG4gICAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSB8fCAwKTtcblxuICAgIC8vIGB0ZXh0QmFzZWxpbmVgIGlzIHNldCBhcyAnbWlkZGxlJy5cbiAgICB0ZXh0WSArPSBsaW5lSGVpZ2h0IC8gMjtcblxuICAgIHZhciB0ZXh0U3Ryb2tlV2lkdGggPSBzdHlsZS50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgdmFyIHRleHRTdHJva2UgPSBnZXRTdHJva2Uoc3R5bGUudGV4dFN0cm9rZSwgdGV4dFN0cm9rZVdpZHRoKTtcbiAgICB2YXIgdGV4dEZpbGwgPSBnZXRGaWxsKHN0eWxlLnRleHRGaWxsKTtcblxuICAgIGlmICh0ZXh0U3Ryb2tlKSB7XG4gICAgICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICAgICAgICBzZXRDdHgoY3R4LCAnc3Ryb2tlU3R5bGUnLCB0ZXh0U3Ryb2tlKTtcbiAgICB9XG4gICAgaWYgKHRleHRGaWxsKSB7XG4gICAgICAgIHNldEN0eChjdHgsICdmaWxsU3R5bGUnLCB0ZXh0RmlsbCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cbiAgICAgICAgdGV4dFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dCh0ZXh0TGluZXNbaV0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgIHRleHRGaWxsICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJSaWNoVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpIHtcbiAgICB2YXIgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrO1xuXG4gICAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHkpIHtcbiAgICAgICAgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VSaWNoVGV4dCh0ZXh0LCBzdHlsZSk7XG4gICAgfVxuXG4gICAgZHJhd1JpY2hUZXh0KGhvc3RFbCwgY3R4LCBjb250ZW50QmxvY2ssIHN0eWxlLCByZWN0KTtcbn1cblxuZnVuY3Rpb24gZHJhd1JpY2hUZXh0KGhvc3RFbCwgY3R4LCBjb250ZW50QmxvY2ssIHN0eWxlLCByZWN0KSB7XG4gICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRlbnRCbG9jay53aWR0aDtcbiAgICB2YXIgb3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay5vdXRlcldpZHRoO1xuICAgIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcblxuICAgIHZhciBib3hQb3MgPSBnZXRCb3hQb3NpdGlvbihvdXRlckhlaWdodCwgc3R5bGUsIHJlY3QpO1xuICAgIHZhciBiYXNlWCA9IGJveFBvcy5iYXNlWDtcbiAgICB2YXIgYmFzZVkgPSBib3hQb3MuYmFzZVk7XG4gICAgdmFyIHRleHRBbGlnbiA9IGJveFBvcy50ZXh0QWxpZ247XG4gICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gYm94UG9zLnRleHRWZXJ0aWNhbEFsaWduO1xuXG4gICAgLy8gT3JpZ2luIG9mIHRleHRSb3RhdGlvbiBzaG91bGQgYmUgdGhlIGJhc2UgcG9pbnQgb2YgdGV4dCBkcmF3aW5nLlxuICAgIGFwcGx5VGV4dFJvdGF0aW9uKGN0eCwgc3R5bGUsIHJlY3QsIGJhc2VYLCBiYXNlWSk7XG5cbiAgICB2YXIgYm94WCA9IHRleHRDb250YWluLmFkanVzdFRleHRYKGJhc2VYLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICAgIHZhciBib3hZID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFkoYmFzZVksIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gICAgdmFyIHhMZWZ0ID0gYm94WDtcbiAgICB2YXIgbGluZVRvcCA9IGJveFk7XG4gICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICAgIHhMZWZ0ICs9IHRleHRQYWRkaW5nWzNdO1xuICAgICAgICBsaW5lVG9wICs9IHRleHRQYWRkaW5nWzBdO1xuICAgIH1cbiAgICB2YXIgeFJpZ2h0ID0geExlZnQgKyBjb250ZW50V2lkdGg7XG5cbiAgICBuZWVkRHJhd0JhY2tncm91bmQoc3R5bGUpICYmIGRyYXdCYWNrZ3JvdW5kKFxuICAgICAgICBob3N0RWwsIGN0eCwgc3R5bGUsIGJveFgsIGJveFksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0XG4gICAgKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEJsb2NrLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gY29udGVudEJsb2NrLmxpbmVzW2ldO1xuICAgICAgICB2YXIgdG9rZW5zID0gbGluZS50b2tlbnM7XG4gICAgICAgIHZhciB0b2tlbkNvdW50ID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBsaW5lLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciB1c2VkV2lkdGggPSBsaW5lLndpZHRoO1xuXG4gICAgICAgIHZhciBsZWZ0SW5kZXggPSAwO1xuICAgICAgICB2YXIgbGluZVhMZWZ0ID0geExlZnQ7XG4gICAgICAgIHZhciBsaW5lWFJpZ2h0ID0geFJpZ2h0O1xuICAgICAgICB2YXIgcmlnaHRJbmRleCA9IHRva2VuQ291bnQgLSAxO1xuICAgICAgICB2YXIgdG9rZW47XG5cbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgbGVmdEluZGV4IDwgdG9rZW5Db3VudFxuICAgICAgICAgICAgJiYgKHRva2VuID0gdG9rZW5zW2xlZnRJbmRleF0sICF0b2tlbi50ZXh0QWxpZ24gfHwgdG9rZW4udGV4dEFsaWduID09PSAnbGVmdCcpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWExlZnQsICdsZWZ0Jyk7XG4gICAgICAgICAgICB1c2VkV2lkdGggLT0gdG9rZW4ud2lkdGg7XG4gICAgICAgICAgICBsaW5lWExlZnQgKz0gdG9rZW4ud2lkdGg7XG4gICAgICAgICAgICBsZWZ0SW5kZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgIHJpZ2h0SW5kZXggPj0gMFxuICAgICAgICAgICAgJiYgKHRva2VuID0gdG9rZW5zW3JpZ2h0SW5kZXhdLCB0b2tlbi50ZXh0QWxpZ24gPT09ICdyaWdodCcpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWFJpZ2h0LCAncmlnaHQnKTtcbiAgICAgICAgICAgIHVzZWRXaWR0aCAtPSB0b2tlbi53aWR0aDtcbiAgICAgICAgICAgIGxpbmVYUmlnaHQgLT0gdG9rZW4ud2lkdGg7XG4gICAgICAgICAgICByaWdodEluZGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgb3RoZXIgdG9rZW5zIGFyZSBwbGFjZWQgYXMgdGV4dEFsaWduICdjZW50ZXInIGlmIHRoZXJlIGlzIGVub3VnaCBzcGFjZS5cbiAgICAgICAgbGluZVhMZWZ0ICs9IChjb250ZW50V2lkdGggLSAobGluZVhMZWZ0IC0geExlZnQpIC0gKHhSaWdodCAtIGxpbmVYUmlnaHQpIC0gdXNlZFdpZHRoKSAvIDI7XG4gICAgICAgIHdoaWxlIChsZWZ0SW5kZXggPD0gcmlnaHRJbmRleCkge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbbGVmdEluZGV4XTtcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIHdpZHRoIHNwZWNpZmllZCBieSB1c2VyLCB1c2UgJ2NlbnRlcicgcmF0aGVyIHRoYW4gJ2xlZnQnLlxuICAgICAgICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWExlZnQgKyB0b2tlbi53aWR0aCAvIDIsICdjZW50ZXInKTtcbiAgICAgICAgICAgIGxpbmVYTGVmdCArPSB0b2tlbi53aWR0aDtcbiAgICAgICAgICAgIGxlZnRJbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZVRvcCArPSBsaW5lSGVpZ2h0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgeCwgeSkge1xuICAgIC8vIHRleHRSb3RhdGlvbiBvbmx5IGFwcGx5IGluIFJlY3RUZXh0LlxuICAgIGlmIChyZWN0ICYmIHN0eWxlLnRleHRSb3RhdGlvbikge1xuICAgICAgICB2YXIgb3JpZ2luID0gc3R5bGUudGV4dE9yaWdpbjtcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHggPSByZWN0LndpZHRoIC8gMiArIHJlY3QueDtcbiAgICAgICAgICAgIHkgPSByZWN0LmhlaWdodCAvIDIgKyByZWN0Lnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICB4ID0gb3JpZ2luWzBdICsgcmVjdC54O1xuICAgICAgICAgICAgeSA9IG9yaWdpblsxXSArIHJlY3QueTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgIC8vIFBvc2l0aXZlOiBhbnRpY2xvY2t3aXNlXG4gICAgICAgIGN0eC5yb3RhdGUoLXN0eWxlLnRleHRSb3RhdGlvbik7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgeCwgdGV4dEFsaWduKSB7XG4gICAgdmFyIHRva2VuU3R5bGUgPSBzdHlsZS5yaWNoW3Rva2VuLnN0eWxlTmFtZV0gfHwge307XG5cbiAgICAvLyAnY3R4LnRleHRCYXNlbGluZScgaXMgYWx3YXlzIHNldCBhcyAnbWlkZGxlJywgZm9yIHNha2Ugb2ZcbiAgICAvLyB0aGUgYmlhcyBvZiBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHRva2VuLnRleHRWZXJ0aWNhbEFsaWduO1xuICAgIHZhciB5ID0gbGluZVRvcCArIGxpbmVIZWlnaHQgLyAyO1xuICAgIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeSA9IGxpbmVUb3AgKyB0b2tlbi5oZWlnaHQgLyAyO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgeSA9IGxpbmVUb3AgKyBsaW5lSGVpZ2h0IC0gdG9rZW4uaGVpZ2h0IC8gMjtcbiAgICB9XG5cbiAgICAhdG9rZW4uaXNMaW5lSG9sZGVyICYmIG5lZWREcmF3QmFja2dyb3VuZCh0b2tlblN0eWxlKSAmJiBkcmF3QmFja2dyb3VuZChcbiAgICAgICAgaG9zdEVsLFxuICAgICAgICBjdHgsXG4gICAgICAgIHRva2VuU3R5bGUsXG4gICAgICAgIHRleHRBbGlnbiA9PT0gJ3JpZ2h0J1xuICAgICAgICAgICAgPyB4IC0gdG9rZW4ud2lkdGhcbiAgICAgICAgICAgIDogdGV4dEFsaWduID09PSAnY2VudGVyJ1xuICAgICAgICAgICAgPyB4IC0gdG9rZW4ud2lkdGggLyAyXG4gICAgICAgICAgICA6IHgsXG4gICAgICAgIHkgLSB0b2tlbi5oZWlnaHQgLyAyLFxuICAgICAgICB0b2tlbi53aWR0aCxcbiAgICAgICAgdG9rZW4uaGVpZ2h0XG4gICAgKTtcblxuICAgIHZhciB0ZXh0UGFkZGluZyA9IHRva2VuLnRleHRQYWRkaW5nO1xuICAgIGlmICh0ZXh0UGFkZGluZykge1xuICAgICAgICB4ID0gZ2V0VGV4dFhGb3JQYWRkaW5nKHgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpO1xuICAgICAgICB5IC09IHRva2VuLmhlaWdodCAvIDIgLSB0ZXh0UGFkZGluZ1syXSAtIHRva2VuLnRleHRIZWlnaHQgLyAyO1xuICAgIH1cblxuICAgIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd0JsdXIsIHN0eWxlLnRleHRTaGFkb3dCbHVyLCAwKSk7XG4gICAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgdG9rZW5TdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgc3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICAgIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRYJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd09mZnNldFgsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYLCAwKSk7XG4gICAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSwgc3R5bGUudGV4dFNoYWRvd09mZnNldFksIDApKTtcblxuICAgIHNldEN0eChjdHgsICd0ZXh0QWxpZ24nLCB0ZXh0QWxpZ24pO1xuICAgIC8vIEZvcmNlIGJhc2VsaW5lIHRvIGJlIFwibWlkZGxlXCIuIE90aGVyd2lzZSwgaWYgdXNpbmcgXCJ0b3BcIiwgdGhlXG4gICAgLy8gdGV4dCB3aWxsIG9mZnNldCBkb3dud2FyZCBhIGxpdHRsZSBiaXQgaW4gZm9udCBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuICAgIHNldEN0eChjdHgsICd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7XG5cbiAgICBzZXRDdHgoY3R4LCAnZm9udCcsIHRva2VuLmZvbnQgfHwgdGV4dENvbnRhaW4uREVGQVVMVF9GT05UKTtcblxuICAgIHZhciB0ZXh0U3Ryb2tlID0gZ2V0U3Ryb2tlKHRva2VuU3R5bGUudGV4dFN0cm9rZSB8fCBzdHlsZS50ZXh0U3Ryb2tlLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICAgIHZhciB0ZXh0RmlsbCA9IGdldEZpbGwodG9rZW5TdHlsZS50ZXh0RmlsbCB8fCBzdHlsZS50ZXh0RmlsbCk7XG4gICAgdmFyIHRleHRTdHJva2VXaWR0aCA9IHJldHJpZXZlMih0b2tlblN0eWxlLnRleHRTdHJva2VXaWR0aCwgc3R5bGUudGV4dFN0cm9rZVdpZHRoKTtcblxuICAgIC8vIEZpbGwgYWZ0ZXIgc3Ryb2tlIHNvIHRoZSBvdXRsaW5lIHdpbGwgbm90IGNvdmVyIHRoZSBtYWluIHBhcnQuXG4gICAgaWYgKHRleHRTdHJva2UpIHtcbiAgICAgICAgc2V0Q3R4KGN0eCwgJ2xpbmVXaWR0aCcsIHRleHRTdHJva2VXaWR0aCk7XG4gICAgICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRTdHJva2UpO1xuICAgICAgICBjdHguc3Ryb2tlVGV4dCh0b2tlbi50ZXh0LCB4LCB5KTtcbiAgICB9XG4gICAgaWYgKHRleHRGaWxsKSB7XG4gICAgICAgIHNldEN0eChjdHgsICdmaWxsU3R5bGUnLCB0ZXh0RmlsbCk7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0b2tlbi50ZXh0LCB4LCB5KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5lZWREcmF3QmFja2dyb3VuZChzdHlsZSkge1xuICAgIHJldHVybiBzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yXG4gICAgICAgIHx8IChzdHlsZS50ZXh0Qm9yZGVyV2lkdGggJiYgc3R5bGUudGV4dEJvcmRlckNvbG9yKTtcbn1cblxuLy8gc3R5bGU6IHt0ZXh0QmFja2dyb3VuZENvbG9yLCB0ZXh0Qm9yZGVyV2lkdGgsIHRleHRCb3JkZXJDb2xvciwgdGV4dEJvcmRlclJhZGl1c31cbi8vIHNoYXBlOiB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCBzdHlsZSwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gc3R5bGUudGV4dEJhY2tncm91bmRDb2xvcjtcbiAgICB2YXIgdGV4dEJvcmRlcldpZHRoID0gc3R5bGUudGV4dEJvcmRlcldpZHRoO1xuICAgIHZhciB0ZXh0Qm9yZGVyQ29sb3IgPSBzdHlsZS50ZXh0Qm9yZGVyQ29sb3I7XG4gICAgdmFyIGlzUGxhaW5CZyA9IGlzU3RyaW5nKHRleHRCYWNrZ3JvdW5kQ29sb3IpO1xuXG4gICAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCBzdHlsZS50ZXh0Qm94U2hhZG93Qmx1ciB8fCAwKTtcbiAgICBzZXRDdHgoY3R4LCAnc2hhZG93Q29sb3InLCBzdHlsZS50ZXh0Qm94U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50Jyk7XG4gICAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFgnLCBzdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WCB8fCAwKTtcbiAgICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHN0eWxlLnRleHRCb3hTaGFkb3dPZmZzZXRZIHx8IDApO1xuXG4gICAgaWYgKGlzUGxhaW5CZyB8fCAodGV4dEJvcmRlcldpZHRoICYmIHRleHRCb3JkZXJDb2xvcikpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgdGV4dEJvcmRlclJhZGl1cyA9IHN0eWxlLnRleHRCb3JkZXJSYWRpdXM7XG4gICAgICAgIGlmICghdGV4dEJvcmRlclJhZGl1cykge1xuICAgICAgICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwge1xuICAgICAgICAgICAgICAgIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHI6IHRleHRCb3JkZXJSYWRpdXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNQbGFpbkJnKSB7XG4gICAgICAgIHNldEN0eChjdHgsICdmaWxsU3R5bGUnLCB0ZXh0QmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QodGV4dEJhY2tncm91bmRDb2xvcikpIHtcbiAgICAgICAgdmFyIGltYWdlID0gdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZTtcblxuICAgICAgICBpbWFnZSA9IGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2UoXG4gICAgICAgICAgICBpbWFnZSwgbnVsbCwgaG9zdEVsLCBvbkJnSW1hZ2VMb2FkZWQsIHRleHRCYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGltYWdlICYmIGltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShpbWFnZSkpIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRleHRCb3JkZXJXaWR0aCAmJiB0ZXh0Qm9yZGVyQ29sb3IpIHtcbiAgICAgICAgc2V0Q3R4KGN0eCwgJ2xpbmVXaWR0aCcsIHRleHRCb3JkZXJXaWR0aCk7XG4gICAgICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRCb3JkZXJDb2xvcik7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9uQmdJbWFnZUxvYWRlZChpbWFnZSwgdGV4dEJhY2tncm91bmRDb2xvcikge1xuICAgIC8vIFJlcGxhY2UgaW1hZ2UsIHNvIHRoYXQgYGNvbnRhaW4vdGV4dC5qcyNwYXJzZVJpY2hUZXh0YFxuICAgIC8vIHdpbGwgZ2V0IGNvcnJlY3QgcmVzdWx0IGluIG5leHQgdGljay5cbiAgICB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlID0gaW1hZ2U7XG59XG5cbmZ1bmN0aW9uIGdldEJveFBvc2l0aW9uKGJsb2NrSGVpaHQsIHN0eWxlLCByZWN0KSB7XG4gICAgdmFyIGJhc2VYID0gc3R5bGUueCB8fCAwO1xuICAgIHZhciBiYXNlWSA9IHN0eWxlLnkgfHwgMDtcbiAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduO1xuXG4gICAgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuICAgIGlmIChyZWN0KSB7XG4gICAgICAgIHZhciB0ZXh0UG9zaXRpb24gPSBzdHlsZS50ZXh0UG9zaXRpb247XG4gICAgICAgIGlmICh0ZXh0UG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgLy8gUGVyY2VudFxuICAgICAgICAgICAgYmFzZVggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgICAgICAgIGJhc2VZID0gcmVjdC55ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblsxXSwgcmVjdC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHRleHRDb250YWluLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdChcbiAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24sIHJlY3QsIHN0eWxlLnRleHREaXN0YW5jZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJhc2VYID0gcmVzLng7XG4gICAgICAgICAgICBiYXNlWSA9IHJlcy55O1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBhbGlnbiBhbmQgYmFzZWxpbmUgd2hlbiBoYXMgdGV4dFBvc2l0aW9uXG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gfHwgcmVzLnRleHRBbGlnbjtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gdGV4dFZlcnRpY2FsQWxpZ24gfHwgcmVzLnRleHRWZXJ0aWNhbEFsaWduO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGV4dE9mZnNldCBpcyBvbmx5IHN1cHBvcnQgaW4gUmVjdFRleHQsIG90aGVyd2lzZVxuICAgICAgICAvLyB3ZSBoYXZlIHRvIGFkanVzdCBib3VuZGluZ1JlY3QgZm9yIHRleHRPZmZzZXQuXG4gICAgICAgIHZhciB0ZXh0T2Zmc2V0ID0gc3R5bGUudGV4dE9mZnNldDtcbiAgICAgICAgaWYgKHRleHRPZmZzZXQpIHtcbiAgICAgICAgICAgIGJhc2VYICs9IHRleHRPZmZzZXRbMF07XG4gICAgICAgICAgICBiYXNlWSArPSB0ZXh0T2Zmc2V0WzFdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZVg6IGJhc2VYLFxuICAgICAgICBiYXNlWTogYmFzZVksXG4gICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogdGV4dFZlcnRpY2FsQWxpZ25cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBzZXRDdHgoY3R4LCBwcm9wLCB2YWx1ZSkge1xuICAgIC8vIEZJWE1FID8/PyBwZXJmb3JtYW5jZSB0cnlcbiAgICAvLyBpZiAoY3R4Ll9fY3VycmVudFZhbHVlc1twcm9wXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgLy8gY3R4W3Byb3BdID0gY3R4Ll9fY3VycmVudFZhbHVlc1twcm9wXSA9IHZhbHVlO1xuICAgIGN0eFtwcm9wXSA9IHZhbHVlO1xuICAgIC8vIH1cbiAgICByZXR1cm4gY3R4W3Byb3BdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3Ryb2tlXSBJZiBzcGVjaWZpZWQsIGRvIG5vdCBjaGVjayBzdHlsZS50ZXh0U3Ryb2tlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtsaW5lV2lkdGhdIElmIHNwZWNpZmllZCwgZG8gbm90IGNoZWNrIHN0eWxlLnRleHRTdHJva2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3R5bGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cm9rZShzdHJva2UsIGxpbmVXaWR0aCkge1xuICAgIHJldHVybiAoc3Ryb2tlID09IG51bGwgfHwgbGluZVdpZHRoIDw9IDAgfHwgc3Ryb2tlID09PSAndHJhbnNwYXJlbnQnIHx8IHN0cm9rZSA9PT0gJ25vbmUnKVxuICAgICAgICA/IG51bGxcbiAgICAgICAgLy8gVE9ETyBwYXR0ZXJuIGFuZCBncmFkaWVudD9cbiAgICAgICAgOiAoc3Ryb2tlLmltYWdlIHx8IHN0cm9rZS5jb2xvclN0b3BzKVxuICAgICAgICA/ICcjMDAwJ1xuICAgICAgICA6IHN0cm9rZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGwoZmlsbCkge1xuICAgIHJldHVybiAoZmlsbCA9PSBudWxsIHx8IGZpbGwgPT09ICdub25lJylcbiAgICAgICAgPyBudWxsXG4gICAgICAgIC8vIFRPRE8gcGF0dGVybiBhbmQgZ3JhZGllbnQ/XG4gICAgICAgIDogKGZpbGwuaW1hZ2UgfHwgZmlsbC5jb2xvclN0b3BzKVxuICAgICAgICA/ICcjMDAwJ1xuICAgICAgICA6IGZpbGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGVyY2VudCh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsdWUubGFzdEluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dFhGb3JQYWRkaW5nKHgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpIHtcbiAgICByZXR1cm4gdGV4dEFsaWduID09PSAncmlnaHQnXG4gICAgICAgID8gKHggLSB0ZXh0UGFkZGluZ1sxXSlcbiAgICAgICAgOiB0ZXh0QWxpZ24gPT09ICdjZW50ZXInXG4gICAgICAgID8gKHggKyB0ZXh0UGFkZGluZ1szXSAvIDIgLSB0ZXh0UGFkZGluZ1sxXSAvIDIpXG4gICAgICAgIDogKHggKyB0ZXh0UGFkZGluZ1szXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3R5bGV9IHN0eWxlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gbmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSB7XG4gICAgcmV0dXJuIHRleHQgIT0gbnVsbFxuICAgICAgICAmJiAodGV4dFxuICAgICAgICAgICAgfHwgc3R5bGUudGV4dEJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgfHwgKHN0eWxlLnRleHRCb3JkZXJXaWR0aCAmJiBzdHlsZS50ZXh0Qm9yZGVyQ29sb3IpXG4gICAgICAgICAgICB8fCBzdHlsZS50ZXh0UGFkZGluZ1xuICAgICAgICApO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL2dyYXBoaWMvaGVscGVyL3RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBHcm91cCBmcm9tIFwienJlbmRlci9zcmMvY29udGFpbmVyL0dyb3VwXCI7XHJcbmltcG9ydCBMaW5lIGZyb20gXCJ6cmVuZGVyL3NyYy9ncmFwaGljL3NoYXBlL0xpbmVcIjtcclxuaW1wb3J0IHtQb2ludH0gZnJvbSBcIi4vUG9pbnRcIjtcclxuaW1wb3J0IHtjaGVja0ludGVyc2VjdGlvbn0gZnJvbSBcImxpbmUtaW50ZXJzZWN0XCI7XHJcblxyXG5mdW5jdGlvbiBSb2FkTGluZShvcHMpe1xyXG4gICAgR3JvdXAuY2FsbCh0aGlzKTtcclxuICAgIHRoaXMudHlwZSA9IFwicm9hZGxpbmVcIjtcclxuICAgIHRoaXMuc3RhcnQgPSB7XHJcbiAgICAgICAgeDogb3BzLngxLFxyXG4gICAgICAgIHk6IG9wcy55MVxyXG4gICAgfTtcclxuICAgIHRoaXMuZW5kID0ge1xyXG4gICAgICAgIHg6IG9wcy54MixcclxuICAgICAgICB5OiBvcHMueTJcclxuICAgIH07XHJcbiAgICB0aGlzLmNyb3NzUG9pbnRzID0gW107XHJcbiAgICBsZXQgbGluZSA9IG5ldyBMaW5lKHtcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICB4MTogdGhpcy5zdGFydC54LFxyXG4gICAgICAgICAgICB5MTogdGhpcy5zdGFydC55LFxyXG4gICAgICAgICAgICB4MjogdGhpcy5lbmQueCxcclxuICAgICAgICAgICAgeTI6IHRoaXMuZW5kLnlcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMuYWRkKGxpbmUpO1xyXG5cclxuICAgIHRoaXMuc3RhcnRQb2ludCA9IG5ldyBQb2ludCh0aGlzLnN0YXJ0KVxyXG4gICAgdGhpcy5hZGQodGhpcy5zdGFydFBvaW50KTtcclxuICAgIHRoaXMuZW5kUG9pbnQgPSBuZXcgUG9pbnQodGhpcy5lbmQpXHJcbiAgICB0aGlzLmFkZCh0aGlzLmVuZFBvaW50KTtcclxuICAgIHRoaXMuc3RhcnRQb2ludC5vbmRyYWcgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgbGluZS5hdHRyKHtcclxuICAgICAgICAgICAgc2hhcGU6e1xyXG4gICAgICAgICAgICAgICAgeDE6IGV2dC5vZmZzZXRYLFxyXG4gICAgICAgICAgICAgICAgeTE6IGV2dC5vZmZzZXRZXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB0aGlzLmVuZFBvaW50Lm9uZHJhZyA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICBsaW5lLmF0dHIoe1xyXG4gICAgICAgICAgICBzaGFwZTp7XHJcbiAgICAgICAgICAgICAgICB4MjogZXZ0Lm9mZnNldFgsXHJcbiAgICAgICAgICAgICAgICB5MjogZXZ0Lm9mZnNldFlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHRoaXMuY3Jvc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuY3Jvc3MoKTtcclxuICAgIH1cclxuICAgIHRoaXMuY3Jvc3NMaW5lID0gKHRhcmdldCkgPT4ge1xyXG4gICAgICAgIGxldCByZXMgPSBjaGVja0ludGVyc2VjdGlvbih0aGlzLnN0YXJ0LngsdGhpcy5zdGFydC55LCB0aGlzLmVuZC54LCB0aGlzLmVuZC55LCB0YXJnZXQuc3RhcnQueCwgdGFyZ2V0LnN0YXJ0LnksIHRhcmdldC5lbmQueCwgdGFyZ2V0LmVuZC55KTtcclxuICAgICAgICByZXR1cm4gcmVzLnBvaW50IHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLnRvRGF0YSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogdGhpcy5lbmRcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblJvYWRMaW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3JvdXAucHJvdG90eXBlKTtcclxuXHJcbmV4cG9ydCB7Um9hZExpbmV9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1JvYWRMaW5lLmpzIiwiaW1wb3J0IEdyb3VwIGZyb20gXCJ6cmVuZGVyL3NyYy9jb250YWluZXIvR3JvdXBcIjtcclxuaW1wb3J0IHtQb2ludH0gZnJvbSBcIi4vUG9pbnRcIjtcclxuXHJcbmZ1bmN0aW9uIFNjZW5lKCl7XHJcbiAgICBHcm91cC5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5jcm9zcyA9ICgpID0+IHtcclxuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XHJcbiAgICAgICAgbGV0IGNyb3NzUG9pbnRzID0gY2hpbGRyZW4uZmlsdGVyKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbS50eXBlID09PSBcImNyb3NzcG9pbnRcIjtcclxuICAgICAgICB9KVxyXG4gICAgICAgIGNyb3NzUG9pbnRzLmZvckVhY2goY3AgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShjcCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICBsZXQgbGluZXMgPSBjaGlsZHJlbi5maWx0ZXIoaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09IFwicm9hZGxpbmVcIjtcclxuICAgICAgICB9KVxyXG4gICAgICAgIGZvcihsZXQgaT0wOyBpPCBsaW5lcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIGxldCBsaW5lMSA9IGxpbmVzW2ldO1xyXG4gICAgICAgICAgICBmb3IobGV0IGo9MTsgajwgbGluZXMubGVuZ3RoOyBqKyspe1xyXG4gICAgICAgICAgICAgICAgbGV0IGxpbmUyID0gbGluZXNbal07XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnQgPSBsaW5lMS5jcm9zc0xpbmUobGluZTIpO1xyXG4gICAgICAgICAgICAgICAgaWYoIXBvaW50KSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGxldCBjcnBvaW50ID0gbmV3IFBvaW50KHBvaW50KTtcclxuICAgICAgICAgICAgICAgIGNycG9pbnQuZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjcnBvaW50LnR5cGUgPSBcImNyb3NzcG9pbnRcIjtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGNycG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5TY2VuZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdyb3VwLnByb3RvdHlwZSk7XHJcblxyXG5leHBvcnQge1NjZW5lfVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TY2VuZS5qcyIsImltcG9ydCBEaXNwbGF5YWJsZSBmcm9tICcuL0Rpc3BsYXlhYmxlJztcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICcuLi9jb3JlL3V0aWwnO1xuaW1wb3J0ICogYXMgdGV4dENvbnRhaW4gZnJvbSAnLi4vY29udGFpbi90ZXh0JztcbmltcG9ydCAqIGFzIHRleHRIZWxwZXIgZnJvbSAnLi9oZWxwZXIvdGV4dCc7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbnZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdHMpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbn07XG5cblRleHQucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRleHQsXG5cbiAgICB0eXBlOiAndGV4dCcsXG5cbiAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICAgICAgLy8gT3B0aW1pemUsIGF2b2lkIG5vcm1hbGl6ZSBldmVyeSB0aW1lLlxuICAgICAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuXG4gICAgICAgIC8vIFVzZSBwcm9wcyB3aXRoIHByZWZpeCAndGV4dCcuXG4gICAgICAgIHN0eWxlLmZpbGwgPSBzdHlsZS5zdHJva2UgPSBzdHlsZS5zaGFkb3dCbHVyID0gc3R5bGUuc2hhZG93Q29sb3IgPVxuICAgICAgICAgICAgc3R5bGUuc2hhZG93T2Zmc2V0WCA9IHN0eWxlLnNoYWRvd09mZnNldFkgPSBudWxsO1xuXG4gICAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgICAgLy8gQ29udmVydCB0byBzdHJpbmdcbiAgICAgICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICAgICAgICAvLyBBbHdheXMgYmluZCBzdHlsZVxuICAgICAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcblxuICAgICAgICBpZiAoIXRleHRIZWxwZXIubmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICB0ZXh0SGVscGVyLnJlbmRlclRleHQodGhpcywgY3R4LCB0ZXh0LCBzdHlsZSk7XG5cbiAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gICAgfSxcblxuICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuXG4gICAgICAgIC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cbiAgICAgICAgdGhpcy5fX2RpcnR5ICYmIHRleHRIZWxwZXIubm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlLCB0cnVlKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgICAgICAgIHRleHQgIT0gbnVsbCA/ICh0ZXh0ICs9ICcnKSA6ICh0ZXh0ID0gJycpO1xuXG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0ICsgJycsXG4gICAgICAgICAgICAgICAgc3R5bGUuZm9udCxcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24sXG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dFBhZGRpbmcsXG4gICAgICAgICAgICAgICAgc3R5bGUucmljaFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmVjdC54ICs9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgIHJlY3QueSArPSBzdHlsZS55IHx8IDA7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0SGVscGVyLmdldFN0cm9rZShzdHlsZS50ZXh0U3Ryb2tlLCBzdHlsZS50ZXh0U3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBzdHlsZS50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICAgICAgcmVjdC54IC09IHcgLyAyO1xuICAgICAgICAgICAgICAgIHJlY3QueSAtPSB3IC8gMjtcbiAgICAgICAgICAgICAgICByZWN0LndpZHRoICs9IHc7XG4gICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgKz0gdztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgICB9XG59O1xuXG56clV0aWwuaW5oZXJpdHMoVGV4dCwgRGlzcGxheWFibGUpO1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9ncmFwaGljL1RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuKiBaUmVuZGVyLCBhIGhpZ2ggcGVyZm9ybWFuY2UgMmQgZHJhd2luZyBsaWJyYXJ5LlxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJhaWR1IEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogTElDRU5TRVxuKiBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL3pyZW5kZXIvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbiovXG5cbmltcG9ydCBndWlkIGZyb20gJy4vY29yZS9ndWlkJztcbmltcG9ydCBlbnYgZnJvbSAnLi9jb3JlL2Vudic7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnLi9jb3JlL3V0aWwnO1xuaW1wb3J0IEhhbmRsZXIgZnJvbSAnLi9IYW5kbGVyJztcbmltcG9ydCBTdG9yYWdlIGZyb20gJy4vU3RvcmFnZSc7XG5pbXBvcnQgUGFpbnRlciBmcm9tICcuL1BhaW50ZXInO1xuaW1wb3J0IEFuaW1hdGlvbiBmcm9tICcuL2FuaW1hdGlvbi9BbmltYXRpb24nO1xuaW1wb3J0IEhhbmRsZXJQcm94eSBmcm9tICcuL2RvbS9IYW5kbGVyUHJveHknO1xuXG52YXIgdXNlVk1MID0gIWVudi5jYW52YXNTdXBwb3J0ZWQ7XG5cbnZhciBwYWludGVyQ3RvcnMgPSB7XG4gICAgY2FudmFzOiBQYWludGVyXG59O1xuXG52YXIgaW5zdGFuY2VzID0ge307ICAgIC8vIFpSZW5kZXLlrp7kvottYXDntKLlvJVcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIHZlcnNpb24gPSAnMy43LjQnO1xuXG4vKipcbiAqIEluaXRpYWxpemluZyBhIHpyZW5kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdChkb20sIG9wdHMpIHtcbiAgICB2YXIgenIgPSBuZXcgWlJlbmRlcihndWlkKCksIGRvbSwgb3B0cyk7XG4gICAgaW5zdGFuY2VzW3pyLmlkXSA9IHpyO1xuICAgIHJldHVybiB6cjtcbn1cblxuLyoqXG4gKiBEaXNwb3NlIHpyZW5kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3Bvc2UoenIpIHtcbiAgICBpZiAoenIpIHtcbiAgICAgICAgenIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzW2tleV0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlcyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEdldCB6cmVuZGVyIGluc3RhbmNlIGJ5IGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgenJlbmRlciBpbnN0YW5jZSBpZFxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEluc3RhbmNlKGlkKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlc1tpZF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclBhaW50ZXIobmFtZSwgQ3Rvcikge1xuICAgIHBhaW50ZXJDdG9yc1tuYW1lXSA9IEN0b3I7XG59XG5cbmZ1bmN0aW9uIGRlbEluc3RhbmNlKGlkKSB7XG4gICAgZGVsZXRlIGluc3RhbmNlc1tpZF07XG59XG5cbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL1pSZW5kZXJcbiAqL1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9aUmVuZGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICovXG52YXIgWlJlbmRlciA9IGZ1bmN0aW9uIChpZCwgZG9tLCBvcHRzKSB7XG5cbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmRvbSA9IGRvbTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGlkO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdG9yYWdlID0gbmV3IFN0b3JhZ2UoKTtcblxuICAgIHZhciByZW5kZXJlclR5cGUgPSBvcHRzLnJlbmRlcmVyO1xuICAgIC8vIFRPRE8gV2ViR0xcbiAgICBpZiAodXNlVk1MKSB7XG4gICAgICAgIGlmICghcGFpbnRlckN0b3JzLnZtbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byByZXF1aXJlIFxcJ3pyZW5kZXIvdm1sL3ZtbFxcJyB0byBzdXBwb3J0IElFOCcpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyVHlwZSA9ICd2bWwnO1xuICAgIH1cbiAgICBlbHNlIGlmICghcmVuZGVyZXJUeXBlIHx8ICFwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXSkge1xuICAgICAgICByZW5kZXJlclR5cGUgPSAnY2FudmFzJztcbiAgICB9XG4gICAgdmFyIHBhaW50ZXIgPSBuZXcgcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0oZG9tLCBzdG9yYWdlLCBvcHRzKTtcblxuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcblxuICAgIHZhciBoYW5kZXJQcm94eSA9ICFlbnYubm9kZSA/IG5ldyBIYW5kbGVyUHJveHkocGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkgOiBudWxsO1xuICAgIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIGhhbmRlclByb3h5LCBwYWludGVyLnJvb3QpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb259XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKHtcbiAgICAgICAgc3RhZ2U6IHtcbiAgICAgICAgICAgIHVwZGF0ZTogenJVdGlsLmJpbmQodGhpcy5mbHVzaCwgdGhpcylcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYW5pbWF0aW9uLnN0YXJ0KCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaDtcblxuICAgIC8vIOS/ruaUuSBzdG9yYWdlLmRlbEZyb21TdG9yYWdlLCDmr4/mrKHliKDpmaTlhYPntKDkuYvliY3liKDpmaTliqjnlLtcbiAgICAvLyBGSVhNRSDmnInngrl1Z2x5XG4gICAgdmFyIG9sZERlbEZyb21TdG9yYWdlID0gc3RvcmFnZS5kZWxGcm9tU3RvcmFnZTtcbiAgICB2YXIgb2xkQWRkVG9TdG9yYWdlID0gc3RvcmFnZS5hZGRUb1N0b3JhZ2U7XG5cbiAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIG9sZERlbEZyb21TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuXG4gICAgICAgIGVsICYmIGVsLnJlbW92ZVNlbGZGcm9tWnIoc2VsZik7XG4gICAgfTtcblxuICAgIHN0b3JhZ2UuYWRkVG9TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIG9sZEFkZFRvU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcblxuICAgICAgICBlbC5hZGRTZWxmVG9acihzZWxmKTtcbiAgICB9O1xufTtcblxuWlJlbmRlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogWlJlbmRlcixcbiAgICAvKipcbiAgICAgKiDojrflj5blrp7kvovllK/kuIDmoIfor4ZcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOa3u+WKoOWFg+e0oFxuICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlLmFkZFJvb3QoZWwpO1xuICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDliKDpmaTlhYPntKBcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KGVsKTtcbiAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGNvbmZpZ3VyYXRpb24gb2YgbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gekxldmVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0gQ2xlYXIgY29sb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5tb3Rpb25CbHVyPWZhbHNlXSBJZiBlbmFibGUgbW90aW9uIGJsdXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddIE1vdGlvbiBibHVyIGZhY3Rvci4gTGFyZ2VyIHZhbHVlIGNhdXNlIGxvbmdlciB0cmFpbGVyXG4gICAgKi9cbiAgICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpMZXZlbCwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMucGFpbnRlci5jb25maWdMYXllcih6TGV2ZWwsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGFpbnQgdGhlIGNhbnZhcyBpbW1lZGlhdGVseVxuICAgICAqL1xuICAgIHJlZnJlc2hJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAvLyBDbGVhciBuZWVkc1JlZnJlc2ggYWhlYWQgdG8gYXZvaWQgc29tZXRoaW5nIHdyb25nIGhhcHBlbnMgaW4gcmVmcmVzaFxuICAgICAgICAvLyBPciBpdCB3aWxsIGNhdXNlIHpyZW5kZXIgcmVmcmVzaGVzIGFnYWluIGFuZCBhZ2Fpbi5cbiAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFpbnRlci5yZWZyZXNoKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdm9pZCB0cmlnZ2VyIHpyLnJlZnJlc2ggaW4gRWxlbWVudCNiZWZvcmVVcGRhdGUgaG9va1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIC8vIHZhciBlbmQgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIC8vIHZhciBsb2cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9nJyk7XG4gICAgICAgIC8vIGlmIChsb2cpIHtcbiAgICAgICAgLy8gICAgIGxvZy5pbm5lckhUTUwgPSBsb2cuaW5uZXJIVE1MICsgJzxicj4nICsgKGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgLy8gfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYXJrIGFuZCByZXBhaW50IHRoZSBjYW52YXMgaW4gdGhlIG5leHQgZnJhbWUgb2YgYnJvd3NlclxuICAgICAqL1xuICAgIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFsbCByZWZyZXNoXG4gICAgICovXG4gICAgZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX25lZWRzUmVmcmVzaCkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoSW1tZWRpYXRlbHkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVySW1tZWRpYXRlbHkoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZWxlbWVudCB0byBob3ZlciBsYXllclxuICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICovXG4gICAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgc3R5bGUpIHtcbiAgICAgICAgaWYgKHRoaXMucGFpbnRlci5hZGRIb3Zlcikge1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmFkZEhvdmVyKGVsLCBzdHlsZSk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBlbGVtZW50IGZyb20gaG92ZXIgbGF5ZXJcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAqL1xuICAgIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKHRoaXMucGFpbnRlci5yZW1vdmVIb3Zlcikge1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlbW92ZUhvdmVyKGVsKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGhvdmVyIGVsZW1lbnRzIGluIGhvdmVyIGxheWVyXG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgKi9cbiAgICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhaW50ZXIuY2xlYXJIb3Zlcikge1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmNsZWFySG92ZXIoKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVmcmVzaCBob3ZlciBpbiBuZXh0IGZyYW1lXG4gICAgICovXG4gICAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVmcmVzaCBob3ZlciBpbW1lZGlhdGVseVxuICAgICAqL1xuICAgIHJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFpbnRlci5yZWZyZXNoSG92ZXIgJiYgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdGhlIGNhbnZhcy5cbiAgICAgKiBTaG91bGQgYmUgaW52b2tlZCB3aGVuIGNvbnRhaW5lciBzaXplIGlzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24ob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5wYWludGVyLnJlc2l6ZShvcHRzLndpZHRoLCBvcHRzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlci5yZXNpemUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBhbmQgY2xlYXIgYWxsIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgICAqL1xuICAgIGNsZWFyQW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLmNsZWFyKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb250YWluZXIgd2lkdGhcbiAgICAgKi9cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbnRhaW5lciBoZWlnaHRcbiAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldEhlaWdodCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHBvcnQgdGhlIGNhbnZhcyBhcyBCYXNlNjQgVVJMXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2JhY2tncm91bmRDb2xvcj0nI2ZmZiddXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgVVJMXG4gICAgICovXG4gICAgLy8gdG9EYXRhVVJMOiBmdW5jdGlvbih0eXBlLCBiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyh7XG4gICAgLy8gICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAgIC8vICAgICB9KS50b0RhdGFVUkwodHlwZSk7XG4gICAgLy8gfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRpbmcgYSBwYXRoIHRvIGltYWdlLlxuICAgICAqIEl0IGhhcyBtdWNoIGJldHRlciBwZXJmb3JtYW5jZSBvZiBkcmF3aW5nIGltYWdlIHJhdGhlciB0aGFuIGRyYXdpbmcgYSB2ZWN0b3IgcGF0aC5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBwYXRoVG9JbWFnZTogZnVuY3Rpb24oZSwgZHByKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhaW50ZXIucGF0aFRvSW1hZ2UoZSwgZHByKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGRlZmF1bHQgY3Vyc29yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdHlsZT0nZGVmYXVsdCddIOS+i+WmgiBjcm9zc2hhaXJcbiAgICAgKi9cbiAgICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5zZXRDdXJzb3JTdHlsZShjdXJzb3JTdHlsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgaG92ZXJlZCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge09iamVjdH0ge3RhcmdldCwgdG9wVGFyZ2V0fVxuICAgICAqL1xuICAgIGZpbmRIb3ZlcjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5maW5kSG92ZXIoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJpbmQgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50SGFuZGxlciBIYW5kbGVyIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0IG9iamVjdFxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmhhbmRsZXIub24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXZlbnRIYW5kbGVyXSBIYW5kbGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXIub2ZmKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBldmVudCBtYW51YWxseVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtldmVudD19IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBvYmplY3RzIGFuZCB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KCk7XG4gICAgICAgIHRoaXMucGFpbnRlci5jbGVhcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHNlbGYuXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi5zdG9wKCk7XG5cbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLnN0b3JhZ2UuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnBhaW50ZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID1cbiAgICAgICAgdGhpcy5zdG9yYWdlID1cbiAgICAgICAgdGhpcy5wYWludGVyID1cbiAgICAgICAgdGhpcy5oYW5kbGVyID0gbnVsbDtcblxuICAgICAgICBkZWxJbnN0YW5jZSh0aGlzLmlkKTtcbiAgICB9XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvenJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICogYXMgenJlbmRlciBmcm9tICd6cmVuZGVyL3NyYy96cmVuZGVyJztcbmltcG9ydCBUZXh0IGZyb20gXCJ6cmVuZGVyL3NyYy9ncmFwaGljL1RleHRcIjtcbmltcG9ydCB7Um9hZExpbmV9IGZyb20gXCIuL1JvYWRMaW5lXCI7XG5pbXBvcnQge1NjZW5lfSBmcm9tIFwiLi9TY2VuZVwiO1xuXG5sZXQgY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjYW52YXNcIik7XG5jb25zdCB6ciA9IHpyZW5kZXIuaW5pdChjb250YWluZXIpO1xuXG5jb25zdCBzY2VuZSA9IG5ldyBTY2VuZSgpO1xubGV0IGxpbmUgPSBuZXcgUm9hZExpbmUoe1xuICAgeDE6IDE2MCxcbiAgIHkxOiAxMCxcbiAgIHgyOiA3MDAsXG4gICB5MjogNjQwXG59KTtcbnNjZW5lLmFkZChsaW5lKTtcbmxldCBsaW5lMSA9IG5ldyBSb2FkTGluZSh7XG4gICB4MTogMTAwLFxuICAgeTE6IDcwLFxuICAgeDI6IDYwMCxcbiAgIHkyOiA3MDBcbn0pO1xuc2NlbmUuYWRkKGxpbmUxKTtcbmxldCB0ZXh0ID0gbmV3IFRleHQoe1xuICAgc3R5bGU6IHtcbiAgICAgIHRleHQ6IFwi5a+85Ye65b2T5YmN6YWN572uXCJcbiAgIH1cbn0pO1xudGV4dC5vbihcImNsaWNrXCIsICgpPT57XG4gICBsZXQgY2hpbGRyZW4gPSBzY2VuZS5jaGlsZHJlbigpO1xuICAgbGV0IGxpbmVzID0gY2hpbGRyZW4uZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gXCJyb2FkbGluZVwiO1xuICAgfSlcbiAgIGxldCBkYXRhcyA9IFtdO1xuICAgbGluZXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGRhdGFzLnB1c2goaXRlbS50b0RhdGEoKSk7XG4gICB9KVxuICAgY29uc29sZS5kZWJ1ZyhkYXRhcylcbn0pXG50ZXh0LnBvc2l0aW9uID0gWzEwLCAxMF1cbnNjZW5lLmFkZCh0ZXh0KTtcbnpyLmFkZChzY2VuZSk7XG5kb2N1bWVudC5vbmNvbnRleHRtZW51ID0gZnVuY3Rpb24oKXtcbiAgIHJldHVybiBmYWxzZTtcbn1cbnpyLm9uKFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICBsZXQgbGluZSA9IG5ldyBSb2FkTGluZSh7XG4gICAgICB4MTogZXZ0Lm9mZnNldFgsXG4gICAgICB5MTogZXZ0Lm9mZnNldFksXG4gICAgICB4MjogZXZ0Lm9mZnNldFggKyAxMDAsXG4gICAgICB5MjogZXZ0Lm9mZnNldFkgKyAxMDBcbiAgIH0pO1xuICAgc2NlbmUuYWRkKGxpbmUpO1xufSk7XG5cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgKGUpID0+IHtcbiAgIHpyLnJlc2l6ZSh7XG4gICAgICB3aWR0aDogY29udGFpbmVyLmNsaWVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBjb250YWluZXIuY2xpZW50SGVpZ2h0XG4gICB9KVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwcC5qcyIsInZhciBDT0xJTkVBUiA9IGludGVyc2VjdFJlc3VsdCgnY29saW5lYXInKTtcbnZhciBQQVJBTExFTCA9IGludGVyc2VjdFJlc3VsdCgncGFyYWxsZWwnKTtcbnZhciBOT05FID0gaW50ZXJzZWN0UmVzdWx0KCdub25lJyk7XG4vKipcbiogQ2hlY2sgaG93IHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdCBlYWNob3RoZXIuIExpbmUgc2VnbWVudHMgYXJlIHJlcHJlc2VudGVkXG4qIGFzICh4MSwgeTEpLSh4MiwgeTIpIGFuZCAoeDMsIHkzKS0oeDQsIHk0KS5cbipcbiogQHBhcmFtIHtudW1iZXJ9IHgxXG4qIEBwYXJhbSB7bnVtYmVyfSB5MVxuKiBAcGFyYW0ge251bWJlcn0geDJcbiogQHBhcmFtIHtudW1iZXJ9IHkyXG4qIEBwYXJhbSB7bnVtYmVyfSB4M1xuKiBAcGFyYW0ge251bWJlcn0geTNcbiogQHBhcmFtIHtudW1iZXJ9IHg0XG4qIEBwYXJhbSB7bnVtYmVyfSB5NFxuKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBkZXNjcmliaW5nIGludGVyc2VjdGlvbiB0aGF0IGxvb2tzIGxpa2VcbiogICAge1xuKiAgICAgIHR5cGU6IG5vbmV8cGFyYWxsZWx8Y29saW5lYXJ8aW50ZXJzZWN0aW5nLFxuKiAgICAgIHBvaW50OiB7eCwgeX0gLSBvbmx5IGRlZmluZWQgd2hlbiB0eXBlID09IGludGVyc2VjdGluZ1xuKiAgICB9XG4qL1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSB7XG4gIHZhciBkZW5vbSA9ICh5NCAtIHkzKSAqICh4MiAtIHgxKSAtICh4NCAtIHgzKSAqICh5MiAtIHkxKTtcbiAgdmFyIG51bWVBID0gKHg0IC0geDMpICogKHkxIC0geTMpIC0gKHk0IC0geTMpICogKHgxIC0geDMpO1xuICB2YXIgbnVtZUIgPSAoeDIgLSB4MSkgKiAoeTEgLSB5MykgLSAoeTIgLSB5MSkgKiAoeDEgLSB4Myk7XG5cbiAgaWYgKGRlbm9tID09IDApIHtcbiAgICBpZiAobnVtZUEgPT0gMCAmJiBudW1lQiA9PSAwKSB7XG4gICAgICByZXR1cm4gQ09MSU5FQVI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBBUkFMTEVMO1xuICB9XG5cbiAgdmFyIHVBID0gbnVtZUEgLyBkZW5vbTtcbiAgdmFyIHVCID0gbnVtZUIgLyBkZW5vbTtcblxuICBpZiAodUEgPj0gMCAmJiB1QSA8PSAxICYmIHVCID49IDAgJiYgdUIgPD0gMSkge1xuICAgIHJldHVybiBpbnRlcnNlY3Rpbmcoe1xuICAgICAgeDogeDEgKyB1QSAqICh4MiAtIHgxKSxcbiAgICAgIHk6IHkxICsgdUEgKiAoeTIgLSB5MSlcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBOT05FO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RpbmcocG9pbnQpIHtcbiAgdmFyIHJlc3VsdCA9IGludGVyc2VjdFJlc3VsdCgnaW50ZXJzZWN0aW5nJyk7XG4gIHJlc3VsdC5wb2ludCA9IHBvaW50O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RSZXN1bHQodHlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGVcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbGluZS1pbnRlcnNlY3QvZXMvY2hlY2staW50ZXJzZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiogQXNzdW1pbmcgYSBwb2ludCBpcyBvbiBzYW1lIGxpbmUgYXMgYSBsaW5lIHNlZ21lbnQsIHRlbGwgaWYgdGhhdCBwb2ludCBpc1xuKiBvbiB0aGUgbGluZSBzZWdtZW50LlxuKlxuKiBAcGFyYW0ge251bWJlcn0gcG9pbnRYIC0gWCBvZiBwb2ludFxuKiBAcGFyYW0ge251bWJlcn0gcG9pbnRZIC0gWSBvZiBwb2ludFxuKiBAcGFyYW0ge251bWJlcn0gc3RhcnRYIC0gWCBvZiBsaW5lIHNlZ21lbnQgc3RhcnRcbiogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0WSAtIFkgb2YgbGluZSBzZWdtZW50IHN0YXJ0XG4qIEBwYXJhbSB7bnVtYmVyfSBlbmRYICAgLSBYIG9mIGxpbmUgc2VnbWVudCBlbmRcbiogQHBhcmFtIHtudW1iZXJ9IGVuZFkgICAtIFkgb2YgbGluZSBzZWdtZW50IGVuZFxuKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHBvaW50IGlzIHdpdGhpbiBzZWdtZW50LCBmYWxzZSBvdGhlcndpc2UuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbGluZWFyUG9pbnRXaXRoaW5TZWdtZW50KHBvaW50WCwgcG9pbnRZLCBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSkge1xuICBpZiAoc3RhcnRYICE9IGVuZFgpIHtcbiAgICBpZiAoc3RhcnRYIDw9IHBvaW50WCAmJiBwb2ludFggPD0gZW5kWCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHN0YXJ0WCA+PSBwb2ludFggJiYgcG9pbnRYID49IGVuZFgpIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGlmIChzdGFydFkgPD0gcG9pbnRZICYmIHBvaW50WSA8PSBlbmRZKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoc3RhcnRZID49IHBvaW50WSAmJiBwb2ludFkgPj0gZW5kWSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xpbmUtaW50ZXJzZWN0L2VzL2NvbGluZWFyLXBvaW50LXdpdGhpbi1zZWdtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBjaGVja0ludGVyc2VjdGlvbiB9IGZyb20gJy4vY2hlY2staW50ZXJzZWN0aW9uJztcbmltcG9ydCB7IGNvbGluZWFyUG9pbnRXaXRoaW5TZWdtZW50IH0gZnJvbSAnLi9jb2xpbmVhci1wb2ludC13aXRoaW4tc2VnbWVudCc7XG5leHBvcnQgeyBjaGVja0ludGVyc2VjdGlvbiwgY29saW5lYXJQb2ludFdpdGhpblNlZ21lbnQgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbGluZS1pbnRlcnNlY3QvZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogSGFuZGxlclxuICogQG1vZHVsZSB6cmVuZGVyL0hhbmRsZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChzaGVueWkuOTE0QGdtYWlsLmNvbSlcbiAqL1xuXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vY29yZS91dGlsJztcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi9jb3JlL3ZlY3Rvcic7XG5pbXBvcnQgRHJhZ2dhYmxlIGZyb20gJy4vbWl4aW4vRHJhZ2dhYmxlJztcbmltcG9ydCBFdmVudGZ1bCBmcm9tICcuL21peGluL0V2ZW50ZnVsJztcblxudmFyIFNJTEVOVCA9ICdzaWxlbnQnO1xuXG5mdW5jdGlvbiBtYWtlRXZlbnRQYWNrZXQoZXZlVHlwZSwgdGFyZ2V0SW5mbywgZXZlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBldmVUeXBlLFxuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIC8vIHRhcmdldCBjYW4gb25seSBiZSBhbiBlbGVtZW50IHRoYXQgaXMgbm90IHNpbGVudC5cbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRJbmZvLnRhcmdldCxcbiAgICAgICAgLy8gdG9wVGFyZ2V0IGNhbiBiZSBhIHNpbGVudCBlbGVtZW50LlxuICAgICAgICB0b3BUYXJnZXQ6IHRhcmdldEluZm8udG9wVGFyZ2V0LFxuICAgICAgICBjYW5jZWxCdWJibGU6IGZhbHNlLFxuICAgICAgICBvZmZzZXRYOiBldmVudC56clgsXG4gICAgICAgIG9mZnNldFk6IGV2ZW50LnpyWSxcbiAgICAgICAgZ2VzdHVyZUV2ZW50OiBldmVudC5nZXN0dXJlRXZlbnQsXG4gICAgICAgIHBpbmNoWDogZXZlbnQucGluY2hYLFxuICAgICAgICBwaW5jaFk6IGV2ZW50LnBpbmNoWSxcbiAgICAgICAgcGluY2hTY2FsZTogZXZlbnQucGluY2hTY2FsZSxcbiAgICAgICAgd2hlZWxEZWx0YTogZXZlbnQuenJEZWx0YSxcbiAgICAgICAgenJCeVRvdWNoOiBldmVudC56ckJ5VG91Y2gsXG4gICAgICAgIHdoaWNoOiBldmVudC53aGljaFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIEVtcHR5UHJveHkgKCkge31cbkVtcHR5UHJveHkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIGhhbmRsZXJOYW1lcyA9IFtcbiAgICAnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V3aGVlbCcsICdtb3VzZW91dCcsXG4gICAgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdjb250ZXh0bWVudSdcbl07XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9IYW5kbGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2UgU3RvcmFnZSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvUGFpbnRlcn0gcGFpbnRlciBQYWludGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9kb20vSGFuZGxlclByb3h5fSBwcm94eSBIYW5kbGVyUHJveHkgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYWludGVyUm9vdCBwYWludGVyLnJvb3QgKG5vdCBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKS5cbiAqL1xudmFyIEhhbmRsZXIgPSBmdW5jdGlvbihzdG9yYWdlLCBwYWludGVyLCBwcm94eSwgcGFpbnRlclJvb3QpIHtcbiAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcblxuICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICB0aGlzLnBhaW50ZXJSb290ID0gcGFpbnRlclJvb3Q7XG5cbiAgICBwcm94eSA9IHByb3h5IHx8IG5ldyBFbXB0eVByb3h5KCk7XG5cbiAgICAvKipcbiAgICAgKiBQcm94eSBvZiBldmVudC4gY2FuIGJlIERvbSwgV2ViR0xTdXJmYWNlLCBldGMuXG4gICAgICovXG4gICAgdGhpcy5wcm94eSA9IHByb3h5O1xuXG4gICAgLy8gQXR0YWNoIGhhbmRsZXJcbiAgICBwcm94eS5oYW5kbGVyID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIHt0YXJnZXQsIHRvcFRhcmdldCwgeCwgeX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5faG92ZXJlZCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fbGFzdFg7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fbGFzdFk7XG5cblxuICAgIERyYWdnYWJsZS5jYWxsKHRoaXMpO1xuXG4gICAgdXRpbC5lYWNoKGhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcHJveHkub24gJiYgcHJveHkub24obmFtZSwgdGhpc1tuYW1lXSwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG5IYW5kbGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBIYW5kbGVyLFxuXG4gICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHggPSBldmVudC56clg7XG4gICAgICAgIHZhciB5ID0gZXZlbnQuenJZO1xuXG4gICAgICAgIHZhciBsYXN0SG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQ7XG4gICAgICAgIHZhciBsYXN0SG92ZXJlZFRhcmdldCA9IGxhc3RIb3ZlcmVkLnRhcmdldDtcblxuICAgICAgICAvLyBJZiBsYXN0SG92ZXJlZFRhcmdldCBpcyByZW1vdmVkIGZyb20genIgKGRldGVjdGVkIGJ5ICdfX3pyJykgYnkgc29tZSBBUEkgY2FsbFxuICAgICAgICAvLyAobGlrZSAnc2V0T3B0aW9uJyBvciAnZGlzcGF0Y2hBY3Rpb24nKSBpbiBldmVudCBoYW5kbGVycywgd2Ugc2hvdWxkIGZpbmRcbiAgICAgICAgLy8gbGFzdEhvdmVyZWQgYWdhaW4gaGVyZS4gT3RoZXJ3aXNlICdtb3VzZW91dCcgY2FuIG5vdCBiZSB0cmlnZ2VyZWQgbm9ybWFsbHkuXG4gICAgICAgIC8vIFNlZSAjNjE5OC5cbiAgICAgICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmICFsYXN0SG92ZXJlZFRhcmdldC5fX3pyKSB7XG4gICAgICAgICAgICBsYXN0SG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKGxhc3RIb3ZlcmVkLngsIGxhc3RIb3ZlcmVkLnkpO1xuICAgICAgICAgICAgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5KTtcbiAgICAgICAgdmFyIGhvdmVyZWRUYXJnZXQgPSBob3ZlcmVkLnRhcmdldDtcblxuICAgICAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgICAgICBwcm94eS5zZXRDdXJzb3IgJiYgcHJveHkuc2V0Q3Vyc29yKGhvdmVyZWRUYXJnZXQgPyBob3ZlcmVkVGFyZ2V0LmN1cnNvciA6ICdkZWZhdWx0Jyk7XG5cbiAgICAgICAgLy8gTW91c2Ugb3V0IG9uIHByZXZpb3VzIGhvdmVyZWQgZWxlbWVudFxuICAgICAgICBpZiAobGFzdEhvdmVyZWRUYXJnZXQgJiYgaG92ZXJlZFRhcmdldCAhPT0gbGFzdEhvdmVyZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQobGFzdEhvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdXNlIG1vdmluZyBvbiBvbmUgZWxlbWVudFxuICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW1vdmUnLCBldmVudCk7XG5cbiAgICAgICAgLy8gTW91c2Ugb3ZlciBvbiBhIG5ldyBlbGVtZW50XG4gICAgICAgIGlmIChob3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW92ZXInLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHRoaXMuX2hvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcblxuICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBzb21lIGRvbXMgY3JlYXRlZCBieSB1cHBlciBsYXllciBhcHBsaWNhdGlvblxuICAgICAgICAvLyBhdCB0aGUgc2FtZSBsZXZlbCBvZiBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpIChlLmcuLCB0b29sdGlwXG4gICAgICAgIC8vIGRvbSBjcmVhdGVkIGJ5IGVjaGFydHMpLCB3aGVyZSAnZ2xvYmFsb3V0JyBldmVudCBzaG91bGQgbm90XG4gICAgICAgIC8vIGJlIHRyaWdnZXJlZCB3aGVuIG1vdXNlIGVudGVycyB0aGVzZSBkb21zLiAoQnV0ICdtb3VzZW91dCdcbiAgICAgICAgLy8gc2hvdWxkIGJlIHRyaWdnZXJlZCBhdCB0aGUgb3JpZ2luYWwgaG92ZXJlZCBlbGVtZW50IGFzIHVzdWFsKS5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgdmFyIGlubmVyRG9tO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPSA5ICYmICEoXG4gICAgICAgICAgICBpbm5lckRvbSA9IGVsZW1lbnQgPT09IHRoaXMucGFpbnRlclJvb3RcbiAgICAgICAgKSk7XG5cbiAgICAgICAgIWlubmVyRG9tICYmIHRoaXMudHJpZ2dlcignZ2xvYmFsb3V0Jywge2V2ZW50OiBldmVudH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemVcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLl9ob3ZlcmVkID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudEFyZ3NcbiAgICAgKi9cbiAgICBkaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcmdzKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpc1tldmVudE5hbWVdO1xuICAgICAgICBoYW5kbGVyICYmIGhhbmRsZXIuY2FsbCh0aGlzLCBldmVudEFyZ3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMucHJveHkuZGlzcG9zZSgpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9XG4gICAgICAgIHRoaXMucHJveHkgPVxuICAgICAgICB0aGlzLnBhaW50ZXIgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDorr7nva7pu5jorqTnmoRjdXJzb3Igc3R5bGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgICAqL1xuICAgIHNldEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICAgICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcbiAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihjdXJzb3JTdHlsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOS6i+S7tuWIhuWPkeS7o+eQhlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0SW5mbyB7dGFyZ2V0LCB0b3BUYXJnZXR9IOebruagh+WbvuW9ouWFg+e0oFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUg5LqL5Lu25ZCN56ewXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tuWvueixoVxuICAgICAqL1xuICAgIGRpc3BhdGNoVG9FbGVtZW50OiBmdW5jdGlvbiAodGFyZ2V0SW5mbywgZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICB0YXJnZXRJbmZvID0gdGFyZ2V0SW5mbyB8fCB7fTtcbiAgICAgICAgdmFyIGVsID0gdGFyZ2V0SW5mby50YXJnZXQ7XG4gICAgICAgIGlmIChlbCAmJiBlbC5zaWxlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRIYW5kbGVyID0gJ29uJyArIGV2ZW50TmFtZTtcbiAgICAgICAgdmFyIGV2ZW50UGFja2V0ID0gbWFrZUV2ZW50UGFja2V0KGV2ZW50TmFtZSwgdGFyZ2V0SW5mbywgZXZlbnQpO1xuXG4gICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgZWxbZXZlbnRIYW5kbGVyXVxuICAgICAgICAgICAgICAgICYmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUgPSBlbFtldmVudEhhbmRsZXJdLmNhbGwoZWwsIGV2ZW50UGFja2V0KSk7XG5cbiAgICAgICAgICAgIGVsLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG5cbiAgICAgICAgICAgIGVsID0gZWwucGFyZW50O1xuXG4gICAgICAgICAgICBpZiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgICAgICAgLy8g5YaS5rOh5Yiw6aG257qnIHpyZW5kZXIg5a+56LGhXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG4gICAgICAgICAgICAvLyDliIblj5Hkuovku7bliLDnlKjmiLfoh6rlrprkuYnlsYJcbiAgICAgICAgICAgIC8vIOeUqOaIt+acieWPr+iDveWcqOWFqOWxgCBjbGljayDkuovku7bkuK0gZGlzcG9zZe+8jOaJgOS7pemcgOimgeWIpOaWreS4iyBwYWludGVyIOaYr+WQpuWtmOWcqFxuICAgICAgICAgICAgdGhpcy5wYWludGVyICYmIHRoaXMucGFpbnRlci5lYWNoT3RoZXJMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGxheWVyW2V2ZW50SGFuZGxlcl0pID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJbZXZlbnRIYW5kbGVyXS5jYWxsKGxheWVyLCBldmVudFBhY2tldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXllci50cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlfSBleGNsdWRlXG4gICAgICogQHJldHVybiB7bW9kZWw6enJlbmRlci9FbGVtZW50fVxuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBmaW5kSG92ZXI6IGZ1bmN0aW9uKHgsIHksIGV4Y2x1ZGUpIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcbiAgICAgICAgdmFyIG91dCA9IHt4OiB4LCB5OiB5fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBob3ZlckNoZWNrUmVzdWx0O1xuICAgICAgICAgICAgaWYgKGxpc3RbaV0gIT09IGV4Y2x1ZGVcbiAgICAgICAgICAgICAgICAvLyBnZXREaXNwbGF5TGlzdCBtYXkgaW5jbHVkZSBpZ25vcmVkIGl0ZW0gaW4gVk1MIG1vZGVcbiAgICAgICAgICAgICAgICAmJiAhbGlzdFtpXS5pZ25vcmVcbiAgICAgICAgICAgICAgICAmJiAoaG92ZXJDaGVja1Jlc3VsdCA9IGlzSG92ZXIobGlzdFtpXSwgeCwgeSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAhb3V0LnRvcFRhcmdldCAmJiAob3V0LnRvcFRhcmdldCA9IGxpc3RbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChob3ZlckNoZWNrUmVzdWx0ICE9PSBTSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnRhcmdldCA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufTtcblxuLy8gQ29tbW9uIGhhbmRsZXJzXG51dGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgSGFuZGxlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gRmluZCBob3ZlciBhZ2FpbiB0byBhdm9pZCBjbGljayBldmVudCBpcyBkaXNwYXRjaGVkIG1hbnVhbGx5LiBPciBjbGljayBpcyB0cmlnZ2VyZWQgd2l0aG91dCBtb3VzZW92ZXJcbiAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSk7XG4gICAgICAgIHZhciBob3ZlcmVkVGFyZ2V0ID0gaG92ZXJlZC50YXJnZXQ7XG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICB0aGlzLl9kb3duRWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5fZG93blBvaW50ID0gW2V2ZW50LnpyWCwgZXZlbnQuenJZXTtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgY2xpY2sgdHJpZ2dlcmVkIGJlZm9yZSBtb3VzZXVwXG4gICAgICAgICAgICB0aGlzLl91cEVsID0gaG92ZXJlZFRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnbW9zdWV1cCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwRWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kb3duRWwgIT09IHRoaXMuX3VwRWxcbiAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBjbGljayBldmVudCBpcyB0cmlnZ2VyZWQgb24gdGhlIHdob2xlIGNhbnZhcyBlbGVtZW50LFxuICAgICAgICAgICAgICAgIC8vIGluY2x1ZGluZyB0aGUgY2FzZSB0aGF0IGBtb3VzZWRvd25gIC0gYG1vdXNlbW92ZWAgLSBgbW91c2V1cGAsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggc2hvdWxkIGJlIGZpbHRlcmVkLCBvdGhlcndpc2UgaXQgd2lsbCBicmluZyB0cm91YmxlIHRvXG4gICAgICAgICAgICAgICAgLy8gcGFuIGFuZCB6b29tLlxuICAgICAgICAgICAgICAgIHx8ICF0aGlzLl9kb3duUG9pbnRcbiAgICAgICAgICAgICAgICAvLyBBcmJpdHJhcnkgdmFsdWVcbiAgICAgICAgICAgICAgICB8fCB2ZWMyLmRpc3QodGhpcy5fZG93blBvaW50LCBbZXZlbnQuenJYLCBldmVudC56clldKSA+IDRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Rvd25Qb2ludCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsIG5hbWUsIGV2ZW50KTtcbiAgICB9O1xufSk7XG5cbmZ1bmN0aW9uIGlzSG92ZXIoZGlzcGxheWFibGUsIHgsIHkpIHtcbiAgICBpZiAoZGlzcGxheWFibGVbZGlzcGxheWFibGUucmVjdEhvdmVyID8gJ3JlY3RDb250YWluJyA6ICdjb250YWluJ10oeCwgeSkpIHtcbiAgICAgICAgdmFyIGVsID0gZGlzcGxheWFibGU7XG4gICAgICAgIHZhciBpc1NpbGVudDtcbiAgICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgICAgICAvLyBJZiBjbGlwcGVkIGJ5IGFuY2VzdG9yLlxuICAgICAgICAgICAgLy8gRklYTUU6IElmIGNsaXBQYXRoIGhhcyBuZWl0aGVyIHN0cm9rZSBub3IgZmlsbCxcbiAgICAgICAgICAgIC8vIGVsLmNsaXBQYXRoLmNvbnRhaW4oeCwgeSkgd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlLlxuICAgICAgICAgICAgaWYgKGVsLmNsaXBQYXRoICYmICFlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpKSAge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBpc1NpbGVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTaWxlbnQgPyBTSUxFTlQgOiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudXRpbC5taXhpbihIYW5kbGVyLCBFdmVudGZ1bCk7XG51dGlsLm1peGluKEhhbmRsZXIsIERyYWdnYWJsZSk7XG5cbmV4cG9ydCBkZWZhdWx0IEhhbmRsZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL0hhbmRsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL0xheWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi9jb3JlL3V0aWwnO1xuaW1wb3J0IHtkZXZpY2VQaXhlbFJhdGlvfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgU3R5bGUgZnJvbSAnLi9ncmFwaGljL1N0eWxlJztcbmltcG9ydCBQYXR0ZXJuIGZyb20gJy4vZ3JhcGhpYy9QYXR0ZXJuJztcblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIOWIm+W7umRvbVxuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHtzdHJpbmd9IGlkIGRvbSBpZCDlvoXnlKhcbiAqIEBwYXJhbSB7UGFpbnRlcn0gcGFpbnRlciBwYWludGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURvbShpZCwgcGFpbnRlciwgZHByKSB7XG4gICAgdmFyIG5ld0RvbSA9IHV0aWwuY3JlYXRlQ2FudmFzKCk7XG4gICAgdmFyIHdpZHRoID0gcGFpbnRlci5nZXRXaWR0aCgpO1xuICAgIHZhciBoZWlnaHQgPSBwYWludGVyLmdldEhlaWdodCgpO1xuXG4gICAgdmFyIG5ld0RvbVN0eWxlID0gbmV3RG9tLnN0eWxlO1xuICAgIC8vIOayoWFwcGVuZOWRou+8jOivt+WOn+iwheaIkei/meagt+WGme+8jOa4heaZsH5cbiAgICBuZXdEb21TdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgbmV3RG9tU3R5bGUubGVmdCA9IDA7XG4gICAgbmV3RG9tU3R5bGUudG9wID0gMDtcbiAgICBuZXdEb21TdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBuZXdEb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIG5ld0RvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgIG5ld0RvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAvLyBpZOS4jeS9nOS4uue0ouW8leeUqO+8jOmBv+WFjeWPr+iDvemAoOaIkOeahOmHjeWQje+8jOWumuS5ieS4uuengeacieWxnuaAp1xuICAgIG5ld0RvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtenItZG9tLWlkJywgaWQpO1xuICAgIHJldHVybiBuZXdEb207XG59XG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0xheWVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyXG4gKiBAcGFyYW0ge251bWJlcn0gW2Rwcl1cbiAqL1xudmFyIExheWVyID0gZnVuY3Rpb24oaWQsIHBhaW50ZXIsIGRwcikge1xuICAgIHZhciBkb207XG4gICAgZHByID0gZHByIHx8IGRldmljZVBpeGVsUmF0aW87XG4gICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZG9tID0gY3JlYXRlRG9tKGlkLCBwYWludGVyLCBkcHIpO1xuICAgIH1cbiAgICAvLyBOb3QgdXNpbmcgaXNEb20gYmVjYXVzZSBpbiBub2RlIGl0IHdpbGwgcmV0dXJuIGZhbHNlXG4gICAgZWxzZSBpZiAodXRpbC5pc09iamVjdChpZCkpIHtcbiAgICAgICAgZG9tID0gaWQ7XG4gICAgICAgIGlkID0gZG9tLmlkO1xuICAgIH1cbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5kb20gPSBkb207XG5cbiAgICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG4gICAgaWYgKGRvbVN0eWxlKSB7IC8vIE5vdCBpbiBub2RlXG4gICAgICAgIGRvbS5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gJ25vbmUnO1xuICAgICAgICBkb21TdHlsZVsndXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICAgICAgZG9tU3R5bGVbJy13ZWJraXQtdG91Y2gtY2FsbG91dCddID0gJ25vbmUnO1xuICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIGRvbVN0eWxlWydwYWRkaW5nJ10gPSAwO1xuICAgICAgICBkb21TdHlsZVsnbWFyZ2luJ10gPSAwO1xuICAgICAgICBkb21TdHlsZVsnYm9yZGVyLXdpZHRoJ10gPSAwO1xuICAgIH1cblxuICAgIHRoaXMuZG9tQmFjayA9IG51bGw7XG4gICAgdGhpcy5jdHhCYWNrID0gbnVsbDtcblxuICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG5cbiAgICAvLyBDb25maWdzXG4gICAgLyoqXG4gICAgICog5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5jbGVhckNvbG9yID0gMDtcbiAgICAvKipcbiAgICAgKiDmmK/lkKblvIDlkK/liqjmgIHmqKHns4pcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHRoaXMubW90aW9uQmx1ciA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjdcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RGcmFtZUFscGhhID0gMC43O1xuXG4gICAgLyoqXG4gICAgICogTGF5ZXIgZHByXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRwciA9IGRwcjtcbn07XG5cbkxheWVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBMYXllcixcblxuICAgIGVsQ291bnQ6IDAsXG5cbiAgICBfX2RpcnR5OiB0cnVlLFxuXG4gICAgaW5pdENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jdHggPSB0aGlzLmRvbS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLmN0eC5fX2N1cnJlbnRWYWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jdHguZHByID0gdGhpcy5kcHI7XG4gICAgfSxcblxuICAgIGNyZWF0ZUJhY2tCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgICAgIHRoaXMuZG9tQmFjayA9IGNyZWF0ZURvbSgnYmFjay0nICsgdGhpcy5pZCwgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgICAgICB0aGlzLmN0eEJhY2sgPSB0aGlzLmRvbUJhY2suZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy5jdHhCYWNrLl9fY3VycmVudFZhbHVlcyA9IHt9O1xuXG4gICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICAgICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG5cbiAgICAgICAgZG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIGRvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgICAgZG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgIGRvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgICAgaWYgKGRvbUJhY2spIHtcbiAgICAgICAgICAgIGRvbUJhY2sud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgICAgIGRvbUJhY2suaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICBpZiAoZHByICE9IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOa4heepuuivpeWxgueUu+W4g1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJBbGwgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uIChjbGVhckFsbCkge1xuICAgICAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgdmFyIHdpZHRoID0gZG9tLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZG9tLmhlaWdodDtcblxuICAgICAgICB2YXIgY2xlYXJDb2xvciA9IHRoaXMuY2xlYXJDb2xvcjtcbiAgICAgICAgdmFyIGhhdmVNb3Rpb25CTHVyID0gdGhpcy5tb3Rpb25CbHVyICYmICFjbGVhckFsbDtcbiAgICAgICAgdmFyIGxhc3RGcmFtZUFscGhhID0gdGhpcy5sYXN0RnJhbWVBbHBoYTtcblxuICAgICAgICB2YXIgZHByID0gdGhpcy5kcHI7XG5cbiAgICAgICAgaWYgKGhhdmVNb3Rpb25CTHVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZG9tQmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlQmFja0J1ZmZlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN0eEJhY2suZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICAgICAgdGhpcy5jdHhCYWNrLmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICBkb20sIDAsIDAsXG4gICAgICAgICAgICAgICAgd2lkdGggLyBkcHIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0IC8gZHByXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgaWYgKGNsZWFyQ29sb3IpIHtcbiAgICAgICAgICAgIHZhciBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47XG4gICAgICAgICAgICAvLyBHcmFkaWVudFxuICAgICAgICAgICAgaWYgKGNsZWFyQ29sb3IuY29sb3JTdG9wcykge1xuICAgICAgICAgICAgICAgIC8vIENhY2hlIGNhbnZhcyBncmFkaWVudFxuICAgICAgICAgICAgICAgIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiA9IGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCB8fCBTdHlsZS5nZXRHcmFkaWVudChjdHgsIGNsZWFyQ29sb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY2xlYXJDb2xvci5fX2NhbnZhc0dyYWRpZW50ID0gY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGF0dGVyblxuICAgICAgICAgICAgZWxzZSBpZiAoY2xlYXJDb2xvci5pbWFnZSkge1xuICAgICAgICAgICAgICAgIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiA9IFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm4uY2FsbChjbGVhckNvbG9yLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gfHwgY2xlYXJDb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgIHZhciBkb21CYWNrID0gdGhpcy5kb21CYWNrO1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxhc3RGcmFtZUFscGhhO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShkb21CYWNrLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMYXllcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvTGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogRGVmYXVsdCBjYW52YXMgcGFpbnRlclxuICogQG1vZHVsZSB6cmVuZGVyL1BhaW50ZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuaW1wb3J0IHtkZXZpY2VQaXhlbFJhdGlvfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vY29yZS91dGlsJztcbmltcG9ydCBsb2cgZnJvbSAnLi9jb3JlL2xvZyc7XG5pbXBvcnQgQm91bmRpbmdSZWN0IGZyb20gJy4vY29yZS9Cb3VuZGluZ1JlY3QnO1xuaW1wb3J0IHRpbXNvcnQgZnJvbSAnLi9jb3JlL3RpbXNvcnQnO1xuaW1wb3J0IExheWVyIGZyb20gJy4vTGF5ZXInO1xuaW1wb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tICcuL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnO1xuaW1wb3J0IEltYWdlIGZyb20gJy4vZ3JhcGhpYy9JbWFnZSc7XG5cbi8vIFBFTkRJR05cbi8vIExheWVyIGV4Y2VlZHMgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiBtYXkgaGF2ZSBzb21lIHByb2JsZW0gd2hlbiBmbHVzaCBkaXJlY3RseSBzZWNvbmQgdGltZS5cbi8vXG4vLyBNYXhpbXVtIHByb2dyZXNzaXZlIGxheWVyLiBXaGVuIGV4Y2VlZGluZyB0aGlzIG51bWJlci4gQWxsIGVsZW1lbnRzIHdpbGwgYmUgZHJhd2VkIGluIHRoZSBsYXN0IGxheWVyLlxudmFyIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgPSA1O1xuXG5mdW5jdGlvbiBwYXJzZUludDEwKHZhbCkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNMYXllclZhbGlkKGxheWVyKSB7XG4gICAgaWYgKCFsYXllcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YobGF5ZXIucmVzaXplKSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICB8fCB0eXBlb2YobGF5ZXIucmVmcmVzaCkgIT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBwcmVQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICBsYXllci5fX3VudXNlZENvdW50Kys7XG59XG5cbmZ1bmN0aW9uIHBvc3RQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICBpZiAobGF5ZXIuX191bnVzZWRDb3VudCA9PSAxKSB7XG4gICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgfVxufVxuXG52YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG52YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuZnVuY3Rpb24gaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRtcFJlY3QuY29weShlbC5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSk7XG4gICAgfVxuICAgIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gICAgdmlld1JlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiAhdG1wUmVjdC5pbnRlcnNlY3Qodmlld1JlY3QpO1xufVxuXG5mdW5jdGlvbiBpc0NsaXBQYXRoQ2hhbmdlZChjbGlwUGF0aHMsIHByZXZDbGlwUGF0aHMpIHtcbiAgICBpZiAoY2xpcFBhdGhzID09IHByZXZDbGlwUGF0aHMpIHsgLy8gQ2FuIGJvdGggYmUgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghY2xpcFBhdGhzIHx8ICFwcmV2Q2xpcFBhdGhzIHx8IChjbGlwUGF0aHMubGVuZ3RoICE9PSBwcmV2Q2xpcFBhdGhzLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG5cbiAgICAgICAgY2xpcFBhdGguc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY2xpcFBhdGguYnVpbGRQYXRoKGN0eCwgY2xpcFBhdGguc2hhcGUpO1xuICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICAvLyBUcmFuc2Zvcm0gYmFja1xuICAgICAgICBjbGlwUGF0aC5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSb290KHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZG9tUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgLy8gZG9tUm9vdC5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuICAgIGRvbVJvb3Quc3R5bGUuY3NzVGV4dCA9IFtcbiAgICAgICAgJ3Bvc2l0aW9uOnJlbGF0aXZlJyxcbiAgICAgICAgJ292ZXJmbG93OmhpZGRlbicsXG4gICAgICAgICd3aWR0aDonICsgd2lkdGggKyAncHgnLFxuICAgICAgICAnaGVpZ2h0OicgKyBoZWlnaHQgKyAncHgnLFxuICAgICAgICAncGFkZGluZzowJyxcbiAgICAgICAgJ21hcmdpbjowJyxcbiAgICAgICAgJ2JvcmRlci13aWR0aDowJ1xuICAgIF0uam9pbignOycpICsgJzsnO1xuXG4gICAgcmV0dXJuIGRvbVJvb3Q7XG59XG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1BhaW50ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm9vdCDnu5jlm77lrrnlmahcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX0gc3RvcmFnZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xudmFyIFBhaW50ZXIgPSBmdW5jdGlvbiAocm9vdCwgc3RvcmFnZSwgb3B0cykge1xuXG4gICAgdGhpcy50eXBlID0gJ2NhbnZhcyc7XG5cbiAgICAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG4gICAgdmFyIHNpbmdsZUNhbnZhcyA9ICFyb290Lm5vZGVOYW1lIC8vIEluIG5vZGUgP1xuICAgICAgICB8fCByb290Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnO1xuXG4gICAgdGhpcy5fb3B0cyA9IG9wdHMgPSB1dGlsLmV4dGVuZCh7fSwgb3B0cyB8fCB7fSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHByID0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIHx8IGRldmljZVBpeGVsUmF0aW87XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zaW5nbGVDYW52YXMgPSBzaW5nbGVDYW52YXM7XG4gICAgLyoqXG4gICAgICog57uY5Zu+5a655ZmoXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cbiAgICB2YXIgcm9vdFN0eWxlID0gcm9vdC5zdHlsZTtcblxuICAgIGlmIChyb290U3R5bGUpIHtcbiAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIHJvb3RTdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID1cbiAgICAgICAgcm9vdFN0eWxlWyd1c2VyLXNlbGVjdCddID1cbiAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcblxuICAgICAgICByb290LmlubmVySFRNTCA9ICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfVxuICAgICAqL1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3QgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvTGF5ZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBPYmplY3Q+fVxuICAgICAqIEB0eXBlIHtwcml2YXRlfVxuICAgICAqL1xuICAgIHRoaXMuX2xheWVyQ29uZmlnID0ge307XG5cbiAgICBpZiAoIXNpbmdsZUNhbnZhcykge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG5cbiAgICAgICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290ID0gY3JlYXRlUm9vdChcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChkb21Sb290KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChvcHRzLndpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJvb3Qud2lkdGggPSBvcHRzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICByb290LmhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBjYW52YXMgd2lkdGggYW5kIGhlaWdodCBkaXJlY3RseVxuICAgICAgICB2YXIgd2lkdGggPSByb290LndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcm9vdC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyBDcmVhdGUgbGF5ZXIgaWYgb25seSBvbmUgZ2l2ZW4gY2FudmFzXG4gICAgICAgIC8vIERldmljZSBwaXhlbCByYXRpbyBpcyBmaXhlZCB0byAxIGJlY2F1c2UgZ2l2ZW4gY2FudmFzIGhhcyBpdHMgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICAgICAgbWFpbkxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgIC8vIEZJWE1FIFVzZSBjYW52YXMgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAvLyBtYWluTGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBsYXllcnNbMF0gPSBtYWluTGF5ZXI7XG4gICAgICAgIHpsZXZlbExpc3QucHVzaCgwKTtcblxuICAgICAgICB0aGlzLl9kb21Sb290ID0gcm9vdDtcbiAgICB9XG5cbiAgICAvLyBMYXllcnMgZm9yIHByb2dyZXNzaXZlIHJlbmRlcmluZ1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9ob3ZlcmxheWVyO1xuXG4gICAgdGhpcy5faG92ZXJFbGVtZW50cyA9IFtdO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogUGFpbnRlcixcblxuICAgIGdldFR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdjYW52YXMnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiBwYWludGVyIHVzZSBhIHNpbmdsZSBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzU2luZ2xlQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaW5nbGVDYW52YXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtIVE1MRGl2RWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXRWaWV3cG9ydFJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvbVJvb3Q7XG4gICAgfSxcblxuICAgIGdldFZpZXdwb3J0Um9vdE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmlld3BvcnRSb290ID0gdGhpcy5nZXRWaWV3cG9ydFJvb3QoKTtcbiAgICAgICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0OiB2aWV3cG9ydFJvb3Qub2Zmc2V0TGVmdCB8fCAwLFxuICAgICAgICAgICAgICAgIG9mZnNldFRvcDogdmlld3BvcnRSb290Lm9mZnNldFRvcCB8fCAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOWIt+aWsFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhaW50QWxsPWZhbHNlXSDlvLrliLbnu5jliLbmiYDmnIlkaXNwbGF5YWJsZVxuICAgICAqL1xuICAgIHJlZnJlc2g6IGZ1bmN0aW9uIChwYWludEFsbCkge1xuXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuXG4gICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcblxuICAgICAgICB0aGlzLl9wYWludExpc3QobGlzdCwgcGFpbnRBbGwpO1xuXG4gICAgICAgIC8vIFBhaW50IGN1c3R1bSBsYXllcnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIGxheWVyLnJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICBsYXllci5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuXG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0UHJvZ2Vzc2l2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIGhvdmVyU3R5bGUpIHtcbiAgICAgICAgaWYgKGVsLl9faG92ZXJNaXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxNaXJyb3IgPSBuZXcgZWwuY29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgc3R5bGU6IGVsLnN0eWxlLFxuICAgICAgICAgICAgc2hhcGU6IGVsLnNoYXBlXG4gICAgICAgIH0pO1xuICAgICAgICBlbE1pcnJvci5fX2Zyb20gPSBlbDtcbiAgICAgICAgZWwuX19ob3Zlck1pciA9IGVsTWlycm9yO1xuICAgICAgICBlbE1pcnJvci5zZXRTdHlsZShob3ZlclN0eWxlKTtcbiAgICAgICAgdGhpcy5faG92ZXJFbGVtZW50cy5wdXNoKGVsTWlycm9yKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgZWxNaXJyb3IgPSBlbC5fX2hvdmVyTWlyO1xuICAgICAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YoaG92ZXJFbGVtZW50cywgZWxNaXJyb3IpO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuX19ob3Zlck1pciA9IG51bGw7XG4gICAgfSxcblxuICAgIGNsZWFySG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG92ZXJFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZyb20gPSBob3ZlckVsZW1lbnRzW2ldLl9fZnJvbTtcbiAgICAgICAgICAgIGlmIChmcm9tKSB7XG4gICAgICAgICAgICAgICAgZnJvbS5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBob3ZlckVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgfSxcblxuICAgIHJlZnJlc2hIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgICAgIHZhciBsZW4gPSBob3ZlckVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGhvdmVyTGF5ZXIgPSB0aGlzLl9ob3ZlcmxheWVyO1xuICAgICAgICBob3ZlckxheWVyICYmIGhvdmVyTGF5ZXIuY2xlYXIoKTtcblxuICAgICAgICBpZiAoIWxlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbXNvcnQoaG92ZXJFbGVtZW50cywgdGhpcy5zdG9yYWdlLmRpc3BsYXlhYmxlU29ydEZ1bmMpO1xuXG4gICAgICAgIC8vIFVzZSBhIGV4dHJlYW0gbGFyZ2UgemxldmVsXG4gICAgICAgIC8vIEZJWE1FP1xuICAgICAgICBpZiAoIWhvdmVyTGF5ZXIpIHtcbiAgICAgICAgICAgIGhvdmVyTGF5ZXIgPSB0aGlzLl9ob3ZlcmxheWVyID0gdGhpcy5nZXRMYXllcigxZTUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICAgIGhvdmVyTGF5ZXIuY3R4LnNhdmUoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBob3ZlckVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRWwgPSBlbC5fX2Zyb207XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBlbCBpcyByZW1vdmVkXG4gICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICBpZiAoIShvcmlnaW5hbEVsICYmIG9yaWdpbmFsRWwuX196cikpIHtcbiAgICAgICAgICAgICAgICBob3ZlckVsZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICAvLyBVc2UgdHJhbnNmb3JtXG4gICAgICAgICAgICAvLyBGSVhNRSBzdHlsZSBhbmQgc2hhcGUgP1xuICAgICAgICAgICAgaWYgKCFvcmlnaW5hbEVsLmludmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGVsLnRyYW5zZm9ybSA9IG9yaWdpbmFsRWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIGVsLmludlRyYW5zZm9ybSA9IG9yaWdpbmFsRWwuaW52VHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIGVsLl9fY2xpcFBhdGhzID0gb3JpZ2luYWxFbC5fX2NsaXBQYXRocztcbiAgICAgICAgICAgICAgICAvLyBlbC5cbiAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGhvdmVyTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBob3ZlckxheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIF9zdGFydFByb2dlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICghc2VsZi5fZnVydGhlclByb2dyZXNzaXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgYSB0b2tlbiB0byBzdG9wIHByb2dyZXNzIHN0ZXBzIHRyaWdnZXJlZCBieVxuICAgICAgICAvLyBwcmV2aW91cyB6ci5yZWZyZXNoIGNhbGxpbmcuXG4gICAgICAgIHZhciB0b2tlbiA9IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSArbmV3IERhdGUoKTtcblxuICAgICAgICBzZWxmLl9wcm9ncmVzcysrO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG5cbiAgICAgICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgcmVmcmVzaGVkIG9yIGRpc3Bvc2VkXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gJiYgc2VsZi5zdG9yYWdlKSB7XG5cbiAgICAgICAgICAgICAgICBzZWxmLl9kb1BhaW50TGlzdChzZWxmLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fZnVydGhlclByb2dyZXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NsZWFyUHJvZ3Jlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVUb2tlbiA9IC0xO1xuICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IDA7XG4gICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBsYXllci5fX2RpcnR5ICYmIGxheWVyLmNsZWFyKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcblxuICAgICAgICBpZiAocGFpbnRBbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFpbnRBbGwgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyU3RhdHVzKGxpc3QpO1xuXG4gICAgICAgIHRoaXMuX2NsZWFyUHJvZ3Jlc3NpdmUoKTtcblxuICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocHJlUHJvY2Vzc0xheWVyKTtcblxuICAgICAgICB0aGlzLl9kb1BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICAgICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHBvc3RQcm9jZXNzTGF5ZXIpO1xuICAgIH0sXG5cbiAgICBfZG9QYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuICAgICAgICB2YXIgY3VycmVudExheWVyO1xuICAgICAgICB2YXIgY3VycmVudFpMZXZlbDtcbiAgICAgICAgdmFyIGN0eDtcblxuICAgICAgICAvLyB2YXIgaW52VHJhbnNmb3JtID0gW107XG4gICAgICAgIHZhciBzY29wZTtcblxuICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllcklkeCA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcblxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgdmFyIGxheWVyUHJvZ3Jlc3M7XG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMuX3Byb2dyZXNzO1xuICAgICAgICBmdW5jdGlvbiBmbHVzaFByb2dyZXNzaXZlTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgICAgIC8vIEF2b2lkIGxheWVyIGRvbid0IGNsZWFyIGluIG5leHQgcHJvZ3Jlc3NpdmUgZnJhbWVcbiAgICAgICAgICAgIGN1cnJlbnRMYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGxheWVyLmRvbSwgMCwgMCwgd2lkdGggKiBkcHIsIGhlaWdodCAqIGRwcik7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBlbFpMZXZlbCA9IHRoaXMuX3NpbmdsZUNhbnZhcyA/IDAgOiBlbC56bGV2ZWw7XG5cbiAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZTtcblxuICAgICAgICAgICAgLy8gRmx1c2ggYXQgY3VycmVudCBjb250ZXh0XG4gICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICBpZiAoZWxGcmFtZSA8IDAgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hhbmdlIGRyYXcgbGF5ZXJcbiAgICAgICAgICAgIGlmIChjdXJyZW50WkxldmVsICE9PSBlbFpMZXZlbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXNldCBzY29wZVxuICAgICAgICAgICAgICAgIHNjb3BlID0ge307XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IDAgemxldmVsIGlmIG9ubHkgaGFzIG9uZSBjYW52YXNcbiAgICAgICAgICAgICAgICBjdXJyZW50WkxldmVsID0gZWxaTGV2ZWw7XG4gICAgICAgICAgICAgICAgY3VycmVudExheWVyID0gdGhpcy5nZXRMYXllcihjdXJyZW50WkxldmVsKTtcblxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudExheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICdaTGV2ZWwgJyArIGN1cnJlbnRaTGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJyBoYXMgYmVlbiB1c2VkIGJ5IHVua293biBsYXllciAnICsgY3VycmVudExheWVyLmlkXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNvdW50XG4gICAgICAgICAgICAgICAgY3VycmVudExheWVyLl9fdW51c2VkQ291bnQgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllci5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoY3VycmVudExheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbEZyYW1lID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBQcm9ncmVzc2l2ZSBsYXllciBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzW1xuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllcklkeCsrLCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPiBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBRdWljayBqdW1wIGFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIHByb2dyZXNzaXZlIGVsZW1lbnQgYXJlIG5vdCBkaXJ0eSwganVtcCBvdmVyIGFuZCBmbHVzaCBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsYXllclByb2dyZXNzID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGxheWVyUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzID0gZnJhbWUgKyAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbEZyYW1lID09PSBmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLCB0cnVlLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBjdXJyZW50TGF5ZXIsIHBhaW50QWxsLCBzY29wZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIGxhc3RMYXllciBjdHhcbiAgICAgICAgY3R4ICYmIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIC8vIElmIHN0aWxsIGhhcyBjbGlwcGluZyBzdGF0ZVxuICAgICAgICAvLyBpZiAoc2NvcGUucHJldkVsQ2xpcFBhdGhzKSB7XG4gICAgICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgdGhpcy5fZnVydGhlclByb2dyZXNzaXZlID0gZmFsc2U7XG4gICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBsYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVydGhlclByb2dyZXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgICAgICB2YXIgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICAgICAgdmFyIG0gPSBlbC50cmFuc2Zvcm07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBmb3JjZVBhaW50KVxuICAgICAgICAgICAgLy8gSWdub3JlIGludmlzaWJsZSBlbGVtZW50XG4gICAgICAgICAgICAmJiAhZWwuaW52aXNpYmxlXG4gICAgICAgICAgICAvLyBJZ25vcmUgdHJhbnNwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgJiYgZWwuc3R5bGUub3BhY2l0eSAhPT0gMFxuICAgICAgICAgICAgLy8gSWdub3JlIHNjYWxlIDAgZWxlbWVudCwgaW4gc29tZSBlbnZpcm9ubWVudCBsaWtlIG5vZGUtY2FudmFzXG4gICAgICAgICAgICAvLyBEcmF3IGEgc2NhbGUgMCBlbGVtZW50IGNhbiBjYXVzZSBhbGwgZm9sbG93aW5nIGRyYXcgd3JvbmdcbiAgICAgICAgICAgIC8vIEFuZCBzZXRUcmFuc2Zvcm0gd2l0aCBzY2FsZSAwIHdpbGwgY2F1c2Ugc2V0IGJhY2sgdHJhbnNmb3JtIGZhaWxlZC5cbiAgICAgICAgICAgICYmICEobSAmJiAhbVswXSAmJiAhbVszXSlcbiAgICAgICAgICAgIC8vIElnbm9yZSBjdWxsZWQgZWxlbWVudFxuICAgICAgICAgICAgJiYgIShlbC5jdWxsaW5nICYmIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpKVxuICAgICAgICApIHtcblxuICAgICAgICAgICAgdmFyIGNsaXBQYXRocyA9IGVsLl9fY2xpcFBhdGhzO1xuXG4gICAgICAgICAgICAvLyBPcHRpbWl6ZSB3aGVuIGNsaXBwaW5nIG9uIGdyb3VwIHdpdGggc2V2ZXJhbCBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKHNjb3BlLnByZXZDbGlwTGF5ZXIgIT09IGN1cnJlbnRMYXllclxuICAgICAgICAgICAgICAgIHx8IGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgc2NvcGUucHJldkVsQ2xpcFBhdGhzKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaGFzIHByZXZpb3VzIGNsaXBwaW5nIHN0YXRlLCByZXN0b3JlIGZyb20gaXRcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUucHJldkVsQ2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZDbGlwTGF5ZXIuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IHNjb3BlLnByZXZFbENsaXBQYXRocyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgcHJldkVsIHNpbmNlIGNvbnRleHQgaGFzIGJlZW4gcmVzdG9yZWRcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkVsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTmV3IGNsaXBwaW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyID0gY3VycmVudExheWVyO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2RWxDbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuYmVmb3JlQnJ1c2ggJiYgZWwuYmVmb3JlQnJ1c2goY3R4KTtcblxuICAgICAgICAgICAgZWwuYnJ1c2goY3R4LCBzY29wZS5wcmV2RWwgfHwgbnVsbCk7XG4gICAgICAgICAgICBzY29wZS5wcmV2RWwgPSBlbDtcblxuICAgICAgICAgICAgZWwuYWZ0ZXJCcnVzaCAmJiBlbC5hZnRlckJydXNoKGN0eCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog6I635Y+WIHpsZXZlbCDmiYDlnKjlsYLvvIzlpoLmnpzkuI3lrZjlnKjliJnkvJrliJvlu7rkuIDkuKrmlrDnmoTlsYJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAgICovXG4gICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbGF5ZXJcbiAgICAgICAgICAgIGxheWVyID0gbmV3IExheWVyKCd6cl8nICsgemxldmVsLCB0aGlzLCB0aGlzLmRwcik7XG4gICAgICAgICAgICBsYXllci5fX2J1aWx0aW5fXyA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXllckNvbmZpZ1t6bGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0TGF5ZXIoemxldmVsLCBsYXllcik7XG5cbiAgICAgICAgICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgICAgICAgIC8vIE9yIGV4Y2FudmFzIHdpbGwgZ2V0IDBweCBjbGllbnRXaWR0aCBhbmQgY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICBsYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH0sXG5cbiAgICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcblxuICAgICAgICB2YXIgbGF5ZXJzTWFwID0gdGhpcy5fbGF5ZXJzO1xuICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgICAgIHZhciBsZW4gPSB6bGV2ZWxMaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHByZXZMYXllciA9IG51bGw7XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDtcblxuICAgICAgICBpZiAobGF5ZXJzTWFwW3psZXZlbF0pIHtcbiAgICAgICAgICAgIGxvZygnWkxldmVsICcgKyB6bGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYWxyZWFkeScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIGlzIGEgdmFsaWQgbGF5ZXJcbiAgICAgICAgaWYgKCFpc0xheWVyVmFsaWQobGF5ZXIpKSB7XG4gICAgICAgICAgICBsb2coJ0xheWVyIG9mIHpsZXZlbCAnICsgemxldmVsICsgJyBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW4gPiAwICYmIHpsZXZlbCA+IHpsZXZlbExpc3RbMF0pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHpsZXZlbExpc3RbaV0gPCB6bGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgJiYgemxldmVsTGlzdFtpICsgMV0gPiB6bGV2ZWxcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkxheWVyID0gbGF5ZXJzTWFwW3psZXZlbExpc3RbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKGkgKyAxLCAwLCB6bGV2ZWwpO1xuXG4gICAgICAgIGxheWVyc01hcFt6bGV2ZWxdID0gbGF5ZXI7XG5cbiAgICAgICAgLy8gVml0dWFsIGxheWVyIHdpbGwgbm90IGRpcmVjdGx5IHNob3cgb24gdGhlIHNjcmVlbi5cbiAgICAgICAgLy8gKEl0IGNhbiBiZSBhIFdlYkdMIGxheWVyIGFuZCBhc3NpZ25lZCB0byBhIFpJbWFnZSBlbGVtZW50KVxuICAgICAgICAvLyBCdXQgaXQgc3RpbGwgdW5kZXIgbWFuYWdlbWVudCBvZiB6cmVuZGVyLlxuICAgICAgICBpZiAoIWxheWVyLnZpcnR1YWwpIHtcbiAgICAgICAgICAgIGlmIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldkRvbSA9IHByZXZMYXllci5kb207XG4gICAgICAgICAgICAgICAgaWYgKHByZXZEb20ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci5kb20sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2RG9tLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbVJvb3QuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShsYXllci5kb20sIGRvbVJvb3QuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEl0ZXJhdGUgZWFjaCBsYXllclxuICAgIGVhY2hMYXllcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgdmFyIHo7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1t6XSwgeik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gSXRlcmF0ZSBlYWNoIGJ1aWxkaW4gbGF5ZXJcbiAgICBlYWNoQnVpbHRpbkxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICB2YXIgbGF5ZXI7XG4gICAgICAgIHZhciB6O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICBpZiAobGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBJdGVyYXRlIGVhY2ggb3RoZXIgbGF5ZXIgZXhjZXB0IGJ1aWxkaW4gbGF5ZXJcbiAgICBlYWNoT3RoZXJMYXllcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgdmFyIGxheWVyO1xuICAgICAgICB2YXIgejtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOiOt+WPluaJgOacieW3suWIm+W7uueahOWxglxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0xheWVyPn0gW3ByZXZMYXllcl1cbiAgICAgKi9cbiAgICBnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVycztcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUxheWVyU3RhdHVzOiBmdW5jdGlvbiAobGlzdCkge1xuXG4gICAgICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVycyA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzO1xuXG4gICAgICAgIHZhciBlbENvdW50c0xhc3RGcmFtZSA9IHt9O1xuICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVFbENvdW50c0xhc3RGcmFtZSA9IHt9O1xuXG4gICAgICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihmdW5jdGlvbiAobGF5ZXIsIHopIHtcbiAgICAgICAgICAgIGVsQ291bnRzTGFzdEZyYW1lW3pdID0gbGF5ZXIuZWxDb3VudDtcbiAgICAgICAgICAgIGxheWVyLmVsQ291bnQgPSAwO1xuICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICAgICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICAgICAgICBsYXllci5fX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVyQ291bnQgPSAwO1xuICAgICAgICB2YXIgY3VycmVudFByb2dyZXNzaXZlTGF5ZXI7XG4gICAgICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgICAgIHZhciBmcmFtZUNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgIHZhciB6bGV2ZWwgPSB0aGlzLl9zaW5nbGVDYW52YXMgPyAwIDogZWwuemxldmVsO1xuICAgICAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW3psZXZlbF07XG4gICAgICAgICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZWxDb3VudCsrO1xuICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBsYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vLy8vLy8gVXBkYXRlIHByb2dyZXNzaXZlXG4gICAgICAgICAgICBpZiAoZWxQcm9ncmVzcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRml4IHdyb25nIHByb2dyZXNzaXZlIHNlcXVlbmNlIHByb2JsZW0uXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQcm9ncmVzc2l2ZUtleSAhPT0gZWxQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IE1hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJDb3VudCwgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHByb2dyZXNzaXZlTGF5ZXJzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gcHJvZ3Jlc3NpdmVMYXllcnNbaWR4XSA9IG5ldyBMYXllcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvZ3Jlc3NpdmUnLCB0aGlzLCB0aGlzLmRwclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuZWxDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzID49IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuX19mcmFtZSA9IC0xO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgPSBpO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVyQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgcHJvZ3Jlc3NpdmVMYXllckNvdW50Kys7XG4gICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWxguS4reeahOWFg+e0oOaVsOmHj+acieWPkeeUn+WPmOWMllxuICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICAgICAgICBpZiAoZWxDb3VudHNMYXN0RnJhbWVbel0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSKTtcbiAgICAgICAgdXRpbC5lYWNoKHByb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIsIGlkeCkge1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWVbaWR4XSAhPT0gbGF5ZXIuZWxDb3VudCkge1xuICAgICAgICAgICAgICAgIGVsLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheWVyLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICBsYXllci5fX3Byb2dyZXNzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOa4hemZpGhvdmVy5bGC5aSW5omA5pyJ5YaF5a65XG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHRoaXMuX2NsZWFyTGF5ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2NsZWFyTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBsYXllci5jbGVhcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDkv67mlLnmjIflrpp6bGV2ZWznmoTnu5jliLblj4LmlbBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB6bGV2ZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIOmFjee9ruWvueixoVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0g5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0g5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubGFzdEZyYW1lQWxwaGE9MC43XVxuICAgICAqICAgICAgICAgICAgICAgICDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAqL1xuICAgIGNvbmZpZ0xheWVyOiBmdW5jdGlvbiAoemxldmVsLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIGxheWVyQ29uZmlnID0gdGhpcy5fbGF5ZXJDb25maWc7XG4gICAgICAgICAgICBpZiAoIWxheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllciwgbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbCDlsYLmiYDlnKjnmoR6bGV2ZWxcbiAgICAgKi9cbiAgICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXIuZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgZGVsZXRlIGxheWVyc1t6bGV2ZWxdO1xuXG4gICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG4gICAgICAgIC8vIEZJWE1FIFdoeSA/XG4gICAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAvLyBTYXZlIGlucHV0IHcvaFxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgICAgIHdpZHRoICE9IG51bGwgJiYgKG9wdHMud2lkdGggPSB3aWR0aCk7XG4gICAgICAgIGhlaWdodCAhPSBudWxsICYmIChvcHRzLmhlaWdodCA9IGhlaWdodCk7XG5cbiAgICAgICAgd2lkdGggPSB0aGlzLl9nZXRTaXplKDApO1xuICAgICAgICBoZWlnaHQgPSB0aGlzLl9nZXRTaXplKDEpO1xuXG4gICAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICAgIC8vIOS8mOWMluayoeacieWunumZheaUueWPmOeahHJlc2l6ZVxuICAgICAgICBpZiAodGhpcy5fd2lkdGggIT0gd2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMuX2hlaWdodCkge1xuICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDmuIXpmaTljZXni6znmoTkuIDkuKrlsYJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAgICovXG4gICAgY2xlYXJMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcbiAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICBsYXllci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOmHiuaUvlxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgIHRoaXMucm9vdCA9XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9XG5cbiAgICAgICAgdGhpcy5fZG9tUm9vdCA9XG4gICAgICAgIHRoaXMuX2xheWVycyA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMucGl4ZWxSYXRpb11cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZENhbnZhczogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbMF0uZG9tO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICAgICAgaW1hZ2VMYXllci5pbml0Q29udGV4dCgpO1xuXG4gICAgICAgIGltYWdlTGF5ZXIuY2xlYXJDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBpbWFnZUxheWVyLmNsZWFyKCk7XG5cbiAgICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuXG4gICAgICAgIHZhciBzY29wZSA9IHt9O1xuICAgICAgICB2YXIgemxldmVsO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gZmluZEFuZERyYXdPdGhlckxheWVyKHNtYWxsZXIsIGxhcmdlcikge1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSBzZWxmLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgaWYgKHNtYWxsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNtYWxsZXIgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW50ZXJtZWRpYXRlTGF5ZXI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gc2VsZi5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18gJiYgeiA+IHNtYWxsZXIgJiYgeiA8IGxhcmdlcikge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVMYXllciA9IGxheWVyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW50ZXJtZWRpYXRlTGF5ZXIgJiYgaW50ZXJtZWRpYXRlTGF5ZXIucmVuZGVyVG9DYW52YXMpIHtcbiAgICAgICAgICAgICAgICBpbWFnZUxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlTGF5ZXIucmVuZGVyVG9DYW52YXMoaW1hZ2VMYXllci5jdHgpO1xuICAgICAgICAgICAgICAgIGltYWdlTGF5ZXIuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBkaXNwbGF5TGlzdFtpXTtcblxuICAgICAgICAgICAgaWYgKGVsLnpsZXZlbCAhPT0gemxldmVsKSB7XG4gICAgICAgICAgICAgICAgZmluZEFuZERyYXdPdGhlckxheWVyKHpsZXZlbCwgZWwuemxldmVsKTtcbiAgICAgICAgICAgICAgICB6bGV2ZWwgPSBlbC56bGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGltYWdlTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmRBbmREcmF3T3RoZXJMYXllcih6bGV2ZWwsIEluZmluaXR5KTtcblxuICAgICAgICByZXR1cm4gaW1hZ2VMYXllci5kb207XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDojrflj5bnu5jlm77ljLrln5/lrr3luqZcbiAgICAgKi9cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOiOt+WPlue7mOWbvuWMuuWfn+mrmOW6plxuICAgICAqL1xuICAgIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgIH0sXG5cbiAgICBfZ2V0U2l6ZTogZnVuY3Rpb24gKHdoSWR4KSB7XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5fb3B0cztcbiAgICAgICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgICAgIHZhciBjd2ggPSBbJ2NsaWVudFdpZHRoJywgJ2NsaWVudEhlaWdodCddW3doSWR4XTtcbiAgICAgICAgdmFyIHBsdCA9IFsncGFkZGluZ0xlZnQnLCAncGFkZGluZ1RvcCddW3doSWR4XTtcbiAgICAgICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICAgICAgaWYgKG9wdHNbd2hdICE9IG51bGwgJiYgb3B0c1t3aF0gIT09ICdhdXRvJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQob3B0c1t3aF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgIC8vIElFOCBkb2VzIG5vdCBzdXBwb3J0IGdldENvbXB1dGVkU3R5bGUsIGJ1dCBpdCB1c2UgVk1MLlxuICAgICAgICB2YXIgc3RsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShyb290KTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJvb3RbY3doXSB8fCBwYXJzZUludDEwKHN0bFt3aF0pIHx8IHBhcnNlSW50MTAocm9vdC5zdHlsZVt3aF0pKVxuICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGxbcGx0XSkgfHwgMClcbiAgICAgICAgICAgIC0gKHBhcnNlSW50MTAoc3RsW3ByYl0pIHx8IDApXG4gICAgICAgICkgfCAwO1xuICAgIH0sXG5cbiAgICBwYXRoVG9JbWFnZTogZnVuY3Rpb24gKHBhdGgsIGRwcikge1xuICAgICAgICBkcHIgPSBkcHIgfHwgdGhpcy5kcHI7XG5cbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgdmFyIHN0eWxlID0gcGF0aC5zdHlsZTtcbiAgICAgICAgdmFyIHNoYWRvd0JsdXJTaXplID0gc3R5bGUuc2hhZG93Qmx1cjtcbiAgICAgICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRYO1xuICAgICAgICB2YXIgc2hhZG93T2Zmc2V0WSA9IHN0eWxlLnNoYWRvd09mZnNldFk7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5oYXNTdHJva2UoKSA/IHN0eWxlLmxpbmVXaWR0aCA6IDA7XG5cbiAgICAgICAgdmFyIGxlZnRNYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCAtc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICAgICAgdmFyIHJpZ2h0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICAgICAgdmFyIHRvcE1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIC1zaGFkb3dPZmZzZXRZICsgc2hhZG93Qmx1clNpemUpO1xuICAgICAgICB2YXIgYm90dG9tTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WSArIHNoYWRvd0JsdXJTaXplKTtcbiAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCArIGxlZnRNYXJnaW4gKyByaWdodE1hcmdpbjtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0ICsgdG9wTWFyZ2luICsgYm90dG9tTWFyZ2luO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgIGN0eC5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5kcHIgPSBkcHI7XG5cbiAgICAgICAgdmFyIHBhdGhUcmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogcGF0aC5wb3NpdGlvbixcbiAgICAgICAgICAgIHJvdGF0aW9uOiBwYXRoLnJvdGF0aW9uLFxuICAgICAgICAgICAgc2NhbGU6IHBhdGguc2NhbGVcbiAgICAgICAgfTtcbiAgICAgICAgcGF0aC5wb3NpdGlvbiA9IFtsZWZ0TWFyZ2luIC0gcmVjdC54LCB0b3BNYXJnaW4gLSByZWN0LnldO1xuICAgICAgICBwYXRoLnJvdGF0aW9uID0gMDtcbiAgICAgICAgcGF0aC5zY2FsZSA9IFsxLCAxXTtcbiAgICAgICAgcGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGguYnJ1c2goY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBJbWFnZVNoYXBlID0gSW1hZ2U7XG4gICAgICAgIHZhciBpbWdTaGFwZSA9IG5ldyBJbWFnZVNoYXBlKHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIGltYWdlOiBjYW52YXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHBhdGhUcmFuc2Zvcm0ucG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgaW1nU2hhcGUucG9zaXRpb24gPSBwYXRoLnBvc2l0aW9uID0gcGF0aFRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoVHJhbnNmb3JtLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIGltZ1NoYXBlLnJvdGF0aW9uID0gcGF0aC5yb3RhdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucm90YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aFRyYW5zZm9ybS5zY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbWdTaGFwZS5zY2FsZSA9IHBhdGguc2NhbGUgPSBwYXRoVHJhbnNmb3JtLnNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGltZ1NoYXBlO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFBhaW50ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL1BhaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogU3RvcmFnZeWGheWuueS7k+W6k+aooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL1N0b3JhZ2VcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogQGF1dGhvciBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZy8pXG4gKi9cblxuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL2NvcmUvdXRpbCc7XG5pbXBvcnQgZW52IGZyb20gJy4vY29yZS9lbnYnO1xuaW1wb3J0IEdyb3VwIGZyb20gJy4vY29udGFpbmVyL0dyb3VwJztcblxuLy8gVXNlIHRpbXNvcnQgYmVjYXVzZSBpbiBtb3N0IGNhc2UgZWxlbWVudHMgYXJlIHBhcnRpYWxseSBzb3J0ZWRcbi8vIGh0dHBzOi8vanNmaWRkbGUubmV0L3Bpc3NhbmcvanI0eDdtZG0vOC9cbmltcG9ydCB0aW1zb3J0IGZyb20gJy4vY29yZS90aW1zb3J0JztcblxuZnVuY3Rpb24gc2hhcGVDb21wYXJlRnVuYyhhLCBiKSB7XG4gICAgaWYgKGEuemxldmVsID09PSBiLnpsZXZlbCkge1xuICAgICAgICBpZiAoYS56ID09PSBiLnopIHtcbiAgICAgICAgICAgIC8vIGlmIChhLnoyID09PSBiLnoyKSB7XG4gICAgICAgICAgICAvLyAgICAgLy8gRklYTUUgU2xvdyBoYXMgcmVuZGVyaWR4IGNvbXBhcmVcbiAgICAgICAgICAgIC8vICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwODgzNDIxL3NvcnRpbmctaW4tamF2YXNjcmlwdC1zaG91bGQtZXZlcnktY29tcGFyZS1mdW5jdGlvbi1oYXZlLWEtcmV0dXJuLTAtc3RhdGVtZW50XG4gICAgICAgICAgICAvLyAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Y4L3Y4L2Jsb2IvNDdjY2U1NDRhMzFlZDU1NzdmZmUyOTYzZjY3YWNiNDE0NGVlMDIzMi9zcmMvanMvYXJyYXkuanMjTDEwMTJcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gYS5fX3JlbmRlcmlkeCAtIGIuX19yZW5kZXJpZHg7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICByZXR1cm4gYS56MiAtIGIuejI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEueiAtIGIuejtcbiAgICB9XG4gICAgcmV0dXJuIGEuemxldmVsIC0gYi56bGV2ZWw7XG59XG4vKipcbiAqIOWGheWuueS7k+W6kyAoTSlcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9TdG9yYWdlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHRoaXMuX3Jvb3RzID0gW107XG5cbiAgICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuXG4gICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xufTtcblxuU3RvcmFnZS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogU3RvcmFnZSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAqXG4gICAgICovXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290c1tpXS50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog6L+U5Zue5omA5pyJ5Zu+5b2i55qE57uY5Yi26Zif5YiXXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlPWZhbHNlXSDmmK/lkKblnKjov5Tlm57liY3mm7TmlrDor6XmlbDnu4RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hCwg5ZyoIHVwZGF0ZSDkuLogdHJ1ZSDnmoTml7blgJnmnInmlYhcbiAgICAgKlxuICAgICAqIOivpuingXtAbGluayBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5TGlzdH1cbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZT59XG4gICAgICovXG4gICAgZ2V0RGlzcGxheUxpc3Q6IGZ1bmN0aW9uICh1cGRhdGUsIGluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgaW5jbHVkZUlnbm9yZSA9IGluY2x1ZGVJZ25vcmUgfHwgZmFsc2U7XG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGlzcGxheUxpc3QoaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXlMaXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDmm7TmlrDlm77lvaLnmoTnu5jliLbpmJ/liJfjgIJcbiAgICAgKiDmr4/mrKHnu5jliLbliY3pg73kvJrosIPnlKjvvIzor6Xmlrnms5XkvJrlhYjmt7HluqbkvJjlhYjpgY3ljobmlbTkuKrmoJHvvIzmm7TmlrDmiYDmnIlHcm91cOWSjFNoYXBl55qE5Y+Y5o2i5bm25LiU5oqK5omA5pyJ5Y+v6KeB55qEU2hhcGXkv53lrZjliLDmlbDnu4TkuK3vvIxcbiAgICAgKiDmnIDlkI7moLnmja7nu5jliLbnmoTkvJjlhYjnuqfvvIh6bGV2ZWwgPiB6ID4g5o+S5YWl6aG65bqP77yJ5o6S5bqP5b6X5Yiw57uY5Yi26Zif5YiXXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUlnbm9yZT1mYWxzZV0g5piv5ZCm5YyF5ZCrIGlnbm9yZSDnmoTmlbDnu4RcbiAgICAgKi9cbiAgICB1cGRhdGVEaXNwbGF5TGlzdDogZnVuY3Rpb24gKGluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuICAgICAgICB2YXIgcm9vdHMgPSB0aGlzLl9yb290cztcbiAgICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5fZGlzcGxheUxpc3Q7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb290cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUocm9vdHNbaV0sIG51bGwsIGluY2x1ZGVJZ25vcmUpO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BsYXlMaXN0Lmxlbmd0aCA9IHRoaXMuX2Rpc3BsYXlMaXN0TGVuO1xuXG4gICAgICAgIC8vIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaXNwbGF5TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyAgICAgZGlzcGxheUxpc3RbaV0uX19yZW5kZXJpZHggPSBpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gZGlzcGxheUxpc3Quc29ydChzaGFwZUNvbXBhcmVGdW5jKTtcbiAgICAgICAgZW52LmNhbnZhc1N1cHBvcnRlZCAmJiB0aW1zb3J0KGRpc3BsYXlMaXN0LCBzaGFwZUNvbXBhcmVGdW5jKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlOiBmdW5jdGlvbiAoZWwsIGNsaXBQYXRocywgaW5jbHVkZUlnbm9yZSkge1xuXG4gICAgICAgIGlmIChlbC5pZ25vcmUgJiYgIWluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG5cbiAgICAgICAgICAgIGVsLnVwZGF0ZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBlbC5hZnRlclVwZGF0ZSgpO1xuXG4gICAgICAgIHZhciB1c2VyU2V0Q2xpcFBhdGggPSBlbC5jbGlwUGF0aDtcbiAgICAgICAgaWYgKHVzZXJTZXRDbGlwUGF0aCkge1xuXG4gICAgICAgICAgICAvLyBGSVhNRSDmlYjnjoflvbHlk41cbiAgICAgICAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aHMgPSBjbGlwUGF0aHMuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsaXBQYXRocyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VycmVudENsaXBQYXRoID0gdXNlclNldENsaXBQYXRoO1xuICAgICAgICAgICAgdmFyIHBhcmVudENsaXBQYXRoID0gZWw7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBhZGQgY2xpcCBwYXRoXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudENsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xpcFBhdGgg55qE5Y+Y5o2i5piv5Z+65LqO5L2/55So6L+Z5LiqIGNsaXBQYXRoIOeahOWFg+e0oFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDbGlwUGF0aC5wYXJlbnQgPSBwYXJlbnRDbGlwUGF0aDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2xpcFBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgICAgICBjbGlwUGF0aHMucHVzaChjdXJyZW50Q2xpcFBhdGgpO1xuXG4gICAgICAgICAgICAgICAgcGFyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGg7XG4gICAgICAgICAgICAgICAgY3VycmVudENsaXBQYXRoID0gY3VycmVudENsaXBQYXRoLmNsaXBQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLl9jaGlsZHJlbjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgdG8gbWFyayBhcyBkaXJ0eSBpZiBncm91cCBpcyBkaXJ0eVxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIF9fZGlydHlQYXRoID9cbiAgICAgICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShjaGlsZCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFyayBncm91cCBjbGVhbiBoZXJlXG4gICAgICAgICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLl9fY2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuXG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdFt0aGlzLl9kaXNwbGF5TGlzdExlbisrXSA9IGVsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOa3u+WKoOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXAp5Yiw5qC56IqC54K5XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAqL1xuICAgIGFkZFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoZWwuX19zdG9yYWdlID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgZWwuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2UodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkZFRvU3RvcmFnZShlbCk7XG4gICAgICAgIHRoaXMuX3Jvb3RzLnB1c2goZWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDliKDpmaTmjIflrprnmoTlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbZWxdIOWmguaenOS4uuepuua4heepuuaVtOS4qlN0b3JhZ2VcbiAgICAgKi9cbiAgICBkZWxSb290OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIOS4jeaMh+WummVs5riF56m6XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzID0gW107XG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbFJvb3QoZWxbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblxuICAgICAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKHRoaXMuX3Jvb3RzLCBlbCk7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZWxGcm9tU3RvcmFnZShlbCk7XG4gICAgICAgICAgICB0aGlzLl9yb290cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgZWwuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRUb1N0b3JhZ2U6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5fX3N0b3JhZ2UgPSB0aGlzO1xuICAgICAgICBlbC5kaXJ0eShmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGRlbEZyb21TdG9yYWdlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBlbC5fX3N0b3JhZ2UgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOa4heepuuW5tuS4lOmHiuaUvlN0b3JhZ2VcbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckxpc3QgPVxuICAgICAgICB0aGlzLl9yb290cyA9IG51bGw7XG4gICAgfSxcblxuICAgIGRpc3BsYXlhYmxlU29ydEZ1bmM6IHNoYXBlQ29tcGFyZUZ1bmNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFN0b3JhZ2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL1N0b3JhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog5Yqo55S75Li757G7LCDosIPluqblkoznrqHnkIbmiYDmnInliqjnlLvmjqfliLblmahcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBUT0RPIEFkZGl0aXZlIGFuaW1hdGlvblxuLy8gaHR0cDovL2lvc290ZXJpYy5jb20vYWRkaXRpdmUtYW5pbWF0aW9ucy1hbmltYXRld2l0aGR1cmF0aW9uLWluLWlvcy04L1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy93d2RjMjAxNC8jMjM2XG5cbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vY29yZS91dGlsJztcbmltcG9ydCB7RGlzcGF0Y2hlcn0gZnJvbSAnLi4vY29yZS9ldmVudCc7XG5pbXBvcnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZyb20gJy4vcmVxdWVzdEFuaW1hdGlvbkZyYW1lJztcbmltcG9ydCBBbmltYXRvciBmcm9tICcuL0FuaW1hdG9yJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJWlJlbmRlclN0YWdlXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cGRhdGVcbiAqL1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uZnJhbWVdXG4gKiBAcGFyYW0ge0laUmVuZGVyU3RhZ2V9IFtvcHRpb25zLnN0YWdlXVxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbigpO1xuICogICAgIHZhciBvYmogPSB7XG4gKiAgICAgICAgIHg6IDEwMCxcbiAqICAgICAgICAgeTogMTAwXG4gKiAgICAgfTtcbiAqICAgICBhbmltYXRpb24uYW5pbWF0ZShub2RlLnBvc2l0aW9uKVxuICogICAgICAgICAud2hlbigxMDAwLCB7XG4gKiAgICAgICAgICAgICB4OiA1MDAsXG4gKiAgICAgICAgICAgICB5OiA1MDBcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLndoZW4oMjAwMCwge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwXG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIC5zdGFydCgnc3BsaW5lJyk7XG4gKi9cbnZhciBBbmltYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLnN0YWdlID0gb3B0aW9ucy5zdGFnZSB8fCB7fTtcblxuICAgIHRoaXMub25mcmFtZSA9IG9wdGlvbnMub25mcmFtZSB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG4gICAgdGhpcy5fY2xpcHMgPSBbXTtcblxuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuX3RpbWU7XG5cbiAgICB0aGlzLl9wYXVzZWRUaW1lO1xuXG4gICAgdGhpcy5fcGF1c2VTdGFydDtcblxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgRGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xufTtcblxuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBBbmltYXRpb24sXG4gICAgLyoqXG4gICAgICog5re75YqgIGNsaXBcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAgICovXG4gICAgYWRkQ2xpcDogZnVuY3Rpb24gKGNsaXApIHtcbiAgICAgICAgdGhpcy5fY2xpcHMucHVzaChjbGlwKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOa3u+WKoCBhbmltYXRvclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfSBhbmltYXRvclxuICAgICAqL1xuICAgIGFkZEFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgICAgYW5pbWF0b3IuYW5pbWF0aW9uID0gdGhpcztcbiAgICAgICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRDbGlwKGNsaXBzW2ldKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgICAqL1xuICAgIHJlbW92ZUNsaXA6IGZ1bmN0aW9uKGNsaXApIHtcbiAgICAgICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9jbGlwcywgY2xpcCk7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY2xpcHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9IGFuaW1hdG9yXG4gICAgICovXG4gICAgcmVtb3ZlQW5pbWF0b3I6IGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgICAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNsaXAoY2xpcHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgfSxcblxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9wYXVzZWRUaW1lO1xuICAgICAgICB2YXIgZGVsdGEgPSB0aW1lIC0gdGhpcy5fdGltZTtcbiAgICAgICAgdmFyIGNsaXBzID0gdGhpcy5fY2xpcHM7XG4gICAgICAgIHZhciBsZW4gPSBjbGlwcy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGRlZmVycmVkRXZlbnRzID0gW107XG4gICAgICAgIHZhciBkZWZlcnJlZENsaXBzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjbGlwID0gY2xpcHNbaV07XG4gICAgICAgICAgICB2YXIgZSA9IGNsaXAuc3RlcCh0aW1lLCBkZWx0YSk7XG4gICAgICAgICAgICAvLyBUaHJvdyBvdXQgdGhlIGV2ZW50cyBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlclxuICAgICAgICAgICAgLy8gc3RhZ2UudXBkYXRlLCBsaWtlIGRlc3Ryb3lcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWRFdmVudHMucHVzaChlKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZENsaXBzLnB1c2goY2xpcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGZpbmlzaGVkIGNsaXBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICBpZiAoY2xpcHNbaV0uX25lZWRzUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgY2xpcHNbaV0gPSBjbGlwc1tsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICBjbGlwcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlbiA9IGRlZmVycmVkRXZlbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZGVmZXJyZWRDbGlwc1tpXS5maXJlKGRlZmVycmVkRXZlbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuXG4gICAgICAgIHRoaXMub25mcmFtZShkZWx0YSk7XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdmcmFtZScsIGRlbHRhKTtcblxuICAgICAgICBpZiAodGhpcy5zdGFnZS51cGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3N0YXJ0TG9vcDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9ydW5uaW5nKSB7XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG5cbiAgICAgICAgICAgICAgICAhc2VsZi5fcGF1c2VkICYmIHNlbGYuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDlvIDlp4vov5DooYzliqjnlLtcbiAgICAgKi9cbiAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMuX3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG5cbiAgICAgICAgdGhpcy5fc3RhcnRMb29wKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDlgZzmraLov5DooYzliqjnlLtcbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGF1c2VcbiAgICAgKi9cbiAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN1bWVcbiAgICAgKi9cbiAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSAobmV3IERhdGUoKS5nZXRUaW1lKCkpIC0gdGhpcy5fcGF1c2VTdGFydDtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOa4hemZpOaJgOacieWKqOeUu+eJh+autVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NsaXBzID0gW107XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDlr7nkuIDkuKrnm67moIfliJvlu7rkuIDkuKphbmltYXRvcuWvueixoe+8jOWPr+S7peaMh+Wumuebruagh+S4reeahOWxnuaAp+S9v+eUqOWKqOeUu1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMubG9vcD1mYWxzZV0g5piv5ZCm5b6q546v5pKt5pS+5Yqo55S7XG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLmdldHRlcj1udWxsXVxuICAgICAqICAgICAgICAg5aaC5p6c5oyH5a6aZ2V0dGVy5Ye95pWw77yM5Lya6YCa6L+HZ2V0dGVy5Ye95pWw5Y+W5bGe5oCn5YC8XG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLnNldHRlcj1udWxsXVxuICAgICAqICAgICAgICAg5aaC5p6c5oyH5a6ac2V0dGVy5Ye95pWw77yM5Lya6YCa6L+Hc2V0dGVy5Ye95pWw6K6+572u5bGe5oCn5YC8XG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvbn5BbmltYXRvcn1cbiAgICAgKi9cbiAgICAvLyBUT0RPIEdhcFxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgb3B0aW9ucy5sb29wLFxuICAgICAgICAgICAgb3B0aW9ucy5nZXR0ZXIsXG4gICAgICAgICAgICBvcHRpb25zLnNldHRlclxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuXG4gICAgICAgIHJldHVybiBhbmltYXRvcjtcbiAgICB9XG59O1xuXG51dGlsLm1peGluKEFuaW1hdGlvbiwgRGlzcGF0Y2hlcik7XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvYW5pbWF0aW9uL0FuaW1hdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDliqjnlLvkuLvmjqfliLblmahcbiAqIEBjb25maWcgdGFyZ2V0IOWKqOeUu+Wvueixoe+8jOWPr+S7peaYr+aVsOe7hO+8jOWmguaenOaYr+aVsOe7hOeahOivneS8muaJuemHj+WIhuWPkW9uZnJhbWXnrYnkuovku7ZcbiAqIEBjb25maWcgbGlmZSgxMDAwKSDliqjnlLvml7bplb9cbiAqIEBjb25maWcgZGVsYXkoMCkg5Yqo55S75bu26L+f5pe26Ze0XG4gKiBAY29uZmlnIGxvb3AodHJ1ZSlcbiAqIEBjb25maWcgZ2FwKDApIOW+queOr+eahOmXtOmalOaXtumXtFxuICogQGNvbmZpZyBvbmZyYW1lXG4gKiBAY29uZmlnIGVhc2luZyhvcHRpb25hbClcbiAqIEBjb25maWcgb25kZXN0cm95KG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbnJlc3RhcnQob3B0aW9uYWwpXG4gKlxuICogVE9ETyBwYXVzZVxuICovXG5cbmltcG9ydCBlYXNpbmdGdW5jcyBmcm9tICcuL2Vhc2luZyc7XG5cbmZ1bmN0aW9uIENsaXAob3B0aW9ucykge1xuXG4gICAgdGhpcy5fdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG5cbiAgICAvLyDnlJ/lkb3lkajmnJ9cbiAgICB0aGlzLl9saWZlID0gb3B0aW9ucy5saWZlIHx8IDEwMDA7XG4gICAgLy8g5bu25pe2XG4gICAgdGhpcy5fZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDA7XG4gICAgLy8g5byA5aeL5pe26Ze0XG4gICAgLy8gdGhpcy5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLl9kZWxheTsvLyDljZXkvY3mr6vnp5JcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgLy8g5piv5ZCm5b6q546vXG4gICAgdGhpcy5sb29wID0gb3B0aW9ucy5sb29wID09IG51bGwgPyBmYWxzZSA6IG9wdGlvbnMubG9vcDtcblxuICAgIHRoaXMuZ2FwID0gb3B0aW9ucy5nYXAgfHwgMDtcblxuICAgIHRoaXMuZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgJ0xpbmVhcic7XG5cbiAgICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWU7XG4gICAgdGhpcy5vbmRlc3Ryb3kgPSBvcHRpb25zLm9uZGVzdHJveTtcbiAgICB0aGlzLm9ucmVzdGFydCA9IG9wdGlvbnMub25yZXN0YXJ0O1xuXG4gICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG59XG5cbkNsaXAucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IENsaXAsXG5cbiAgICBzdGVwOiBmdW5jdGlvbiAoZ2xvYmFsVGltZSwgZGVsdGFUaW1lKSB7XG4gICAgICAgIC8vIFNldCBzdGFydFRpbWUgb24gZmlyc3Qgc3RlcCwgb3IgX3N0YXJ0VGltZSBtYXkgaGFzIG1pbGxlc2Vjb25kcyBkaWZmZXJlbnQgYmV0d2VlbiBjbGlwc1xuICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgKyB0aGlzLl9kZWxheTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZFRpbWUgKz0gZGVsdGFUaW1lO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBlcmNlbnQgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX3BhdXNlZFRpbWUpIC8gdGhpcy5fbGlmZTtcblxuICAgICAgICAvLyDov5jmsqHlvIDlp4tcbiAgICAgICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwZXJjZW50ID0gTWF0aC5taW4ocGVyY2VudCwgMSk7XG5cbiAgICAgICAgdmFyIGVhc2luZyA9IHRoaXMuZWFzaW5nO1xuICAgICAgICB2YXIgZWFzaW5nRnVuYyA9IHR5cGVvZiBlYXNpbmcgPT0gJ3N0cmluZycgPyBlYXNpbmdGdW5jc1tlYXNpbmddIDogZWFzaW5nO1xuICAgICAgICB2YXIgc2NoZWR1bGUgPSB0eXBlb2YgZWFzaW5nRnVuYyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBlYXNpbmdGdW5jKHBlcmNlbnQpXG4gICAgICAgICAgICA6IHBlcmNlbnQ7XG5cbiAgICAgICAgdGhpcy5maXJlKCdmcmFtZScsIHNjaGVkdWxlKTtcblxuICAgICAgICAvLyDnu5PmnZ9cbiAgICAgICAgaWYgKHBlcmNlbnQgPT0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9vcCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydCAoZ2xvYmFsVGltZSk7XG4gICAgICAgICAgICAgICAgLy8g6YeN5paw5byA5aeL5ZGo5pyfXG4gICAgICAgICAgICAgICAgLy8g5oqb5Ye66ICM5LiN5piv55u05o6l6LCD55So5LqL5Lu255u05YiwIHN0YWdlLnVwZGF0ZSDlkI7lho3nu5/kuIDosIPnlKjov5nkupvkuovku7ZcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3Jlc3RhcnQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDliqjnlLvlrozmiJDlsIbov5nkuKrmjqfliLblmajmoIfor4bkuLrlvoXliKDpmaRcbiAgICAgICAgICAgIC8vIOWcqEFuaW1hdGlvbi51cGRhdGXkuK3ov5vooYzmibnph4/liKDpmaRcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiAnZGVzdHJveSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgcmVzdGFydDogZnVuY3Rpb24gKGdsb2JhbFRpbWUpIHtcbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgJSB0aGlzLl9saWZlO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lIC0gcmVtYWluZGVyICsgdGhpcy5nYXA7XG4gICAgICAgIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuXG4gICAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gZmFsc2U7XG4gICAgfSxcblxuICAgIGZpcmU6IGZ1bmN0aW9uIChldmVudFR5cGUsIGFyZykge1xuICAgICAgICBldmVudFR5cGUgPSAnb24nICsgZXZlbnRUeXBlO1xuICAgICAgICBpZiAodGhpc1tldmVudFR5cGVdKSB7XG4gICAgICAgICAgICB0aGlzW2V2ZW50VHlwZV0odGhpcy5fdGFyZ2V0LCBhcmcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDbGlwO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9hbmltYXRpb24vQ2xpcC5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDnvJPliqjku6PnoIHmnaXoh6ogaHR0cHM6Ly9naXRodWIuY29tL3NvbGUvdHdlZW4uanMvYmxvYi9tYXN0ZXIvc3JjL1R3ZWVuLmpzXG4gKiBAc2VlIGh0dHA6Ly9zb2xlLmdpdGh1Yi5pby90d2Vlbi5qcy9leGFtcGxlcy8wM19ncmFwaHMuaHRtbFxuICogQGV4cG9ydHMgenJlbmRlci9hbmltYXRpb24vZWFzaW5nXG4gKi9cbnZhciBlYXNpbmcgPSB7XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICovXG4gICAgbGluZWFyOiBmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gaztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICovXG4gICAgcXVhZHJhdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICogaztcbiAgICB9LFxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAqL1xuICAgIHF1YWRyYXRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIGsgKiAoMiAtIGspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICovXG4gICAgcXVhZHJhdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG4gICAgfSxcblxuICAgIC8vIOS4ieasoeaWueeahOe8k+WKqO+8iHReM++8iVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAqL1xuICAgIGN1YmljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICogayAqIGs7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjdWJpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbiAgICB9LFxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAqL1xuICAgIGN1YmljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG4gICAgfSxcblxuICAgIC8vIOWbm+asoeaWueeahOe8k+WKqO+8iHReNO+8iVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAqL1xuICAgIHF1YXJ0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIGsgKiBrICogayAqIGs7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgKi9cbiAgICBxdWFydGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gMSAtICgtLWsgKiBrICogayAqIGspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICovXG4gICAgcXVhcnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuICAgIH0sXG5cbiAgICAvLyDkupTmrKHmlrnnmoTnvJPliqjvvIh0XjXvvIlcbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgKi9cbiAgICBxdWludGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICogayAqIGsgKiBrICogaztcbiAgICB9LFxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAqL1xuICAgIHF1aW50aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcbiAgICB9LFxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAqL1xuICAgIHF1aW50aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG4gICAgfSxcblxuICAgIC8vIOato+W8puabsue6v+eahOe8k+WKqO+8iHNpbih0Ke+8iVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAqL1xuICAgIHNpbnVzb2lkYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICovXG4gICAgc2ludXNvaWRhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKGsgKiBNYXRoLlBJIC8gMik7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgKi9cbiAgICBzaW51c29pZGFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgfSxcblxuICAgIC8vIOaMh+aVsOabsue6v+eahOe8k+WKqO+8iDJedO+8iVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAqL1xuICAgIGV4cG9uZW50aWFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrID09PSAwID8gMCA6IE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAqL1xuICAgIGV4cG9uZW50aWFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogayk7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgKi9cbiAgICBleHBvbmVudGlhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGsgLSAxKSkgKyAyKTtcbiAgICB9LFxuXG4gICAgLy8g5ZyG5b2i5puy57q/55qE57yT5Yqo77yIc3FydCgxLXReMinvvIlcbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjaXJjdWxhckluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICovXG4gICAgY2lyY3VsYXJPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLWsgKiBrKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjaXJjdWxhckluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoayAtPSAyKSAqIGspICsgMSk7XG4gICAgfSxcblxuICAgIC8vIOWIm+W7uuexu+S8vOS6juW8ueewp+WcqOWBnOatouWJjeadpeWbnuaMr+iNoeeahOWKqOeUu1xuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAqL1xuICAgIGVsYXN0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgdmFyIHM7XG4gICAgICAgIHZhciBhID0gMC4xO1xuICAgICAgICB2YXIgcCA9IDAuNDtcbiAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgIGEgPSAxOyBzID0gcCAvIDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICovXG4gICAgZWxhc3RpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgdmFyIHM7XG4gICAgICAgIHZhciBhID0gMC4xO1xuICAgICAgICB2YXIgcCA9IDAuNDtcbiAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgIGEgPSAxOyBzID0gcCAvIDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYSAqIE1hdGgucG93KDIsIC0xMCAqIGspICpcbiAgICAgICAgICAgICAgICBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgKi9cbiAgICBlbGFzdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBzO1xuICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgdmFyIHAgPSAwLjQ7XG4gICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICAgICAgICBhID0gMTsgcyA9IHAgLyA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSlcbiAgICAgICAgICAgICAgICAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKGsgLT0gMSkpXG4gICAgICAgICAgICAgICAgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICogMC41ICsgMTtcblxuICAgIH0sXG5cbiAgICAvLyDlnKjmn5DkuIDliqjnlLvlvIDlp4vmsr/mjIfnpLrnmoTot6/lvoTov5vooYzliqjnlLvlpITnkIbliY3nqI3nqI3mlLblm57or6XliqjnlLvnmoTnp7vliqhcbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgKi9cbiAgICBiYWNrSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgKi9cbiAgICBiYWNrT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICovXG4gICAgYmFja0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcbiAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG4gICAgfSxcblxuICAgIC8vIOWIm+W7uuW8uei3s+aViOaenFxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAqL1xuICAgIGJvdW5jZUluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gMSAtIGVhc2luZy5ib3VuY2VPdXQoMSAtIGspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICovXG4gICAgYm91bmNlT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoayA8ICgxIC8gMi43NSkpIHtcbiAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiBrICogaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrIDwgKDIgLyAyLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgxLjUgLyAyLjc1KSkgKiBrICsgMC43NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrIDwgKDIuNSAvIDIuNzUpKSB7XG4gICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuMjUgLyAyLjc1KSkgKiBrICsgMC45Mzc1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjYyNSAvIDIuNzUpKSAqIGsgKyAwLjk4NDM3NTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICovXG4gICAgYm91bmNlSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChrIDwgMC41KSB7XG4gICAgICAgICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZUluKGsgKiAyKSAqIDAuNTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZU91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGVhc2luZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvYW5pbWF0aW9uL2Vhc2luZy5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5pbXBvcnQge25vcm1hbGl6ZVJhZGlhbn0gZnJvbSAnLi91dGlsJztcblxudmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG4vKipcbiAqIOWchuW8p+aPj+i+ueWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgY3hcbiAqIEBwYXJhbSAge251bWJlcn0gIGN5XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICByXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydEFuZ2xlXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBlbmRBbmdsZVxuICogQHBhcmFtICB7Ym9vbGVhbn0gIGFudGljbG9ja3dpc2VcbiAqIEBwYXJhbSAge251bWJlcn0gbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpblN0cm9rZShcbiAgICBjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLFxuICAgIGxpbmVXaWR0aCwgeCwgeVxuKSB7XG5cbiAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIF9sID0gbGluZVdpZHRoO1xuXG4gICAgeCAtPSBjeDtcbiAgICB5IC09IGN5O1xuICAgIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gICAgaWYgKChkIC0gX2wgPiByKSB8fCAoZCArIF9sIDwgcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAlIFBJMiA8IDFlLTQpIHtcbiAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgfVxuICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgZW5kQW5nbGUgKz0gUEkyO1xuICAgIH1cblxuICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XG4gICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICBhbmdsZSArPSBQSTI7XG4gICAgfVxuICAgIHJldHVybiAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSlcbiAgICAgICAgfHwgKGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGUpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9jb250YWluL2FyYy5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5pbXBvcnQgKiBhcyBjdXJ2ZSBmcm9tICcuLi9jb3JlL2N1cnZlJztcblxuLyoqXG4gKiDkuInmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAqIEBwYXJhbSAge251bWJlcn0gIHgzXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5M1xuICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgaWYgKFxuICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgJiYgeSA+IHkzICsgX2wpXG4gICAgICAgIHx8ICh5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbCAmJiB5IDwgeTMgLSBfbClcbiAgICAgICAgfHwgKHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sICYmIHggPiB4MyArIF9sKVxuICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wgJiYgeCA8IHgzIC0gX2wpXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGQgPSBjdXJ2ZS5jdWJpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLFxuICAgICAgICB4LCB5LCBudWxsXG4gICAgKTtcbiAgICByZXR1cm4gZCA8PSBfbCAvIDI7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL2NvbnRhaW4vY3ViaWMuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiDnur/mrrXljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIF9sID0gbGluZVdpZHRoO1xuICAgIHZhciBfYSA9IDA7XG4gICAgdmFyIF9iID0geDA7XG4gICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgaWYgKFxuICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wpXG4gICAgICAgIHx8ICh5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbClcbiAgICAgICAgfHwgKHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sKVxuICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wpXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoeDAgIT09IHgxKSB7XG4gICAgICAgIF9hID0gKHkwIC0geTEpIC8gKHgwIC0geDEpO1xuICAgICAgICBfYiA9ICh4MCAqIHkxIC0geDEgKiB5MCkgLyAoeDAgLSB4MSkgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHggLSB4MCkgPD0gX2wgLyAyO1xuICAgIH1cbiAgICB2YXIgdG1wID0gX2EgKiB4IC0geSArIF9iO1xuICAgIHZhciBfcyA9IHRtcCAqIHRtcCAvIChfYSAqIF9hICsgMSk7XG4gICAgcmV0dXJuIF9zIDw9IF9sIC8gMiAqIF9sIC8gMjtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvY29udGFpbi9saW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUGF0aFByb3h5IGZyb20gJy4uL2NvcmUvUGF0aFByb3h5JztcbmltcG9ydCAqIGFzIGxpbmUgZnJvbSAnLi9saW5lJztcbmltcG9ydCAqIGFzIGN1YmljIGZyb20gJy4vY3ViaWMnO1xuaW1wb3J0ICogYXMgcXVhZHJhdGljIGZyb20gJy4vcXVhZHJhdGljJztcbmltcG9ydCAqIGFzIGFyYyBmcm9tICcuL2FyYyc7XG5pbXBvcnQge25vcm1hbGl6ZVJhZGlhbn0gZnJvbSAnLi91dGlsJztcbmltcG9ydCAqIGFzIGN1cnZlIGZyb20gJy4uL2NvcmUvY3VydmUnO1xuaW1wb3J0IHdpbmRpbmdMaW5lIGZyb20gJy4vd2luZGluZ0xpbmUnO1xuXG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcblxudmFyIEVQU0lMT04gPSAxZS00O1xuXG5mdW5jdGlvbiBpc0Fyb3VuZEVxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgRVBTSUxPTjtcbn1cblxuLy8g5Li05pe25pWw57uEXG52YXIgcm9vdHMgPSBbLTEsIC0xLCAtMV07XG52YXIgZXh0cmVtYSA9IFstMSwgLTFdO1xuXG5mdW5jdGlvbiBzd2FwRXh0cmVtYSgpIHtcbiAgICB2YXIgdG1wID0gZXh0cmVtYVswXTtcbiAgICBleHRyZW1hWzBdID0gZXh0cmVtYVsxXTtcbiAgICBleHRyZW1hWzFdID0gdG1wO1xufVxuXG5mdW5jdGlvbiB3aW5kaW5nQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSB7XG4gICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgaWYgKFxuICAgICAgICAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgJiYgeSA+IHkzKVxuICAgICAgICB8fCAoeSA8IHkwICYmIHkgPCB5MSAmJiB5IDwgeTIgJiYgeSA8IHkzKVxuICAgICkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIG5Sb290cyA9IGN1cnZlLmN1YmljUm9vdEF0KHkwLCB5MSwgeTIsIHkzLCB5LCByb290cyk7XG4gICAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgdmFyIG5FeHRyZW1hID0gLTE7XG4gICAgICAgIHZhciB5MF8sIHkxXztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm9vdHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHQgPSByb290c1tpXTtcblxuICAgICAgICAgICAgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG4gICAgICAgICAgICB2YXIgdW5pdCA9ICh0ID09PSAwIHx8IHQgPT09IDEpID8gMC41IDogMTtcblxuICAgICAgICAgICAgdmFyIHhfID0gY3VydmUuY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICBpZiAoeF8gPCB4KSB7IC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5FeHRyZW1hIDwgMCkge1xuICAgICAgICAgICAgICAgIG5FeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hKTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmVtYVsxXSA8IGV4dHJlbWFbMF0gJiYgbkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3YXBFeHRyZW1hKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkwXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMF0pO1xuICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgeTFfID0gY3VydmUuY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5FeHRyZW1hID09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyDliIbmiJDkuInmrrXljZXosIPlh73mlbBcbiAgICAgICAgICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodCA8IGV4dHJlbWFbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdyArPSB5MV8gPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHkzIDwgeTFfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIOWIhuaIkOS4pOauteWNleiwg+WHveaVsFxuICAgICAgICAgICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdyArPSB5MyA8IHkwXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB3aW5kaW5nUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICAvLyBRdWljayByZWplY3RcbiAgICBpZiAoXG4gICAgICAgICh5ID4geTAgJiYgeSA+IHkxICYmIHkgPiB5MilcbiAgICAgICAgfHwgKHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyKVxuICAgICkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIG5Sb290cyA9IGN1cnZlLnF1YWRyYXRpY1Jvb3RBdCh5MCwgeTEsIHkyLCB5LCByb290cyk7XG4gICAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB0ID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5Mik7XG4gICAgICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgICAgICB2YXIgeV8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHJvb3RzW2ldID09PSAwIHx8IHJvb3RzW2ldID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RzW2ldIDwgdCkge1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHlfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHkyIDwgeV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICAgICAgdmFyIHVuaXQgPSAocm9vdHNbMF0gPT09IDAgfHwgcm9vdHNbMF0gPT09IDEpID8gMC41IDogMTtcblxuICAgICAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbMF0pO1xuICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHkyIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFRPRE9cbi8vIEFyYyDml4vovaxcbmZ1bmN0aW9uIHdpbmRpbmdBcmMoXG4gICAgY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgeCwgeVxuKSB7XG4gICAgeSAtPSBjeTtcbiAgICBpZiAoeSA+IHIgfHwgeSA8IC1yKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgdG1wID0gTWF0aC5zcXJ0KHIgKiByIC0geSAqIHkpO1xuICAgIHJvb3RzWzBdID0gLXRtcDtcbiAgICByb290c1sxXSA9IHRtcDtcblxuICAgIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcbiAgICBpZiAoZGlmZiA8IDFlLTQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChkaWZmICUgUEkyIDwgMWUtNCkge1xuICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICBzdGFydEFuZ2xlID0gMDtcbiAgICAgICAgZW5kQW5nbGUgPSBQSTI7XG4gICAgICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuICAgICAgICBpZiAoeCA+PSByb290c1swXSArIGN4ICYmIHggPD0gcm9vdHNbMV0gKyBjeCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihzdGFydEFuZ2xlKTtcbiAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgIH1cbiAgICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlKSB7XG4gICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICB9XG5cbiAgICB2YXIgdyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgdmFyIHhfID0gcm9vdHNbaV07XG4gICAgICAgIGlmICh4XyArIGN4ID4geCkge1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4Xyk7XG4gICAgICAgICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICBhbmdsZSA9IFBJMiArIGFuZ2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgIHx8IChhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSAvIDIgJiYgYW5nbGUgPCBNYXRoLlBJICogMS41KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpciA9IC1kaXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHcgKz0gZGlyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3O1xufVxuXG5mdW5jdGlvbiBjb250YWluUGF0aChkYXRhLCBsaW5lV2lkdGgsIGlzU3Ryb2tlLCB4LCB5KSB7XG4gICAgdmFyIHcgPSAwO1xuICAgIHZhciB4aSA9IDA7XG4gICAgdmFyIHlpID0gMDtcbiAgICB2YXIgeDAgPSAwO1xuICAgIHZhciB5MCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuICAgICAgICAvLyBCZWdpbiBhIG5ldyBzdWJwYXRoXG4gICAgICAgIGlmIChjbWQgPT09IENNRC5NICYmIGkgPiAxKSB7XG4gICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzdWJwYXRoXG4gICAgICAgICAgICBpZiAoIWlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDlpoLmnpzooqvku7vkvZXkuIDkuKogc3VicGF0aCDljIXlkKtcbiAgICAgICAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuXG4gICAgICAgICAgICB4MCA9IHhpO1xuICAgICAgICAgICAgeTAgPSB5aTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgICAgICAgLy8g5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnkvb/nlKhcbiAgICAgICAgICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5jb250YWluU3Ryb2tlKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFIOWcqOesrOS4gOS4quWRveS7pOS4uiBMLCBDLCBRIOeahOaXtuWAmeS8muiuoeeul+WHuiBOYU5cbiAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCB4LCB5KSB8fCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdWJpYy5jb250YWluU3Ryb2tlKHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0N1YmljKFxuICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgKSB8fCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWFkcmF0aWMuY29udGFpblN0cm9rZSh4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ1F1YWRyYXRpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgKSB8fCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOaXi+i9rFxuICAgICAgICAgICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHZhciB4MSA9IE1hdGguY29zKHRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgdmFyIHkxID0gTWF0aC5zaW4odGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAvLyDkuI3mmK/nm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgICAgIGlmIChpID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgICAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHkxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB6ciDkvb/nlKhzY2FsZeadpeaooeaLn+akreWchiwg6L+Z6YeM5Lmf5a+5eOWBmuS4gOWumueahOe8qeaUvlxuICAgICAgICAgICAgICAgIHZhciBfeCA9ICh4IC0gY3gpICogcnkgLyByeCArIGN4O1xuICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJjLmNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsIF94LCB5XG4gICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdBcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICBjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBfeCwgeVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4aSA9IE1hdGguY29zKHRoZXRhICsgZFRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgeWkgPSBNYXRoLnNpbih0aGV0YSArIGRUaGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgdmFyIHgxID0geDAgKyB3aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgeTEgPSB5MCArIGhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MCwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgbGluZS5jb250YWluU3Ryb2tlKHgxLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBsaW5lLmNvbnRhaW5TdHJva2UoeDEsIHkxLCB4MCwgeTEsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGxpbmUuY29udGFpblN0cm9rZSh4MCwgeTEsIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBDbG9ja3dpc2UgP1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHgxLCB5MCwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MCwgeTEsIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuY29udGFpblN0cm9rZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSwgeDAsIHkwLCBsaW5lV2lkdGgsIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsb3NlIGEgc3VicGF0aFxuICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIHN1YnBhdGhzIG1heSBvdmVybGFwXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1N0cm9rZSAmJiAhaXNBcm91bmRFcXVhbCh5aSwgeTApKSB7XG4gICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpIHx8IDA7XG4gICAgfVxuICAgIHJldHVybiB3ICE9PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbihwYXRoRGF0YSwgeCwgeSkge1xuICAgIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgMCwgZmFsc2UsIHgsIHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udGFpblN0cm9rZShwYXRoRGF0YSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHRydWUsIHgsIHkpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9jb250YWluL3BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7cXVhZHJhdGljUHJvamVjdFBvaW50fSBmcm9tICcuLi9jb3JlL2N1cnZlJztcblxuLyoqXG4gKiDkuozmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgICAvLyBRdWljayByZWplY3RcbiAgICBpZiAoXG4gICAgICAgICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCAmJiB5ID4geTIgKyBfbClcbiAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sKVxuICAgICAgICB8fCAoeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wpXG4gICAgICAgIHx8ICh4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCAmJiB4IDwgeDIgLSBfbClcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZCA9IHF1YWRyYXRpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgeCwgeSwgbnVsbFxuICAgICk7XG4gICAgcmV0dXJuIGQgPD0gX2wgLyAyO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL2NvbnRhaW4vcXVhZHJhdGljLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdpbmRpbmdMaW5lKHgwLCB5MCwgeDEsIHkxLCB4LCB5KSB7XG4gICAgaWYgKCh5ID4geTAgJiYgeSA+IHkxKSB8fCAoeSA8IHkwICYmIHkgPCB5MSkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIElnbm9yZSBob3Jpem9udGFsIGxpbmVcbiAgICBpZiAoeTEgPT09IHkwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgZGlyID0geTEgPCB5MCA/IDEgOiAtMTtcbiAgICB2YXIgdCA9ICh5IC0geTApIC8gKHkxIC0geTApO1xuXG4gICAgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG4gICAgaWYgKHQgPT09IDEgfHwgdCA9PT0gMCkge1xuICAgICAgICBkaXIgPSB5MSA8IHkwID8gMC41IDogLTAuNTtcbiAgICB9XG5cbiAgICB2YXIgeF8gPSB0ICogKHgxIC0geDApICsgeDA7XG5cbiAgICByZXR1cm4geF8gPiB4ID8gZGlyIDogMDtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvY29udGFpbi93aW5kaW5nTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBPbmx5IGltcGxlbWVudHMgbmVlZGVkIGdlc3R1cmVzIGZvciBtb2JpbGUuXG4gKi9cblxuaW1wb3J0ICogYXMgZXZlbnRVdGlsIGZyb20gJy4vZXZlbnQnO1xuXG52YXIgR2VzdHVyZU1nciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMuX3RyYWNrID0gW107XG59O1xuXG5HZXN0dXJlTWdyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBHZXN0dXJlTWdyLFxuXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgICAgICB0aGlzLl9kb1RyYWNrKGV2ZW50LCB0YXJnZXQsIHJvb3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjb2duaXplKGV2ZW50KTtcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdHJhY2subGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9kb1RyYWNrOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XG5cbiAgICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhY2tJdGVtID0ge1xuICAgICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICAgIHRvdWNoZXM6IFtdLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG91Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcbiAgICAgICAgICAgIHZhciBwb3MgPSBldmVudFV0aWwuY2xpZW50VG9Mb2NhbChyb290LCB0b3VjaCwge30pO1xuICAgICAgICAgICAgdHJhY2tJdGVtLnBvaW50cy5wdXNoKFtwb3MuenJYLCBwb3MuenJZXSk7XG4gICAgICAgICAgICB0cmFja0l0ZW0udG91Y2hlcy5wdXNoKHRvdWNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RyYWNrLnB1c2godHJhY2tJdGVtKTtcbiAgICB9LFxuXG4gICAgX3JlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiByZWNvZ25pemVycykge1xuICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2VzdHVyZUluZm8gPSByZWNvZ25pemVyc1tldmVudE5hbWVdKHRoaXMuX3RyYWNrLCBldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXN0dXJlSW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiBkaXN0KHBvaW50UGFpcikge1xuICAgIHZhciBkeCA9IHBvaW50UGFpclsxXVswXSAtIHBvaW50UGFpclswXVswXTtcbiAgICB2YXIgZHkgPSBwb2ludFBhaXJbMV1bMV0gLSBwb2ludFBhaXJbMF1bMV07XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbn1cblxuZnVuY3Rpb24gY2VudGVyKHBvaW50UGFpcikge1xuICAgIHJldHVybiBbXG4gICAgICAgIChwb2ludFBhaXJbMF1bMF0gKyBwb2ludFBhaXJbMV1bMF0pIC8gMixcbiAgICAgICAgKHBvaW50UGFpclswXVsxXSArIHBvaW50UGFpclsxXVsxXSkgLyAyXG4gICAgXTtcbn1cblxudmFyIHJlY29nbml6ZXJzID0ge1xuXG4gICAgcGluY2g6IGZ1bmN0aW9uICh0cmFjaywgZXZlbnQpIHtcbiAgICAgICAgdmFyIHRyYWNrTGVuID0gdHJhY2subGVuZ3RoO1xuXG4gICAgICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwaW5jaEVuZCA9ICh0cmFja1t0cmFja0xlbiAtIDFdIHx8IHt9KS5wb2ludHM7XG4gICAgICAgIHZhciBwaW5jaFByZSA9ICh0cmFja1t0cmFja0xlbiAtIDJdIHx8IHt9KS5wb2ludHMgfHwgcGluY2hFbmQ7XG5cbiAgICAgICAgaWYgKHBpbmNoUHJlXG4gICAgICAgICAgICAmJiBwaW5jaFByZS5sZW5ndGggPiAxXG4gICAgICAgICAgICAmJiBwaW5jaEVuZFxuICAgICAgICAgICAgJiYgcGluY2hFbmQubGVuZ3RoID4gMVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBwaW5jaFNjYWxlID0gZGlzdChwaW5jaEVuZCkgLyBkaXN0KHBpbmNoUHJlKTtcbiAgICAgICAgICAgICFpc0Zpbml0ZShwaW5jaFNjYWxlKSAmJiAocGluY2hTY2FsZSA9IDEpO1xuXG4gICAgICAgICAgICBldmVudC5waW5jaFNjYWxlID0gcGluY2hTY2FsZTtcblxuICAgICAgICAgICAgdmFyIHBpbmNoQ2VudGVyID0gY2VudGVyKHBpbmNoRW5kKTtcbiAgICAgICAgICAgIGV2ZW50LnBpbmNoWCA9IHBpbmNoQ2VudGVyWzBdO1xuICAgICAgICAgICAgZXZlbnQucGluY2hZID0gcGluY2hDZW50ZXJbMV07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BpbmNoJyxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRyYWNrWzBdLnRhcmdldCxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPbmx5IHBpbmNoIGN1cnJlbnRseS5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdlc3R1cmVNZ3I7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL2NvcmUvR2VzdHVyZU1nci5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAYXV0aG9yIFlpIFNoZW4oaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuL3ZlY3Rvcic7XG5pbXBvcnQgKiBhcyBjdXJ2ZSBmcm9tICcuL2N1cnZlJztcblxudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aFNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcblxudmFyIHN0YXJ0ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBlbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGV4dHJlbWl0eSA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICog5LuO6aG254K55pWw57uE5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb2ludHMg6aG254K55pWw57uEXG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUG9pbnRzKHBvaW50cywgbWluLCBtYXgpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwID0gcG9pbnRzWzBdO1xuICAgIHZhciBsZWZ0ID0gcFswXTtcbiAgICB2YXIgcmlnaHQgPSBwWzBdO1xuICAgIHZhciB0b3AgPSBwWzFdO1xuICAgIHZhciBib3R0b20gPSBwWzFdO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICBsZWZ0ID0gbWF0aE1pbihsZWZ0LCBwWzBdKTtcbiAgICAgICAgcmlnaHQgPSBtYXRoTWF4KHJpZ2h0LCBwWzBdKTtcbiAgICAgICAgdG9wID0gbWF0aE1pbih0b3AsIHBbMV0pO1xuICAgICAgICBib3R0b20gPSBtYXRoTWF4KGJvdHRvbSwgcFsxXSk7XG4gICAgfVxuXG4gICAgbWluWzBdID0gbGVmdDtcbiAgICBtaW5bMV0gPSB0b3A7XG4gICAgbWF4WzBdID0gcmlnaHQ7XG4gICAgbWF4WzFdID0gYm90dG9tO1xufVxuXG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21MaW5lKHgwLCB5MCwgeDEsIHkxLCBtaW4sIG1heCkge1xuICAgIG1pblswXSA9IG1hdGhNaW4oeDAsIHgxKTtcbiAgICBtaW5bMV0gPSBtYXRoTWluKHkwLCB5MSk7XG4gICAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDEpO1xuICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkxKTtcbn1cblxudmFyIHhEaW0gPSBbXTtcbnZhciB5RGltID0gW107XG4vKipcbiAqIOS7juS4iemYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyLCBwMynkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge251bWJlcn0geDNcbiAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21DdWJpYyhcbiAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbiwgbWF4XG4pIHtcbiAgICB2YXIgY3ViaWNFeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hO1xuICAgIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbiA9IGN1YmljRXh0cmVtYSh4MCwgeDEsIHgyLCB4MywgeERpbSk7XG4gICAgbWluWzBdID0gSW5maW5pdHk7XG4gICAgbWluWzFdID0gSW5maW5pdHk7XG4gICAgbWF4WzBdID0gLUluZmluaXR5O1xuICAgIG1heFsxXSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB4RGltW2ldKTtcbiAgICAgICAgbWluWzBdID0gbWF0aE1pbih4LCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgsIG1heFswXSk7XG4gICAgfVxuICAgIG4gPSBjdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIHlEaW0pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB5RGltW2ldKTtcbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5LCBtaW5bMV0pO1xuICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHksIG1heFsxXSk7XG4gICAgfVxuXG4gICAgbWluWzBdID0gbWF0aE1pbih4MCwgbWluWzBdKTtcbiAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCBtYXhbMF0pO1xuICAgIG1pblswXSA9IG1hdGhNaW4oeDMsIG1pblswXSk7XG4gICAgbWF4WzBdID0gbWF0aE1heCh4MywgbWF4WzBdKTtcblxuICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIG1pblsxXSk7XG4gICAgbWF4WzFdID0gbWF0aE1heCh5MCwgbWF4WzFdKTtcbiAgICBtaW5bMV0gPSBtYXRoTWluKHkzLCBtaW5bMV0pO1xuICAgIG1heFsxXSA9IG1hdGhNYXgoeTMsIG1heFsxXSk7XG59XG5cbi8qKlxuICog5LuO5LqM6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIp5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWFkcmF0aWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbWluLCBtYXgpIHtcbiAgICB2YXIgcXVhZHJhdGljRXh0cmVtdW0gPSBjdXJ2ZS5xdWFkcmF0aWNFeHRyZW11bTtcbiAgICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZS5xdWFkcmF0aWNBdDtcbiAgICAvLyBGaW5kIGV4dHJlbWl0aWVzLCB3aGVyZSBkZXJpdmF0aXZlIGluIHggZGltIG9yIHkgZGltIGlzIHplcm9cbiAgICB2YXIgdHggPVxuICAgICAgICBtYXRoTWF4KFxuICAgICAgICAgICAgbWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh4MCwgeDEsIHgyKSwgMSksIDBcbiAgICAgICAgKTtcbiAgICB2YXIgdHkgPVxuICAgICAgICBtYXRoTWF4KFxuICAgICAgICAgICAgbWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh5MCwgeTEsIHkyKSwgMSksIDBcbiAgICAgICAgKTtcblxuICAgIHZhciB4ID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdHgpO1xuICAgIHZhciB5ID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdHkpO1xuXG4gICAgbWluWzBdID0gbWF0aE1pbih4MCwgeDIsIHgpO1xuICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkyLCB5KTtcbiAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MiwgeCk7XG4gICAgbWF4WzFdID0gbWF0aE1heCh5MCwgeTIsIHkpO1xufVxuXG4vKipcbiAqIOS7juWchuW8p+S4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IHJ4XG4gKiBAcGFyYW0ge251bWJlcn0gcnlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kQW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbnRpY2xvY2t3aXNlXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUFyYyhcbiAgICB4LCB5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4sIG1heFxuKSB7XG4gICAgdmFyIHZlYzJNaW4gPSB2ZWMyLm1pbjtcbiAgICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuXG4gICAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuXG5cbiAgICBpZiAoZGlmZiAlIFBJMiA8IDFlLTQgJiYgZGlmZiA+IDFlLTQpIHtcbiAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgbWluWzBdID0geCAtIHJ4O1xuICAgICAgICBtaW5bMV0gPSB5IC0gcnk7XG4gICAgICAgIG1heFswXSA9IHggKyByeDtcbiAgICAgICAgbWF4WzFdID0geSArIHJ5O1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhcnRbMF0gPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyB4O1xuICAgIHN0YXJ0WzFdID0gbWF0aFNpbihzdGFydEFuZ2xlKSAqIHJ5ICsgeTtcblxuICAgIGVuZFswXSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyB4O1xuICAgIGVuZFsxXSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyB5O1xuXG4gICAgdmVjMk1pbihtaW4sIHN0YXJ0LCBlbmQpO1xuICAgIHZlYzJNYXgobWF4LCBzdGFydCwgZW5kKTtcblxuICAgIC8vIFRocmVzaCB0byBbMCwgTWF0aC5QSSAqIDJdXG4gICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgJSAoUEkyKTtcbiAgICBpZiAoc3RhcnRBbmdsZSA8IDApIHtcbiAgICAgICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBQSTI7XG4gICAgfVxuICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgJSAoUEkyKTtcbiAgICBpZiAoZW5kQW5nbGUgPCAwKSB7XG4gICAgICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgKyBQSTI7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSAmJiAhYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICBlbmRBbmdsZSArPSBQSTI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXJ0QW5nbGUgPCBlbmRBbmdsZSAmJiBhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgIHN0YXJ0QW5nbGUgKz0gUEkyO1xuICAgIH1cbiAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICB2YXIgdG1wID0gZW5kQW5nbGU7XG4gICAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICAgICAgc3RhcnRBbmdsZSA9IHRtcDtcbiAgICB9XG5cbiAgICAvLyB2YXIgbnVtYmVyID0gMDtcbiAgICAvLyB2YXIgc3RlcCA9IChhbnRpY2xvY2t3aXNlID8gLU1hdGguUEkgOiBNYXRoLlBJKSAvIDI7XG4gICAgZm9yICh2YXIgYW5nbGUgPSAwOyBhbmdsZSA8IGVuZEFuZ2xlOyBhbmdsZSArPSBNYXRoLlBJIC8gMikge1xuICAgICAgICBpZiAoYW5nbGUgPiBzdGFydEFuZ2xlKSB7XG4gICAgICAgICAgICBleHRyZW1pdHlbMF0gPSBtYXRoQ29zKGFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgICAgICAgIGV4dHJlbWl0eVsxXSA9IG1hdGhTaW4oYW5nbGUpICogcnkgKyB5O1xuXG4gICAgICAgICAgICB2ZWMyTWluKG1pbiwgZXh0cmVtaXR5LCBtaW4pO1xuICAgICAgICAgICAgdmVjMk1heChtYXgsIGV4dHJlbWl0eSwgbWF4KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9jb3JlL2Jib3guanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuaW1wb3J0IHtcbiAgICBhZGRFdmVudExpc3RlbmVyLFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIsXG4gICAgbm9ybWFsaXplRXZlbnRcbn0gZnJvbSAnLi4vY29yZS9ldmVudCc7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnLi4vY29yZS91dGlsJztcbmltcG9ydCBFdmVudGZ1bCBmcm9tICcuLi9taXhpbi9FdmVudGZ1bCc7XG5pbXBvcnQgZW52IGZyb20gJy4uL2NvcmUvZW52JztcbmltcG9ydCBHZXN0dXJlTWdyIGZyb20gJy4uL2NvcmUvR2VzdHVyZU1ncic7XG5cbnZhciBUT1VDSF9DTElDS19ERUxBWSA9IDMwMDtcblxudmFyIG1vdXNlSGFuZGxlck5hbWVzID0gW1xuICAgICdjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JyxcbiAgICAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J1xuXTtcblxudmFyIHRvdWNoSGFuZGxlck5hbWVzID0gW1xuICAgICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSdcbl07XG5cbnZhciBwb2ludGVyRXZlbnROYW1lcyA9IHtcbiAgICBwb2ludGVyZG93bjogMSwgcG9pbnRlcnVwOiAxLCBwb2ludGVybW92ZTogMSwgcG9pbnRlcm91dDogMVxufTtcblxudmFyIHBvaW50ZXJIYW5kbGVyTmFtZXMgPSB6clV0aWwubWFwKG1vdXNlSGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBubSA9IG5hbWUucmVwbGFjZSgnbW91c2UnLCAncG9pbnRlcicpO1xuICAgIHJldHVybiBwb2ludGVyRXZlbnROYW1lc1tubV0gPyBubSA6IG5hbWU7XG59KTtcblxuZnVuY3Rpb24gZXZlbnROYW1lRml4KG5hbWUpIHtcbiAgICByZXR1cm4gKG5hbWUgPT09ICdtb3VzZXdoZWVsJyAmJiBlbnYuYnJvd3Nlci5maXJlZm94KSA/ICdET01Nb3VzZVNjcm9sbCcgOiBuYW1lO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzR2VzdHVyZShwcm94eSwgZXZlbnQsIHN0YWdlKSB7XG4gICAgdmFyIGdlc3R1cmVNZ3IgPSBwcm94eS5fZ2VzdHVyZU1ncjtcblxuICAgIHN0YWdlID09PSAnc3RhcnQnICYmIGdlc3R1cmVNZ3IuY2xlYXIoKTtcblxuICAgIHZhciBnZXN0dXJlSW5mbyA9IGdlc3R1cmVNZ3IucmVjb2duaXplKFxuICAgICAgICBldmVudCxcbiAgICAgICAgcHJveHkuaGFuZGxlci5maW5kSG92ZXIoZXZlbnQuenJYLCBldmVudC56clksIG51bGwpLnRhcmdldCxcbiAgICAgICAgcHJveHkuZG9tXG4gICAgKTtcblxuICAgIHN0YWdlID09PSAnZW5kJyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7XG5cbiAgICAvLyBEbyBub3QgZG8gYW55IHByZXZlbnREZWZhdWx0IGhlcmUuIFVwcGVyIGFwcGxpY2F0aW9uIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICB2YXIgdHlwZSA9IGdlc3R1cmVJbmZvLnR5cGU7XG4gICAgICAgIGV2ZW50Lmdlc3R1cmVFdmVudCA9IHR5cGU7XG5cbiAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudCh7dGFyZ2V0OiBnZXN0dXJlSW5mby50YXJnZXR9LCB0eXBlLCBnZXN0dXJlSW5mby5ldmVudCk7XG4gICAgfVxufVxuXG4vLyBmdW5jdGlvbiBvbk1TR2VzdHVyZUNoYW5nZShwcm94eSwgZXZlbnQpIHtcbi8vICAgICBpZiAoZXZlbnQudHJhbnNsYXRpb25YIHx8IGV2ZW50LnRyYW5zbGF0aW9uWSkge1xuLy8gICAgICAgICAvLyBtb3VzZW1vdmUgaXMgY2FycmllZCBieSBNU0dlc3R1cmUgdG8gcmVkdWNlIHRoZSBzZW5zaXRpdml0eS5cbi8vICAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudChldmVudC50YXJnZXQsICdtb3VzZW1vdmUnLCBldmVudCk7XG4vLyAgICAgfVxuLy8gICAgIGlmIChldmVudC5zY2FsZSAhPT0gMSkge1xuLy8gICAgICAgICBldmVudC5waW5jaFggPSBldmVudC5vZmZzZXRYO1xuLy8gICAgICAgICBldmVudC5waW5jaFkgPSBldmVudC5vZmZzZXRZO1xuLy8gICAgICAgICBldmVudC5waW5jaFNjYWxlID0gZXZlbnQuc2NhbGU7XG4vLyAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoZXZlbnQudGFyZ2V0LCAncGluY2gnLCBldmVudCk7XG4vLyAgICAgfVxuLy8gfVxuXG4vKipcbiAqIFByZXZlbnQgbW91c2UgZXZlbnQgZnJvbSBiZWluZyBkaXNwYXRjaGVkIGFmdGVyIFRvdWNoIEV2ZW50cyBhY3Rpb25cbiAqIEBzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9kZWx0YWtvc2gvaGFuZGpzL2Jsb2IvbWFzdGVyL3NyYy9oYW5kLmJhc2UuanM+XG4gKiAxLiBNb2JpbGUgYnJvd3NlcnMgZGlzcGF0Y2ggbW91c2UgZXZlbnRzIDMwMG1zIGFmdGVyIHRvdWNoZW5kLlxuICogMi4gQ2hyb21lIGZvciBBbmRyb2lkIGRpc3BhdGNoIG1vdXNlZG93biBmb3IgbG9uZy10b3VjaCBhYm91dCA2NTBtc1xuICogUmVzdWx0OiBCbG9ja2luZyBNb3VzZSBFdmVudHMgZm9yIDcwMG1zLlxuICovXG5mdW5jdGlvbiBzZXRUb3VjaFRpbWVyKGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UuX3RvdWNoaW5nID0gdHJ1ZTtcbiAgICBjbGVhclRpbWVvdXQoaW5zdGFuY2UuX3RvdWNoVGltZXIpO1xuICAgIGluc3RhbmNlLl90b3VjaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlLl90b3VjaGluZyA9IGZhbHNlO1xuICAgIH0sIDcwMCk7XG59XG5cblxudmFyIGRvbUhhbmRsZXJzID0ge1xuICAgIC8qKlxuICAgICAqIE1vdXNlIG1vdmUgaGFuZGxlclxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcignbW91c2Vtb3ZlJywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3VzZSBvdXQgaGFuZGxlclxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgaWYgKGVsZW1lbnQgIT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT0gOSkge1xuICAgICAgICAgICAgICAgIC8vIOW/veeVpeWMheWQq+WcqHJvb3TkuK3nmoRkb23lvJXotbfnmoRtb3VzZU91dFxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcignbW91c2VvdXQnLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvdWNo5byA5aeL5ZON5bqU5Ye95pWwXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICB0b3VjaHN0YXJ0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBtb3VzZSBiZWhhdmlvdXIgc2hvdWxkIG5vdCBiZSBkaXNhYmxlZCBoZXJlLlxuICAgICAgICAvLyBGb3IgZXhhbXBsZSwgcGFnZSBtYXkgbmVlZHMgdG8gYmUgc2xpZGVkLlxuICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG5cbiAgICAgICAgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgICAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cbiAgICAgICAgZXZlbnQuenJCeVRvdWNoID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnc3RhcnQnKTtcblxuICAgICAgICAvLyBJbiB0b3VjaCBkZXZpY2UsIHRyaWdnZXIgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIHNob3VsZFxuICAgICAgICAvLyBiZSB0cmlnZ2VyZWQsIGFuZCBtdXN0IGJlZm9yZSBgbW91c2Vkb3duYCB0cmlnZ2VyZWQuXG4gICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICBkb21IYW5kbGVycy5tb3VzZWRvd24uY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICAgICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG91Y2jnp7vliqjlk43lupTlh73mlbBcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqL1xuICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgIC8vIE1hcmsgdG91Y2gsIHdoaWNoIGlzIHVzZWZ1bCBpbiBkaXN0aW5ndWlzaCB0b3VjaCBhbmRcbiAgICAgICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG4gICAgICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG5cbiAgICAgICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdjaGFuZ2UnKTtcblxuICAgICAgICAvLyBNb3VzZSBtb3ZlIHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQsIGJlY2F1c2UgbW91c2UgbW92ZSBhbmQgcGluY2ggbWF5XG4gICAgICAgIC8vIGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvdWNo57uT5p2f5ZON5bqU5Ye95pWwXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICB0b3VjaGVuZDogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgIC8vIE1hcmsgdG91Y2gsIHdoaWNoIGlzIHVzZWZ1bCBpbiBkaXN0aW5ndWlzaCB0b3VjaCBhbmRcbiAgICAgICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG4gICAgICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG5cbiAgICAgICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdlbmQnKTtcblxuICAgICAgICBkb21IYW5kbGVycy5tb3VzZXVwLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGBtb3VzZW91dGAgaGVyZSwgaW4gc3BpdGUgb2YgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIGlzXG4gICAgICAgIC8vIHRyaWdnZXJlZCBpbiBgdG91Y2hzdGFydGAuIFRoaXMgc2VlbXMgdG8gYmUgaWxsb2dpY2FsLCBidXQgYnkgdGhpcyBtZWNoYW5pc20sXG4gICAgICAgIC8vIHdlIGNhbiBjb252ZW5pZW50bHkgaW1wbGVtZW50IFwiaG92ZXIgc3R5bGVcIiBpbiBib3RoIFBDIGFuZCB0b3VjaCBkZXZpY2UganVzdFxuICAgICAgICAvLyBieSBsaXN0ZW5pbmcgdG8gYG1vdXNlb3ZlcmAgdG8gYWRkIFwiaG92ZXIgc3R5bGVcIiBhbmQgbGlzdGVuaW5nIHRvIGBtb3VzZW91dGBcbiAgICAgICAgLy8gdG8gcmVtb3ZlIFwiaG92ZXIgc3R5bGVcIiBvbiBhbiBlbGVtZW50LCB3aXRob3V0IGFueSBhZGRpdGlvbmFsIGNvZGUgZm9yXG4gICAgICAgIC8vIGNvbXBhdGliaWxpdHkuIChgbW91c2VvdXRgIHdpbGwgbm90IGJlIHRyaWdnZXJlZCBpbiBgdG91Y2hlbmRgLCBzbyBcImhvdmVyXG4gICAgICAgIC8vIHN0eWxlXCIgd2lsbCByZW1haW4gZm9yIHVzZXIgdmlldylcblxuICAgICAgICAvLyBjbGljayBldmVudCBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgICAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LiBTeXN0ZW0gY2xpY2sgY2FuIG5vdCBiZSBwcmV2ZW50ZWQuXG4gICAgICAgIGlmICgrbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA8IFRPVUNIX0NMSUNLX0RFTEFZKSB7XG4gICAgICAgICAgICBkb21IYW5kbGVycy5jbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJkb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgIC8vIGlmICh1c2VNU0d1ZXN0dXJlKHRoaXMsIGV2ZW50KSkge1xuICAgICAgICAvLyAgICAgdGhpcy5fbXNHZXN0dXJlLmFkZFBvaW50ZXIoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgLy8gfVxuICAgIH0sXG5cbiAgICBwb2ludGVybW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIHBvaW50ZXJtb3ZlIGlzIHNvIHNlbnNpdGl2ZSB0aGF0IGl0IGFsd2F5cyB0cmlnZ2VyZWQgd2hlblxuICAgICAgICAvLyB0YXAoY2xpY2spIG9uIHRvdWNoIHNjcmVlbiwgd2hpY2ggYWZmZWN0IHNvbWUganVkZ2VtZW50IGluXG4gICAgICAgIC8vIHVwcGVyIGFwcGxpY2F0aW9uLiBTbywgd2UgZG9udCBzdXBwb3J0IG1vdXNlbW92ZSBvbiBNUyB0b3VjaFxuICAgICAgICAvLyBkZXZpY2UgeWV0LlxuICAgICAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwb2ludGVydXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBkb21IYW5kbGVycy5tb3VzZXVwLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICBwb2ludGVyb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gcG9pbnRlcm91dCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRhcCBvbiB0b3VjaCBzY3JlZW5cbiAgICAgICAgLy8gKElFMTErL0VkZ2Ugb24gTVMgU3VyZmFjZSkgYWZ0ZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcmVkLFxuICAgICAgICAvLyB3aGljaCBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgbW91c291dCBiZWhhdmlvciB3ZSBkZWZpbmVkXG4gICAgICAgIC8vIGluIHRvdWNoZW5kLiBTbyB3ZSB1bmlmeSB0aGVtLlxuICAgICAgICAvLyAoY2hlY2sgZG9tSGFuZGxlcnMudG91Y2hlbmQgZm9yIGRldGFpbGVkIGV4cGxhbmF0aW9uKVxuICAgICAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlb3V0LmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSB7XG4gICAgdmFyIHBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgcmV0dXJuIHBvaW50ZXJUeXBlID09PSAncGVuJyB8fCBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbn1cblxuLy8gZnVuY3Rpb24gdXNlTVNHdWVzdHVyZShoYW5kbGVyUHJveHksIGV2ZW50KSB7XG4vLyAgICAgcmV0dXJuIGlzUG9pbnRlckZyb21Ub3VjaChldmVudCkgJiYgISFoYW5kbGVyUHJveHkuX21zR2VzdHVyZTtcbi8vIH1cblxuLy8gQ29tbW9uIGhhbmRsZXJzXG56clV0aWwuZWFjaChbJ2NsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNld2hlZWwnLCAnZGJsY2xpY2snLCAnY29udGV4dG1lbnUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBkb21IYW5kbGVyc1tuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcihuYW1lLCBldmVudCk7XG4gICAgfTtcbn0pO1xuXG4vKipcbiAqIOS4uuaOp+WItuexu+WunuS+i+WIneWni+WMlmRvbSDkuovku7blpITnkIblh73mlbBcbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvSGFuZGxlcn0gaW5zdGFuY2Ug5o6n5Yi257G75a6e5L6LXG4gKi9cbmZ1bmN0aW9uIGluaXREb21IYW5kbGVyKGluc3RhbmNlKSB7XG4gICAgenJVdGlsLmVhY2godG91Y2hIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gICAgfSk7XG5cbiAgICB6clV0aWwuZWFjaChwb2ludGVySGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICAgIH0pO1xuXG4gICAgenJVdGlsLmVhY2gobW91c2VIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IG1ha2VNb3VzZUhhbmRsZXIoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1ha2VNb3VzZUhhbmRsZXIoZm4sIGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuX3RvdWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBIYW5kbGVyRG9tUHJveHkoZG9tKSB7XG4gICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl90b3VjaGluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3RvdWNoVGltZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0dlc3R1cmVNZ3J9XG4gICAgICovXG4gICAgdGhpcy5fZ2VzdHVyZU1nciA9IG5ldyBHZXN0dXJlTWdyKCk7XG5cbiAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuXG4gICAgaW5pdERvbUhhbmRsZXIodGhpcyk7XG5cbiAgICBpZiAoZW52LnBvaW50ZXJFdmVudHNTdXBwb3J0ZWQpIHsgLy8gT25seSBJRTExKy9FZGdlXG4gICAgICAgIC8vIDEuIE9uIGRldmljZXMgdGhhdCBib3RoIGVuYWJsZSB0b3VjaCBhbmQgbW91c2UgKGUuZy4sIE1TIFN1cmZhY2UgYW5kIGxlbm92byBYMjQwKSxcbiAgICAgICAgLy8gSUUxMSsvRWRnZSBkbyBub3QgdHJpZ2dlciB0b3VjaCBldmVudCwgYnV0IHRyaWdnZXIgcG9pbnRlciBldmVudCBhbmQgbW91c2UgZXZlbnRcbiAgICAgICAgLy8gYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgLy8gMi4gT24gTVMgU3VyZmFjZSwgaXQgcHJvYmFibGVseSBvbmx5IHRyaWdnZXIgbW91c2Vkb3duIGJ1dCBubyBtb3VzZXVwIHdoZW4gdGFwIG9uXG4gICAgICAgIC8vIHNjcmVlbiwgd2hpY2ggZG8gbm90IG9jY3VycyBpbiBwb2ludGVyIGV2ZW50LlxuICAgICAgICAvLyBTbyB3ZSB1c2UgcG9pbnRlciBldmVudCB0byBib3RoIGRldGVjdCB0b3VjaCBnZXN0dXJlIGFuZCBtb3VzZSBiZWhhdmlvci5cbiAgICAgICAgbW91bnRIYW5kbGVycyhwb2ludGVySGFuZGxlck5hbWVzLCB0aGlzKTtcblxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBOb3RlOiBNUyBHZXN0dXJlIHJlcXVpcmUgQ1NTIHRvdWNoLWFjdGlvbiBzZXQuIEJ1dCB0b3VjaC1hY3Rpb24gaXMgbm90IHJlbGlhYmxlLFxuICAgICAgICAvLyB3aGljaCBkb2VzIG5vdCBwcmV2ZW50IGRlZnVhdWx0IGJlaGF2aW9yIG9jY2FzaW9uYWxseSAod2hpY2ggbWF5IGNhdXNlIHZpZXcgcG9ydFxuICAgICAgICAvLyB6b29tZWQgaW4gYnV0IHVzZSBjYW4gbm90IHpvb20gaXQgYmFjaykuIEFuZCBldmVudC5wcmV2ZW50RGVmYXVsdCgpIGRvZXMgbm90IHdvcmsuXG4gICAgICAgIC8vIFNvIHdlIGhhdmUgdG8gbm90IHRvIHVzZSBNU0dlc3R1cmUgYW5kIG5vdCB0byBzdXBwb3J0IHRvdWNobW92ZSBhbmQgcGluY2ggb24gTVNcbiAgICAgICAgLy8gdG91Y2ggc2NyZWVuLiBBbmQgd2Ugb25seSBzdXBwb3J0IGNsaWNrIGJlaGF2aW9yIG9uIE1TIHRvdWNoIHNjcmVlbiBub3cuXG5cbiAgICAgICAgLy8gTVMgR2VzdHVyZSBFdmVudCBpcyBvbmx5IHN1cHBvcnRlZCBvbiBJRTExKy9FZGdlIGFuZCBvbiBXaW5kb3dzIDgrLlxuICAgICAgICAvLyBXZSBkb250IHN1cHBvcnQgdG91Y2ggb24gSUUgb24gd2luNy5cbiAgICAgICAgLy8gU2VlIDxodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RuNDMzMjQzKHY9dnMuODUpLmFzcHg+XG4gICAgICAgIC8vIGlmICh0eXBlb2YgTVNHZXN0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICAgICAodGhpcy5fbXNHZXN0dXJlID0gbmV3IE1TR2VzdHVyZSgpKS50YXJnZXQgPSBkb207IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAvLyAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ01TR2VzdHVyZUNoYW5nZScsIG9uTVNHZXN0dXJlQ2hhbmdlKTtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGVudi50b3VjaEV2ZW50c1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgbW91bnRIYW5kbGVycyh0b3VjaEhhbmRsZXJOYW1lcywgdGhpcyk7XG4gICAgICAgICAgICAvLyBIYW5kbGVyIG9mICdtb3VzZW91dCcgZXZlbnQgaXMgbmVlZGVkIGluIHRvdWNoIG1vZGUsIHdoaWNoIHdpbGwgYmUgbW91bnRlZCBiZWxvdy5cbiAgICAgICAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdXNlb3V0JywgdGhpcy5fbW91c2VvdXRIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDEuIENvbnNpZGVyaW5nIHNvbWUgZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSBldmVudCAobGlrZSBvbiBNUyBTdXJmYWNlXG4gICAgICAgIC8vIGFuZCBsZW5vdm8gWDI0MCwgQHNlZSAjMjM1MCksIHdlIG1ha2UgbW91c2UgZXZlbnQgYmUgYWx3YXlzIGxpc3RlbmVkLCBvdGhlcndpc2VcbiAgICAgICAgLy8gbW91c2UgZXZlbnQgY2FuIG5vdCBiZSBoYW5kbGUgaW4gdGhvc2UgZGV2aWNlcy5cbiAgICAgICAgLy8gMi4gT24gTVMgU3VyZmFjZSwgQ2hyb21lIHdpbGwgdHJpZ2dlciBib3RoIHRvdWNoIGV2ZW50IGFuZCBtb3VzZSBldmVudC4gSG93IHRvIHByZXZlbnRcbiAgICAgICAgLy8gbW91c2VldmVudCBhZnRlciB0b3VjaCBldmVudCB0cmlnZ2VyZWQsIHNlZSBgc2V0VG91Y2hUaW1lcmAuXG4gICAgICAgIG1vdW50SGFuZGxlcnMobW91c2VIYW5kbGVyTmFtZXMsIHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdW50SGFuZGxlcnMoaGFuZGxlck5hbWVzLCBpbnN0YW5jZSkge1xuICAgICAgICB6clV0aWwuZWFjaChoYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGRvbSwgZXZlbnROYW1lRml4KG5hbWUpLCBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9LCBpbnN0YW5jZSk7XG4gICAgfVxufVxuXG52YXIgaGFuZGxlckRvbVByb3h5UHJvdG8gPSBIYW5kbGVyRG9tUHJveHkucHJvdG90eXBlO1xuaGFuZGxlckRvbVByb3h5UHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlck5hbWVzID0gbW91c2VIYW5kbGVyTmFtZXMuY29uY2F0KHRvdWNoSGFuZGxlck5hbWVzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gaGFuZGxlck5hbWVzW2ldO1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZG9tLCBldmVudE5hbWVGaXgobmFtZSksIHRoaXMuX2hhbmRsZXJzW25hbWVdKTtcbiAgICB9XG59O1xuXG5oYW5kbGVyRG9tUHJveHlQcm90by5zZXRDdXJzb3IgPSBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICB0aGlzLmRvbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZSB8fCAnZGVmYXVsdCc7XG59O1xuXG56clV0aWwubWl4aW4oSGFuZGxlckRvbVByb3h5LCBFdmVudGZ1bCk7XG5cbmV4cG9ydCBkZWZhdWx0IEhhbmRsZXJEb21Qcm94eTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvZG9tL0hhbmRsZXJQcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IERpc3BsYXlhYmxlIGZyb20gJy4vRGlzcGxheWFibGUnO1xuaW1wb3J0IEJvdW5kaW5nUmVjdCBmcm9tICcuLi9jb3JlL0JvdW5kaW5nUmVjdCc7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnLi4vY29yZS91dGlsJztcbmltcG9ydCAqIGFzIGltYWdlSGVscGVyIGZyb20gJy4vaGVscGVyL2ltYWdlJztcblxuLyoqXG4gKiBAYWxpYXMgenJlbmRlci9ncmFwaGljL0ltYWdlXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmZ1bmN0aW9uIFpJbWFnZShvcHRzKSB7XG4gICAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuWkltYWdlLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBaSW1hZ2UsXG5cbiAgICB0eXBlOiAnaW1hZ2UnLFxuXG4gICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICB2YXIgc3JjID0gc3R5bGUuaW1hZ2U7XG5cbiAgICAgICAgLy8gTXVzdCBiaW5kIGVhY2ggdGltZVxuICAgICAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcblxuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSA9IGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2UoXG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICB0aGlzLl9pbWFnZSxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICB0aGlzLm9ubG9hZFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghaW1hZ2UgfHwgIWltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShpbWFnZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWbvueJh+W3sue7j+WKoOi9veWujOaIkFxuICAgICAgICAvLyBpZiAoaW1hZ2Uubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnSU1HJykge1xuICAgICAgICAvLyAgICAgaWYgKCFpbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBFbHNlIGlzIGNhbnZhc1xuXG4gICAgICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgICAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBzdHlsZS5oZWlnaHQ7XG4gICAgICAgIHZhciBhc3BlY3QgPSBpbWFnZS53aWR0aCAvIGltYWdlLmhlaWdodDtcbiAgICAgICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgaW1hZ2UvaGVpZ2h0IHJhdGlvXG4gICAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIGFzcGVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZWlnaHQgPT0gbnVsbCAmJiB3aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3aWR0aCA9PSBudWxsICYmIGhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g6K6+572udHJhbnNmb3JtXG4gICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgaWYgKHN0eWxlLnNXaWR0aCAmJiBzdHlsZS5zSGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgc3ggPSBzdHlsZS5zeCB8fCAwO1xuICAgICAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3kgfHwgMDtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgICAgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsXG4gICAgICAgICAgICAgICAgeCwgeSwgd2lkdGgsIGhlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHlsZS5zeCAmJiBzdHlsZS5zeSkge1xuICAgICAgICAgICAgdmFyIHN4ID0gc3R5bGUuc3g7XG4gICAgICAgICAgICB2YXIgc3kgPSBzdHlsZS5zeTtcbiAgICAgICAgICAgIHZhciBzV2lkdGggPSB3aWR0aCAtIHN4O1xuICAgICAgICAgICAgdmFyIHNIZWlnaHQgPSBoZWlnaHQgLSBzeTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgICAgc3gsIHN5LCBzV2lkdGgsIHNIZWlnaHQsXG4gICAgICAgICAgICAgICAgeCwgeSwgd2lkdGgsIGhlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgLy8gRHJhdyByZWN0IHRleHRcbiAgICAgICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgaWYgKCEgdGhpcy5fcmVjdCkge1xuICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgc3R5bGUueCB8fCAwLCBzdHlsZS55IHx8IDAsIHN0eWxlLndpZHRoIHx8IDAsIHN0eWxlLmhlaWdodCB8fCAwXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICAgIH1cbn07XG5cbnpyVXRpbC5pbmhlcml0cyhaSW1hZ2UsIERpc3BsYXlhYmxlKTtcblxuZXhwb3J0IGRlZmF1bHQgWkltYWdlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9ncmFwaGljL0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZFBhdGgoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICB2YXIgciA9IHNoYXBlLnI7XG4gICAgdmFyIHIxO1xuICAgIHZhciByMjtcbiAgICB2YXIgcjM7XG4gICAgdmFyIHI0O1xuXG4gICAgLy8gQ29udmVydCB3aWR0aCBhbmQgaGVpZ2h0IHRvIHBvc2l0aXZlIGZvciBiZXR0ZXIgYm9yZGVyUmFkaXVzXG4gICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICB4ID0geCArIHdpZHRoO1xuICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByID09PSAnbnVtYmVyJykge1xuICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBpZiAoci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gclswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgcjEgPSByMyA9IHJbMF07XG4gICAgICAgICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgcjEgPSByWzBdO1xuICAgICAgICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICAgICAgICByMyA9IHJbMl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByMSA9IHJbMF07XG4gICAgICAgICAgICByMiA9IHJbMV07XG4gICAgICAgICAgICByMyA9IHJbMl07XG4gICAgICAgICAgICByNCA9IHJbM107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgdG90YWw7XG4gICAgaWYgKHIxICsgcjIgPiB3aWR0aCkge1xuICAgICAgICB0b3RhbCA9IHIxICsgcjI7XG4gICAgICAgIHIxICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgIHIyICo9IHdpZHRoIC8gdG90YWw7XG4gICAgfVxuICAgIGlmIChyMyArIHI0ID4gd2lkdGgpIHtcbiAgICAgICAgdG90YWwgPSByMyArIHI0O1xuICAgICAgICByMyAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICByNCAqPSB3aWR0aCAvIHRvdGFsO1xuICAgIH1cbiAgICBpZiAocjIgKyByMyA+IGhlaWdodCkge1xuICAgICAgICB0b3RhbCA9IHIyICsgcjM7XG4gICAgICAgIHIyICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICByMyAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICB9XG4gICAgaWYgKHIxICsgcjQgPiBoZWlnaHQpIHtcbiAgICAgICAgdG90YWwgPSByMSArIHI0O1xuICAgICAgICByMSAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgcjQgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgfVxuICAgIGN0eC5tb3ZlVG8oeCArIHIxLCB5KTtcbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHIyLCB5KTtcbiAgICByMiAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByMlxuICAgICk7XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByMyk7XG4gICAgcjMgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcjMsIHkgKyBoZWlnaHRcbiAgICApO1xuICAgIGN0eC5saW5lVG8oeCArIHI0LCB5ICsgaGVpZ2h0KTtcbiAgICByNCAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHI0XG4gICAgKTtcbiAgICBjdHgubGluZVRvKHgsIHkgKyByMSk7XG4gICAgcjEgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHIxLCB5KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL3NyYy9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogTWl4aW4gZm9yIGRyYXdpbmcgdGV4dCBpbiBhIGVsZW1lbnQgYm91bmRpbmcgcmVjdFxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1JlY3RUZXh0XG4gKi9cblxuaW1wb3J0ICogYXMgdGV4dEhlbHBlciBmcm9tICcuLi9oZWxwZXIvdGV4dCc7XG5pbXBvcnQgQm91bmRpbmdSZWN0IGZyb20gJy4uLy4uL2NvcmUvQm91bmRpbmdSZWN0JztcblxudmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KCk7XG5cbnZhciBSZWN0VGV4dCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5SZWN0VGV4dC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogUmVjdFRleHQsXG5cbiAgICAvKipcbiAgICAgKiBEcmF3IHRleHQgaW4gYSByZWN0IHdpdGggc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSByZWN0IERpc3BsYXlhYmxlIHJlY3RcbiAgICAgKi9cbiAgICBkcmF3UmVjdFRleHQ6IGZ1bmN0aW9uIChjdHgsIHJlY3QpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcblxuICAgICAgICByZWN0ID0gc3R5bGUudGV4dFJlY3QgfHwgcmVjdDtcblxuICAgICAgICAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG4gICAgICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuXG4gICAgICAgIC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICAgICAgaWYgKCF0ZXh0SGVscGVyLm5lZWREcmF3VGV4dCh0ZXh0LCBzdHlsZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICghc3R5bGUudHJhbnNmb3JtVGV4dCkge1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIHRtcFJlY3QuY29weShyZWN0KTtcbiAgICAgICAgICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJhbnNmb3JtVGV4dCBhbmQgdGV4dFJvdGF0aW9uIGNhbiBub3QgYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICB0ZXh0SGVscGVyLnJlbmRlclRleHQodGhpcywgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCk7XG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBSZWN0VGV4dDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDlnIblvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9DaXJjbGVcbiAqL1xuXG5pbXBvcnQgUGF0aCBmcm9tICcuLi9QYXRoJztcblxuZXhwb3J0IGRlZmF1bHQgUGF0aC5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2NpcmNsZScsXG5cbiAgICBzaGFwZToge1xuICAgICAgICBjeDogMCxcbiAgICAgICAgY3k6IDAsXG4gICAgICAgIHI6IDBcbiAgICB9LFxuXG5cbiAgICBidWlsZFBhdGggOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgaW5CdW5kbGUpIHtcbiAgICAgICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgICAgIC8vIEFsd2F5cyBkbyBpdCBtYXkgaGF2ZSBwZXJmb3JtZW5jZSBpc3N1ZSAoIGZpbGwgbWF5IGJlIDJ4IG1vcmUgY29zdClcbiAgICAgICAgaWYgKGluQnVuZGxlKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2Uge1xuICAgICAgICAvLyAgICAgaWYgKGN0eC5hbGxvY2F0ZSAmJiAhY3R4LmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vICAgICAgICAgY3R4LmFsbG9jYXRlKGN0eC5DTURfTUVNX1NJWkUuQSk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgICAgIC8vIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XG4gICAgICAgIGN0eC5hcmMoc2hhcGUuY3gsIHNoYXBlLmN5LCBzaGFwZS5yLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOebtOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvTGluZVxuICovXG5cbmltcG9ydCBQYXRoIGZyb20gJy4uL1BhdGgnO1xuXG5leHBvcnQgZGVmYXVsdCBQYXRoLmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnbGluZScsXG5cbiAgICBzaGFwZToge1xuICAgICAgICAvLyBTdGFydCBwb2ludFxuICAgICAgICB4MTogMCxcbiAgICAgICAgeTE6IDAsXG4gICAgICAgIC8vIEVuZCBwb2ludFxuICAgICAgICB4MjogMCxcbiAgICAgICAgeTI6IDAsXG5cbiAgICAgICAgcGVyY2VudDogMVxuICAgIH0sXG5cbiAgICBzdHlsZToge1xuICAgICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgICAgZmlsbDogbnVsbFxuICAgIH0sXG5cbiAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgICAgICB2YXIgeTEgPSBzaGFwZS55MTtcbiAgICAgICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgICAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG5cbiAgICAgICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgIHgyID0geDEgKiAoMSAtIHBlcmNlbnQpICsgeDIgKiBwZXJjZW50O1xuICAgICAgICAgICAgeTIgPSB5MSAqICgxIC0gcGVyY2VudCkgKyB5MiAqIHBlcmNlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHBvaW50QXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBzaGFwZS54MSAqICgxIC0gcCkgKyBzaGFwZS54MiAqIHAsXG4gICAgICAgICAgICBzaGFwZS55MSAqICgxIC0gcCkgKyBzaGFwZS55MiAqIHBcbiAgICAgICAgXTtcbiAgICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgQW5pbWF0b3IgZnJvbSAnLi4vYW5pbWF0aW9uL0FuaW1hdG9yJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vY29yZS9sb2cnO1xuaW1wb3J0IHtcbiAgICBpc1N0cmluZyxcbiAgICBpc0Z1bmN0aW9uLFxuICAgIGlzT2JqZWN0LFxuICAgIGlzQXJyYXlMaWtlLFxuICAgIGluZGV4T2Zcbn0gZnJvbSAnLi4vY29yZS91dGlsJztcblxuLyoqXG4gKiBAYWxpYXMgbW9kdWU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEFuaW1hdGFibGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcj59XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRvcnMgPSBbXTtcbn07XG5cbkFuaW1hdGFibGUucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IEFuaW1hdGFibGUsXG5cbiAgICAvKipcbiAgICAgKiDliqjnlLtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGZldGNoIHZhbHVlIGZyb20gb2JqZWN0LCBsaWtlICdhLmIuYycuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbbG9vcF0gV2hldGhlciB0byBsb29wIGFuaW1hdGlvbi5cbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICogQGV4YW1wbGU6XG4gICAgICogICAgIGVsLmFuaW1hdGUoJ3N0eWxlJywgZmFsc2UpXG4gICAgICogICAgICAgICAud2hlbigxMDAwLCB7eDogMTB9IClcbiAgICAgKiAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCl7IC8vIEFuaW1hdGlvbiBkb25lIH0pXG4gICAgICogICAgICAgICAuc3RhcnQoKVxuICAgICAqL1xuICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChwYXRoLCBsb29wKSB7XG4gICAgICAgIHZhciB0YXJnZXQ7XG4gICAgICAgIHZhciBhbmltYXRpbmdTaGFwZSA9IGZhbHNlO1xuICAgICAgICB2YXIgZWwgPSB0aGlzO1xuICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICB2YXIgcGF0aFNwbGl0dGVkID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgdmFyIHByb3AgPSBlbDtcbiAgICAgICAgICAgIC8vIElmIGFuaW1hdGluZyBzaGFwZVxuICAgICAgICAgICAgYW5pbWF0aW5nU2hhcGUgPSBwYXRoU3BsaXR0ZWRbMF0gPT09ICdzaGFwZSc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhTcGxpdHRlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3AgPSBwcm9wW3BhdGhTcGxpdHRlZFtpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICBsb2coXG4gICAgICAgICAgICAgICAgJ1Byb3BlcnR5IFwiJ1xuICAgICAgICAgICAgICAgICsgcGF0aFxuICAgICAgICAgICAgICAgICsgJ1wiIGlzIG5vdCBleGlzdGVkIGluIGVsZW1lbnQgJ1xuICAgICAgICAgICAgICAgICsgZWwuaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW5pbWF0b3JzID0gZWwuYW5pbWF0b3JzO1xuXG4gICAgICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIGxvb3ApO1xuXG4gICAgICAgIGFuaW1hdG9yLmR1cmluZyhmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBlbC5kaXJ0eShhbmltYXRpbmdTaGFwZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIEFuaW1hdG9yIHdpbGwgbm90IGJlIHJlbW92ZWQgaWYgdXNlIGBBbmltYXRvciNzdG9wYCB0byBzdG9wIGFuaW1hdGlvblxuICAgICAgICAgICAgYW5pbWF0b3JzLnNwbGljZShpbmRleE9mKGFuaW1hdG9ycywgYW5pbWF0b3IpLCAxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYW5pbWF0b3JzLnB1c2goYW5pbWF0b3IpO1xuXG4gICAgICAgIC8vIElmIGFuaW1hdGUgYWZ0ZXIgYWRkZWQgdG8gdGhlIHpyZW5kZXJcbiAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFuaW1hdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDlgZzmraLliqjnlLtcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmRUb0xhc3QgSWYgbW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICovXG4gICAgc3RvcEFuaW1hdGlvbjogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICB2YXIgbGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYW5pbWF0b3JzW2ldLnN0b3AoZm9yd2FyZFRvTGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgYW5pbWF0b3JzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhdXRpb246IHRoaXMgbWV0aG9kIHdpbGwgc3RvcCBwcmV2aW91cyBhbmltYXRpb24uXG4gICAgICogU28gZG8gbm90IHVzZSB0aGlzIG1ldGhvZCB0byBvbmUgZWxlbWVudCB0d2ljZSBiZWZvcmVcbiAgICAgKiBhbmltYXRpb24gc3RhcnRzLCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXSBUaW1lIGluIG1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtlYXNpbmc9J2xpbmVhciddXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm9yY2VBbmltYXRlXSBQcmV2ZW50IHN0b3AgYW5pbWF0aW9uIGFuZCBjYWxsYmFja1xuICAgICAqICAgICAgICBpbW1lZGllbnRseSB3aGVuIHRhcmdldCB2YWx1ZXMgYXJlIHRoZSBzYW1lIGFzIGN1cnJlbnQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgICAqICBlbC5hbmltYXRlVG8oe1xuICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICogIH0sIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgICAqXG4gICAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtcywgd2l0aCBjdWJpY091dCBlYXNpbmdcbiAgICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICAgKiAgICAgIHNoYXBlOiB7XG4gICAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgICAqICAgICAgfSxcbiAgICAgKiAgICAgIHN0eWxlOiB7XG4gICAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICAgKiAgICAgIH1cbiAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAqICB9LCAxMDAsIDEwMCwgJ2N1YmljT3V0JywgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAgICovXG4gICAgICAgIC8vIFRPRE8gUmV0dXJuIGFuaW1hdGlvbiBrZXlcbiAgICBhbmltYXRlVG86IGZ1bmN0aW9uICh0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrLCBmb3JjZUFuaW1hdGUpIHtcbiAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICAgIGlmIChpc1N0cmluZyhkZWxheSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgICAgICAgZWFzaW5nID0gZGVsYXk7XG4gICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZGVsYXksIGNhbGxiYWNrKTtcbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihlYXNpbmcpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9ICdsaW5lYXInO1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihkZWxheSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZGVsYXk7XG4gICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgY2FsbGJhY2spXG4gICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odGltZSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGltZTtcbiAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldClcbiAgICAgICAgZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcCBhbGwgcHJldmlvdXMgYW5pbWF0aW9uc1xuICAgICAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdygnJywgdGhpcywgdGFyZ2V0LCB0aW1lLCBkZWxheSk7XG5cbiAgICAgICAgLy8gQW5pbWF0b3JzIG1heSBiZSByZW1vdmVkIGltbWVkaWF0ZWx5IGFmdGVyIHN0YXJ0XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnMuc2xpY2UoKTtcbiAgICAgICAgdmFyIGNvdW50ID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIGFuaW1hdG9ycy4gVGhpcyBzaG91bGQgYmUgY2hlY2tlZCBiZWZvcmUgYW5pbWF0b3JzW2ldLnN0YXJ0KCksXG4gICAgICAgIC8vIGJlY2F1c2UgJ2RvbmUnIG1heSBiZSBleGVjdXRlZCBpbW1lZGlhdGVseSBpZiBubyBuZWVkIHRvIGFuaW1hdGUuXG4gICAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgYWZ0ZXIgYWxsIGFuaW1hdG9ycyBjcmVhdGVkXG4gICAgICAgIC8vIEluY2FzZSBhbnkgYW5pbWF0b3IgaXMgZG9uZSBpbW1lZGlhdGVseSB3aGVuIGFsbCBhbmltYXRpb24gcHJvcGVydGllcyBhcmUgbm90IGNoYW5nZWRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFuaW1hdG9yc1tpXVxuICAgICAgICAgICAgICAgIC5kb25lKGRvbmUpXG4gICAgICAgICAgICAgICAgLnN0YXJ0KGVhc2luZywgZm9yY2VBbmltYXRlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoPScnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZT10aGlzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgKiAgfSlcbiAgICAgKlxuICAgICAqICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXNcbiAgICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgICAqICAgICAgc2hhcGU6IHtcbiAgICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAgICogICAgICB9LFxuICAgICAqICAgICAgc3R5bGU6IHtcbiAgICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgICAqICAgICAgfVxuICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICogIH0sIDEwMCwgMTAwKVxuICAgICAqL1xuICAgIF9hbmltYXRlVG9TaGFsbG93OiBmdW5jdGlvbiAocGF0aCwgc291cmNlLCB0YXJnZXQsIHRpbWUsIGRlbGF5KSB7XG4gICAgICAgIHZhciBvYmpTaGFsbG93ID0ge307XG4gICAgICAgIHZhciBwcm9wZXJ0eUNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2VbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh0YXJnZXRbbmFtZV0pICYmICFpc0FycmF5TGlrZSh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3coXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID8gcGF0aCArICcuJyArIG5hbWUgOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlW25hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmpTaGFsbG93W25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0W25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBBdHRyIGRpcmVjdGx5IGlmIG5vdCBoYXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSwgaWYgc29tZSBwcm9wZXJ0eSBub3QgbmVlZGVkIGZvciBlbGVtZW50ID9cbiAgICAgICAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKG5hbWUsIHRhcmdldFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAgLy8gU2hhcGUgb3Igc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3BhdGhdID0ge307XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3BhdGhdW25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHIocHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0eUNvdW50ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlKHBhdGgsIGZhbHNlKVxuICAgICAgICAgICAgICAgIC53aGVuKHRpbWUgPT0gbnVsbCA/IDUwMCA6IHRpbWUsIG9ialNoYWxsb3cpXG4gICAgICAgICAgICAgICAgLmRlbGF5KGRlbGF5IHx8IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0YWJsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvbWl4aW4vQW5pbWF0YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVE9ETyBEcmFnZ2FibGUgZm9yIGdyb3VwXG4vLyBGSVhNRSBEcmFnZ2FibGUgb24gZWxlbWVudCB3aGljaCBoYXMgcGFyZW50IHJvdGF0aW9uIG9yIHNjYWxlXG5mdW5jdGlvbiBEcmFnZ2FibGUoKSB7XG5cbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9kcmFnU3RhcnQsIHRoaXMpO1xuICAgIHRoaXMub24oJ21vdXNlbW92ZScsIHRoaXMuX2RyYWcsIHRoaXMpO1xuICAgIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgICB0aGlzLm9uKCdnbG9iYWxvdXQnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgICAvLyB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG5cbiAgICAvLyB0aGlzLl94ID0gMDtcbiAgICAvLyB0aGlzLl95ID0gMDtcbn1cblxuRHJhZ2dhYmxlLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBEcmFnZ2FibGUsXG5cbiAgICBfZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICYmIGRyYWdnaW5nVGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBkcmFnZ2luZ1RhcmdldDtcbiAgICAgICAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ggPSBlLm9mZnNldFg7XG4gICAgICAgICAgICB0aGlzLl95ID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWdzdGFydCcsIGUuZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9kcmFnOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcbiAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG5cbiAgICAgICAgICAgIHZhciB4ID0gZS5vZmZzZXRYO1xuICAgICAgICAgICAgdmFyIHkgPSBlLm9mZnNldFk7XG5cbiAgICAgICAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgICAgICAgdmFyIGR5ID0geSAtIHRoaXMuX3k7XG4gICAgICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuXG4gICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmlmdChkeCwgZHksIGUpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcmFnZ2luZ1RhcmdldCwgZSksICdkcmFnJywgZS5ldmVudCk7XG5cbiAgICAgICAgICAgIHZhciBkcm9wVGFyZ2V0ID0gdGhpcy5maW5kSG92ZXIoeCwgeSwgZHJhZ2dpbmdUYXJnZXQpLnRhcmdldDtcbiAgICAgICAgICAgIHZhciBsYXN0RHJvcFRhcmdldCA9IHRoaXMuX2Ryb3BUYXJnZXQ7XG4gICAgICAgICAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gZHJvcFRhcmdldDtcblxuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICE9PSBkcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3REcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0obGFzdERyb3BUYXJnZXQsIGUpLCAnZHJhZ2xlYXZlJywgZS5ldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJvcFRhcmdldCwgZSksICdkcmFnZW50ZXInLCBlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2RyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuXG4gICAgICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZ2VuZCcsIGUuZXZlbnQpO1xuXG4gICAgICAgIGlmICh0aGlzLl9kcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKHRoaXMuX2Ryb3BUYXJnZXQsIGUpLCAnZHJvcCcsIGUuZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgICB9XG5cbn07XG5cbmZ1bmN0aW9uIHBhcmFtKHRhcmdldCwgZSkge1xuICAgIHJldHVybiB7dGFyZ2V0OiB0YXJnZXQsIHRvcFRhcmdldDogZSAmJiBlLnRvcFRhcmdldH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdnYWJsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvbWl4aW4vRHJhZ2dhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOaPkOS+m+WPmOaNouaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cbmltcG9ydCAqIGFzIG1hdHJpeCBmcm9tICcuLi9jb3JlL21hdHJpeCc7XG5pbXBvcnQgKiBhcyB2ZWN0b3IgZnJvbSAnLi4vY29yZS92ZWN0b3InO1xuXG52YXIgbUlkZW50aXR5ID0gbWF0cml4LmlkZW50aXR5O1xuXG52YXIgRVBTSUxPTiA9IDVlLTU7XG5cbmZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbn1cblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBUcmFuc2Zvcm1hYmxlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZ2l2ZW4gcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZVxuICAgIGlmICghb3B0cy5wb3NpdGlvbikge1xuICAgICAgICAvKipcbiAgICAgICAgICog5bmz56e7XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQGRlZmF1bHQgWzAsIDBdXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gWzAsIDBdO1xuICAgIH1cbiAgICBpZiAob3B0cy5yb3RhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDml4vovaxcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICB9XG4gICAgaWYgKCFvcHRzLnNjYWxlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnvKnmlL5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAZGVmYXVsdCBbMSwgMV1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NhbGUgPSBbMSwgMV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOaXi+i9rOWSjOe8qeaUvueahOWOn+eCuVxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgdGhpcy5vcmlnaW4gPSB0aGlzLm9yaWdpbiB8fCBudWxsO1xufTtcblxudmFyIHRyYW5zZm9ybWFibGVQcm90byA9IFRyYW5zZm9ybWFibGUucHJvdG90eXBlO1xudHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybSA9IG51bGw7XG5cbi8qKlxuICog5Yik5pat5piv5ZCm6ZyA6KaB5pyJ5Z2Q5qCH5Y+Y5o2iXG4gKiDlpoLmnpzmnInlnZDmoIflj5jmjaIsIOWImeS7jnBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGXku6Xlj4rniLboioLngrnnmoR0cmFuc2Zvcm3orqHnrpflh7roh6rouqvnmoR0cmFuc2Zvcm3nn6npmLVcbiAqL1xudHJhbnNmb3JtYWJsZVByb3RvLm5lZWRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNOb3RBcm91bmRaZXJvKHRoaXMucm90YXRpb24pXG4gICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzBdKVxuICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblsxXSlcbiAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMF0gLSAxKVxuICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVsxXSAtIDEpO1xufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgdmFyIHBhcmVudEhhc1RyYW5zZm9ybSA9IHBhcmVudCAmJiBwYXJlbnQudHJhbnNmb3JtO1xuICAgIHZhciBuZWVkTG9jYWxUcmFuc2Zvcm0gPSB0aGlzLm5lZWRMb2NhbFRyYW5zZm9ybSgpO1xuXG4gICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICBpZiAoIShuZWVkTG9jYWxUcmFuc2Zvcm0gfHwgcGFyZW50SGFzVHJhbnNmb3JtKSkge1xuICAgICAgICBtICYmIG1JZGVudGl0eShtKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG0gPSBtIHx8IG1hdHJpeC5jcmVhdGUoKTtcblxuICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5nZXRMb2NhbFRyYW5zZm9ybShtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1JZGVudGl0eShtKTtcbiAgICB9XG5cbiAgICAvLyDlupTnlKjniLboioLngrnlj5jmjaJcbiAgICBpZiAocGFyZW50SGFzVHJhbnNmb3JtKSB7XG4gICAgICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIG1hdHJpeC5tdWwobSwgcGFyZW50LnRyYW5zZm9ybSwgbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXRyaXguY29weShtLCBwYXJlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyDkv53lrZjov5nkuKrlj5jmjaLnn6npmLVcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG07XG5cbiAgICB0aGlzLmludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtIHx8IG1hdHJpeC5jcmVhdGUoKTtcbiAgICBtYXRyaXguaW52ZXJ0KHRoaXMuaW52VHJhbnNmb3JtLCBtKTtcbn07XG5cbnRyYW5zZm9ybWFibGVQcm90by5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIFRyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0odGhpcywgbSk7XG59O1xuXG4vKipcbiAqIOWwhuiHquW3seeahHRyYW5zZm9ybeW6lOeUqOWIsGNvbnRleHTkuIpcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAqL1xudHJhbnNmb3JtYWJsZVByb3RvLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybShkcHIgKiBtWzBdLCBkcHIgKiBtWzFdLCBkcHIgKiBtWzJdLCBkcHIgKiBtWzNdLCBkcHIgKiBtWzRdLCBkcHIgKiBtWzVdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICAgIH1cbn07XG5cbnRyYW5zZm9ybWFibGVQcm90by5yZXN0b3JlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCk7XG59O1xuXG52YXIgdG1wVHJhbnNmb3JtID0gW107XG5cbi8qKlxuICog5YiG6KejYHRyYW5zZm9ybWDnn6npmLXliLBgcG9zaXRpb25gLCBgcm90YXRpb25gLCBgc2NhbGVgXG4gKi9cbnRyYW5zZm9ybWFibGVQcm90by5kZWNvbXBvc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybSkge1xuICAgICAgICAvLyBHZXQgbG9jYWwgdHJhbnNmb3JtIGFuZCBkZWNvbXBvc2UgdGhlbSB0byBwb3NpdGlvbiwgc2NhbGUsIHJvdGF0aW9uXG4gICAgICAgIG1hdHJpeC5tdWwodG1wVHJhbnNmb3JtLCBwYXJlbnQuaW52VHJhbnNmb3JtLCBtKTtcbiAgICAgICAgbSA9IHRtcFRyYW5zZm9ybTtcbiAgICB9XG4gICAgdmFyIHN4ID0gbVswXSAqIG1bMF0gKyBtWzFdICogbVsxXTtcbiAgICB2YXIgc3kgPSBtWzJdICogbVsyXSArIG1bM10gKiBtWzNdO1xuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICBpZiAoaXNOb3RBcm91bmRaZXJvKHN4IC0gMSkpIHtcbiAgICAgICAgc3ggPSBNYXRoLnNxcnQoc3gpO1xuICAgIH1cbiAgICBpZiAoaXNOb3RBcm91bmRaZXJvKHN5IC0gMSkpIHtcbiAgICAgICAgc3kgPSBNYXRoLnNxcnQoc3kpO1xuICAgIH1cbiAgICBpZiAobVswXSA8IDApIHtcbiAgICAgICAgc3ggPSAtc3g7XG4gICAgfVxuICAgIGlmIChtWzNdIDwgMCkge1xuICAgICAgICBzeSA9IC1zeTtcbiAgICB9XG4gICAgcG9zaXRpb25bMF0gPSBtWzRdO1xuICAgIHBvc2l0aW9uWzFdID0gbVs1XTtcbiAgICBzY2FsZVswXSA9IHN4O1xuICAgIHNjYWxlWzFdID0gc3k7XG4gICAgdGhpcy5yb3RhdGlvbiA9IE1hdGguYXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbn07XG5cbi8qKlxuICogR2V0IGdsb2JhbCBzY2FsZVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cbnRyYW5zZm9ybWFibGVQcm90by5nZXRHbG9iYWxTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gWzEsIDFdO1xuICAgIH1cbiAgICB2YXIgc3ggPSBNYXRoLnNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgdmFyIHN5ID0gTWF0aC5zcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgIGlmIChtWzBdIDwgMCkge1xuICAgICAgICBzeCA9IC1zeDtcbiAgICB9XG4gICAgaWYgKG1bM10gPCAwKSB7XG4gICAgICAgIHN5ID0gLXN5O1xuICAgIH1cbiAgICByZXR1cm4gW3N4LCBzeV07XG59O1xuLyoqXG4gKiDlj5jmjaLlnZDmoIfkvY3nva7liLAgc2hhcGUg55qE5bGA6YOo5Z2Q5qCH56m66Ze0XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG50cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtQ29vcmRUb0xvY2FsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgdjIgPSBbeCwgeV07XG4gICAgdmFyIGludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtO1xuICAgIGlmIChpbnZUcmFuc2Zvcm0pIHtcbiAgICAgICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgaW52VHJhbnNmb3JtKTtcbiAgICB9XG4gICAgcmV0dXJuIHYyO1xufTtcblxuLyoqXG4gKiDlj5jmjaLlsYDpg6jlnZDmoIfkvY3nva7liLDlhajlsYDlnZDmoIfnqbrpl7RcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvR2xvYmFsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgdjIgPSBbeCwgeV07XG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgdHJhbnNmb3JtKTtcbiAgICB9XG4gICAgcmV0dXJuIHYyO1xufTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQub3JpZ2luXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0LnJvdGF0aW9uXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQucG9zaXRpb25cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFttXVxuICovXG5UcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKHRhcmdldCwgbSkge1xuICAgIG0gPSBtIHx8IFtdO1xuICAgIG1JZGVudGl0eShtKTtcblxuICAgIHZhciBvcmlnaW4gPSB0YXJnZXQub3JpZ2luO1xuICAgIHZhciBzY2FsZSA9IHRhcmdldC5zY2FsZSB8fCBbMSwgMV07XG4gICAgdmFyIHJvdGF0aW9uID0gdGFyZ2V0LnJvdGF0aW9uIHx8IDA7XG4gICAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0LnBvc2l0aW9uIHx8IFswLCAwXTtcblxuICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgLy8gVHJhbnNsYXRlIHRvIG9yaWdpblxuICAgICAgICBtWzRdIC09IG9yaWdpblswXTtcbiAgICAgICAgbVs1XSAtPSBvcmlnaW5bMV07XG4gICAgfVxuICAgIG1hdHJpeC5zY2FsZShtLCBtLCBzY2FsZSk7XG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICAgIG1hdHJpeC5yb3RhdGUobSwgbSwgcm90YXRpb24pO1xuICAgIH1cbiAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgIC8vIFRyYW5zbGF0ZSBiYWNrIGZyb20gb3JpZ2luXG4gICAgICAgIG1bNF0gKz0gb3JpZ2luWzBdO1xuICAgICAgICBtWzVdICs9IG9yaWdpblsxXTtcbiAgICB9XG5cbiAgICBtWzRdICs9IHBvc2l0aW9uWzBdO1xuICAgIG1bNV0gKz0gcG9zaXRpb25bMV07XG5cbiAgICByZXR1cm4gbTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zZm9ybWFibGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvc3JjL21peGluL1RyYW5zZm9ybWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBMUlUgZnJvbSAnLi4vY29yZS9MUlUnO1xuXG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gICAgJ3RyYW5zcGFyZW50JzogWzAsMCwwLDBdLCAnYWxpY2VibHVlJzogWzI0MCwyNDgsMjU1LDFdLFxuICAgICdhbnRpcXVld2hpdGUnOiBbMjUwLDIzNSwyMTUsMV0sICdhcXVhJzogWzAsMjU1LDI1NSwxXSxcbiAgICAnYXF1YW1hcmluZSc6IFsxMjcsMjU1LDIxMiwxXSwgJ2F6dXJlJzogWzI0MCwyNTUsMjU1LDFdLFxuICAgICdiZWlnZSc6IFsyNDUsMjQ1LDIyMCwxXSwgJ2Jpc3F1ZSc6IFsyNTUsMjI4LDE5NiwxXSxcbiAgICAnYmxhY2snOiBbMCwwLDAsMV0sICdibGFuY2hlZGFsbW9uZCc6IFsyNTUsMjM1LDIwNSwxXSxcbiAgICAnYmx1ZSc6IFswLDAsMjU1LDFdLCAnYmx1ZXZpb2xldCc6IFsxMzgsNDMsMjI2LDFdLFxuICAgICdicm93bic6IFsxNjUsNDIsNDIsMV0sICdidXJseXdvb2QnOiBbMjIyLDE4NCwxMzUsMV0sXG4gICAgJ2NhZGV0Ymx1ZSc6IFs5NSwxNTgsMTYwLDFdLCAnY2hhcnRyZXVzZSc6IFsxMjcsMjU1LDAsMV0sXG4gICAgJ2Nob2NvbGF0ZSc6IFsyMTAsMTA1LDMwLDFdLCAnY29yYWwnOiBbMjU1LDEyNyw4MCwxXSxcbiAgICAnY29ybmZsb3dlcmJsdWUnOiBbMTAwLDE0OSwyMzcsMV0sICdjb3Juc2lsayc6IFsyNTUsMjQ4LDIyMCwxXSxcbiAgICAnY3JpbXNvbic6IFsyMjAsMjAsNjAsMV0sICdjeWFuJzogWzAsMjU1LDI1NSwxXSxcbiAgICAnZGFya2JsdWUnOiBbMCwwLDEzOSwxXSwgJ2RhcmtjeWFuJzogWzAsMTM5LDEzOSwxXSxcbiAgICAnZGFya2dvbGRlbnJvZCc6IFsxODQsMTM0LDExLDFdLCAnZGFya2dyYXknOiBbMTY5LDE2OSwxNjksMV0sXG4gICAgJ2RhcmtncmVlbic6IFswLDEwMCwwLDFdLCAnZGFya2dyZXknOiBbMTY5LDE2OSwxNjksMV0sXG4gICAgJ2RhcmtraGFraSc6IFsxODksMTgzLDEwNywxXSwgJ2RhcmttYWdlbnRhJzogWzEzOSwwLDEzOSwxXSxcbiAgICAnZGFya29saXZlZ3JlZW4nOiBbODUsMTA3LDQ3LDFdLCAnZGFya29yYW5nZSc6IFsyNTUsMTQwLDAsMV0sXG4gICAgJ2RhcmtvcmNoaWQnOiBbMTUzLDUwLDIwNCwxXSwgJ2RhcmtyZWQnOiBbMTM5LDAsMCwxXSxcbiAgICAnZGFya3NhbG1vbic6IFsyMzMsMTUwLDEyMiwxXSwgJ2RhcmtzZWFncmVlbic6IFsxNDMsMTg4LDE0MywxXSxcbiAgICAnZGFya3NsYXRlYmx1ZSc6IFs3Miw2MSwxMzksMV0sICdkYXJrc2xhdGVncmF5JzogWzQ3LDc5LDc5LDFdLFxuICAgICdkYXJrc2xhdGVncmV5JzogWzQ3LDc5LDc5LDFdLCAnZGFya3R1cnF1b2lzZSc6IFswLDIwNiwyMDksMV0sXG4gICAgJ2Rhcmt2aW9sZXQnOiBbMTQ4LDAsMjExLDFdLCAnZGVlcHBpbmsnOiBbMjU1LDIwLDE0NywxXSxcbiAgICAnZGVlcHNreWJsdWUnOiBbMCwxOTEsMjU1LDFdLCAnZGltZ3JheSc6IFsxMDUsMTA1LDEwNSwxXSxcbiAgICAnZGltZ3JleSc6IFsxMDUsMTA1LDEwNSwxXSwgJ2RvZGdlcmJsdWUnOiBbMzAsMTQ0LDI1NSwxXSxcbiAgICAnZmlyZWJyaWNrJzogWzE3OCwzNCwzNCwxXSwgJ2Zsb3JhbHdoaXRlJzogWzI1NSwyNTAsMjQwLDFdLFxuICAgICdmb3Jlc3RncmVlbic6IFszNCwxMzksMzQsMV0sICdmdWNoc2lhJzogWzI1NSwwLDI1NSwxXSxcbiAgICAnZ2FpbnNib3JvJzogWzIyMCwyMjAsMjIwLDFdLCAnZ2hvc3R3aGl0ZSc6IFsyNDgsMjQ4LDI1NSwxXSxcbiAgICAnZ29sZCc6IFsyNTUsMjE1LDAsMV0sICdnb2xkZW5yb2QnOiBbMjE4LDE2NSwzMiwxXSxcbiAgICAnZ3JheSc6IFsxMjgsMTI4LDEyOCwxXSwgJ2dyZWVuJzogWzAsMTI4LDAsMV0sXG4gICAgJ2dyZWVueWVsbG93JzogWzE3MywyNTUsNDcsMV0sICdncmV5JzogWzEyOCwxMjgsMTI4LDFdLFxuICAgICdob25leWRldyc6IFsyNDAsMjU1LDI0MCwxXSwgJ2hvdHBpbmsnOiBbMjU1LDEwNSwxODAsMV0sXG4gICAgJ2luZGlhbnJlZCc6IFsyMDUsOTIsOTIsMV0sICdpbmRpZ28nOiBbNzUsMCwxMzAsMV0sXG4gICAgJ2l2b3J5JzogWzI1NSwyNTUsMjQwLDFdLCAna2hha2knOiBbMjQwLDIzMCwxNDAsMV0sXG4gICAgJ2xhdmVuZGVyJzogWzIzMCwyMzAsMjUwLDFdLCAnbGF2ZW5kZXJibHVzaCc6IFsyNTUsMjQwLDI0NSwxXSxcbiAgICAnbGF3bmdyZWVuJzogWzEyNCwyNTIsMCwxXSwgJ2xlbW9uY2hpZmZvbic6IFsyNTUsMjUwLDIwNSwxXSxcbiAgICAnbGlnaHRibHVlJzogWzE3MywyMTYsMjMwLDFdLCAnbGlnaHRjb3JhbCc6IFsyNDAsMTI4LDEyOCwxXSxcbiAgICAnbGlnaHRjeWFuJzogWzIyNCwyNTUsMjU1LDFdLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiBbMjUwLDI1MCwyMTAsMV0sXG4gICAgJ2xpZ2h0Z3JheSc6IFsyMTEsMjExLDIxMSwxXSwgJ2xpZ2h0Z3JlZW4nOiBbMTQ0LDIzOCwxNDQsMV0sXG4gICAgJ2xpZ2h0Z3JleSc6IFsyMTEsMjExLDIxMSwxXSwgJ2xpZ2h0cGluayc6IFsyNTUsMTgyLDE5MywxXSxcbiAgICAnbGlnaHRzYWxtb24nOiBbMjU1LDE2MCwxMjIsMV0sICdsaWdodHNlYWdyZWVuJzogWzMyLDE3OCwxNzAsMV0sXG4gICAgJ2xpZ2h0c2t5Ymx1ZSc6IFsxMzUsMjA2LDI1MCwxXSwgJ2xpZ2h0c2xhdGVncmF5JzogWzExOSwxMzYsMTUzLDFdLFxuICAgICdsaWdodHNsYXRlZ3JleSc6IFsxMTksMTM2LDE1MywxXSwgJ2xpZ2h0c3RlZWxibHVlJzogWzE3NiwxOTYsMjIyLDFdLFxuICAgICdsaWdodHllbGxvdyc6IFsyNTUsMjU1LDIyNCwxXSwgJ2xpbWUnOiBbMCwyNTUsMCwxXSxcbiAgICAnbGltZWdyZWVuJzogWzUwLDIwNSw1MCwxXSwgJ2xpbmVuJzogWzI1MCwyNDAsMjMwLDFdLFxuICAgICdtYWdlbnRhJzogWzI1NSwwLDI1NSwxXSwgJ21hcm9vbic6IFsxMjgsMCwwLDFdLFxuICAgICdtZWRpdW1hcXVhbWFyaW5lJzogWzEwMiwyMDUsMTcwLDFdLCAnbWVkaXVtYmx1ZSc6IFswLDAsMjA1LDFdLFxuICAgICdtZWRpdW1vcmNoaWQnOiBbMTg2LDg1LDIxMSwxXSwgJ21lZGl1bXB1cnBsZSc6IFsxNDcsMTEyLDIxOSwxXSxcbiAgICAnbWVkaXVtc2VhZ3JlZW4nOiBbNjAsMTc5LDExMywxXSwgJ21lZGl1bXNsYXRlYmx1ZSc6IFsxMjMsMTA0LDIzOCwxXSxcbiAgICAnbWVkaXVtc3ByaW5nZ3JlZW4nOiBbMCwyNTAsMTU0LDFdLCAnbWVkaXVtdHVycXVvaXNlJzogWzcyLDIwOSwyMDQsMV0sXG4gICAgJ21lZGl1bXZpb2xldHJlZCc6IFsxOTksMjEsMTMzLDFdLCAnbWlkbmlnaHRibHVlJzogWzI1LDI1LDExMiwxXSxcbiAgICAnbWludGNyZWFtJzogWzI0NSwyNTUsMjUwLDFdLCAnbWlzdHlyb3NlJzogWzI1NSwyMjgsMjI1LDFdLFxuICAgICdtb2NjYXNpbic6IFsyNTUsMjI4LDE4MSwxXSwgJ25hdmFqb3doaXRlJzogWzI1NSwyMjIsMTczLDFdLFxuICAgICduYXZ5JzogWzAsMCwxMjgsMV0sICdvbGRsYWNlJzogWzI1MywyNDUsMjMwLDFdLFxuICAgICdvbGl2ZSc6IFsxMjgsMTI4LDAsMV0sICdvbGl2ZWRyYWInOiBbMTA3LDE0MiwzNSwxXSxcbiAgICAnb3JhbmdlJzogWzI1NSwxNjUsMCwxXSwgJ29yYW5nZXJlZCc6IFsyNTUsNjksMCwxXSxcbiAgICAnb3JjaGlkJzogWzIxOCwxMTIsMjE0LDFdLCAncGFsZWdvbGRlbnJvZCc6IFsyMzgsMjMyLDE3MCwxXSxcbiAgICAncGFsZWdyZWVuJzogWzE1MiwyNTEsMTUyLDFdLCAncGFsZXR1cnF1b2lzZSc6IFsxNzUsMjM4LDIzOCwxXSxcbiAgICAncGFsZXZpb2xldHJlZCc6IFsyMTksMTEyLDE0NywxXSwgJ3BhcGF5YXdoaXAnOiBbMjU1LDIzOSwyMTMsMV0sXG4gICAgJ3BlYWNocHVmZic6IFsyNTUsMjE4LDE4NSwxXSwgJ3BlcnUnOiBbMjA1LDEzMyw2MywxXSxcbiAgICAncGluayc6IFsyNTUsMTkyLDIwMywxXSwgJ3BsdW0nOiBbMjIxLDE2MCwyMjEsMV0sXG4gICAgJ3Bvd2RlcmJsdWUnOiBbMTc2LDIyNCwyMzAsMV0sICdwdXJwbGUnOiBbMTI4LDAsMTI4LDFdLFxuICAgICdyZWQnOiBbMjU1LDAsMCwxXSwgJ3Jvc3licm93bic6IFsxODgsMTQzLDE0MywxXSxcbiAgICAncm95YWxibHVlJzogWzY1LDEwNSwyMjUsMV0sICdzYWRkbGVicm93bic6IFsxMzksNjksMTksMV0sXG4gICAgJ3NhbG1vbic6IFsyNTAsMTI4LDExNCwxXSwgJ3NhbmR5YnJvd24nOiBbMjQ0LDE2NCw5NiwxXSxcbiAgICAnc2VhZ3JlZW4nOiBbNDYsMTM5LDg3LDFdLCAnc2Vhc2hlbGwnOiBbMjU1LDI0NSwyMzgsMV0sXG4gICAgJ3NpZW5uYSc6IFsxNjAsODIsNDUsMV0sICdzaWx2ZXInOiBbMTkyLDE5MiwxOTIsMV0sXG4gICAgJ3NreWJsdWUnOiBbMTM1LDIwNiwyMzUsMV0sICdzbGF0ZWJsdWUnOiBbMTA2LDkwLDIwNSwxXSxcbiAgICAnc2xhdGVncmF5JzogWzExMiwxMjgsMTQ0LDFdLCAnc2xhdGVncmV5JzogWzExMiwxMjgsMTQ0LDFdLFxuICAgICdzbm93JzogWzI1NSwyNTAsMjUwLDFdLCAnc3ByaW5nZ3JlZW4nOiBbMCwyNTUsMTI3LDFdLFxuICAgICdzdGVlbGJsdWUnOiBbNzAsMTMwLDE4MCwxXSwgJ3Rhbic6IFsyMTAsMTgwLDE0MCwxXSxcbiAgICAndGVhbCc6IFswLDEyOCwxMjgsMV0sICd0aGlzdGxlJzogWzIxNiwxOTEsMjE2LDFdLFxuICAgICd0b21hdG8nOiBbMjU1LDk5LDcxLDFdLCAndHVycXVvaXNlJzogWzY0LDIyNCwyMDgsMV0sXG4gICAgJ3Zpb2xldCc6IFsyMzgsMTMwLDIzOCwxXSwgJ3doZWF0JzogWzI0NSwyMjIsMTc5LDFdLFxuICAgICd3aGl0ZSc6IFsyNTUsMjU1LDI1NSwxXSwgJ3doaXRlc21va2UnOiBbMjQ1LDI0NSwyNDUsMV0sXG4gICAgJ3llbGxvdyc6IFsyNTUsMjU1LDAsMV0sICd5ZWxsb3dncmVlbic6IFsxNTQsMjA1LDUwLDFdXG59O1xuXG5mdW5jdGlvbiBjbGFtcENzc0J5dGUoaSkgeyAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBDc3NBbmdsZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMzYwLlxuICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gICAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAzNjAgPyAzNjAgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcENzc0Zsb2F0KGYpIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gICAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzSW50KHN0cikgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gICAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gICAgfVxuICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VJbnQoc3RyLCAxMCkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNzc0Zsb2F0KHN0cikgeyAgLy8gZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7XG4gICAgfVxuICAgIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkge1xuICAgIGlmIChoIDwgMCkge1xuICAgICAgICBoICs9IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGggPiAxKSB7XG4gICAgICAgIGggLT0gMTtcbiAgICB9XG5cbiAgICBpZiAoaCAqIDYgPCAxKSB7XG4gICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICAgIH1cbiAgICBpZiAoaCAqIDIgPCAxKSB7XG4gICAgICAgIHJldHVybiBtMjtcbiAgICB9XG4gICAgaWYgKGggKiAzIDwgMikge1xuICAgICAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICAgIH1cbiAgICByZXR1cm4gbTE7XG59XG5cbmZ1bmN0aW9uIGxlcnBOdW1iZXIoYSwgYiwgcCkge1xuICAgIHJldHVybiBhICsgKGIgLSBhKSAqIHA7XG59XG5cbmZ1bmN0aW9uIHNldFJnYmEob3V0LCByLCBnLCBiLCBhKSB7XG4gICAgb3V0WzBdID0gcjsgb3V0WzFdID0gZzsgb3V0WzJdID0gYjsgb3V0WzNdID0gYTtcbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gY29weVJnYmEob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTsgb3V0WzFdID0gYVsxXTsgb3V0WzJdID0gYVsyXTsgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG52YXIgY29sb3JDYWNoZSA9IG5ldyBMUlUoMjApO1xudmFyIGxhc3RSZW1vdmVkQXJyID0gbnVsbDtcblxuZnVuY3Rpb24gcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycikge1xuICAgIC8vIFJldXNlIHJlbW92ZWQgYXJyYXlcbiAgICBpZiAobGFzdFJlbW92ZWRBcnIpIHtcbiAgICAgICAgY29weVJnYmEobGFzdFJlbW92ZWRBcnIsIHJnYmFBcnIpO1xuICAgIH1cbiAgICBsYXN0UmVtb3ZlZEFyciA9IGNvbG9yQ2FjaGUucHV0KGNvbG9yU3RyLCBsYXN0UmVtb3ZlZEFyciB8fCAocmdiYUFyci5zbGljZSgpKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yU3RyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKGNvbG9yU3RyLCByZ2JhQXJyKSB7XG4gICAgaWYgKCFjb2xvclN0cikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJnYmFBcnIgPSByZ2JhQXJyIHx8IFtdO1xuXG4gICAgdmFyIGNhY2hlZCA9IGNvbG9yQ2FjaGUuZ2V0KGNvbG9yU3RyKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHJldHVybiBjb3B5UmdiYShyZ2JhQXJyLCBjYWNoZWQpO1xuICAgIH1cblxuICAgIC8vIGNvbG9yU3RyIG1heSBiZSBub3Qgc3RyaW5nXG4gICAgY29sb3JTdHIgPSBjb2xvclN0ciArICcnO1xuICAgIC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuICAgIHZhciBzdHIgPSBjb2xvclN0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuICAgIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHtcbiAgICAgICAgY29weVJnYmEocmdiYUFyciwga0NTU0NvbG9yVGFibGVbc3RyXSk7XG4gICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICB9XG5cbiAgICAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC5cbiAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSB7XG4gICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLFxuICAgICAgICAgICAgICAgICgoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAgIChpdiAmIDB4ZjApIHwgKChpdiAmIDB4ZjApID4+IDQpLFxuICAgICAgICAgICAgICAgIChpdiAmIDB4ZikgfCAoKGl2ICYgMHhmKSA8PCA0KSxcbiAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSB7XG4gICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLFxuICAgICAgICAgICAgICAgIChpdiAmIDB4ZmYwMDAwKSA+PiAxNixcbiAgICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgICAgaXYgJiAweGZmLFxuICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gICAgaWYgKG9wICE9PSAtMSAmJiBlcCArIDEgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wICsgMSwgZXAgLSAob3AgKyAxKSkuc3BsaXQoJywnKTtcbiAgICAgICAgdmFyIGFscGhhID0gMTsgIC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG4gICAgICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWxwaGEgPSBwYXJzZUNzc0Zsb2F0KHBhcmFtcy5wb3AoKSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFycixcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgYWxwaGFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgICAgICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXNbM10gPSBwYXJzZUNzc0Zsb2F0KHBhcmFtc1szXSk7XG4gICAgICAgICAgICAgICAgaHNsYTJyZ2JhKHBhcmFtcywgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgICAgICBjYXNlICdoc2wnOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHNsYTJyZ2JhKHBhcmFtcywgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgcmV0dXJuO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gKi9cbmZ1bmN0aW9uIGhzbGEycmdiYShoc2xhLCByZ2JhKSB7XG4gICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KGhzbGFbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXG4gICAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXG4gICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgIHZhciBzID0gcGFyc2VDc3NGbG9hdChoc2xhWzFdKTtcbiAgICB2YXIgbCA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsyXSk7XG4gICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcblxuICAgIHJnYmEgPSByZ2JhIHx8IFtdO1xuICAgIHNldFJnYmEocmdiYSxcbiAgICAgICAgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCArIDEgLyAzKSAqIDI1NSksXG4gICAgICAgIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGgpICogMjU1KSxcbiAgICAgICAgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCAtIDEgLyAzKSAqIDI1NSksXG4gICAgICAgIDFcbiAgICApO1xuXG4gICAgaWYgKGhzbGEubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJnYmFbM10gPSBoc2xhWzNdO1xuICAgIH1cblxuICAgIHJldHVybiByZ2JhO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gKi9cbmZ1bmN0aW9uIHJnYmEyaHNsYShyZ2JhKSB7XG4gICAgaWYgKCFyZ2JhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSR0IgZnJvbSAwIHRvIDI1NVxuICAgIHZhciBSID0gcmdiYVswXSAvIDI1NTtcbiAgICB2YXIgRyA9IHJnYmFbMV0gLyAyNTU7XG4gICAgdmFyIEIgPSByZ2JhWzJdIC8gMjU1O1xuXG4gICAgdmFyIHZNaW4gPSBNYXRoLm1pbihSLCBHLCBCKTsgLy8gTWluLiB2YWx1ZSBvZiBSR0JcbiAgICB2YXIgdk1heCA9IE1hdGgubWF4KFIsIEcsIEIpOyAvLyBNYXguIHZhbHVlIG9mIFJHQlxuICAgIHZhciBkZWx0YSA9IHZNYXggLSB2TWluOyAvLyBEZWx0YSBSR0IgdmFsdWVcblxuICAgIHZhciBMID0gKHZNYXggKyB2TWluKSAvIDI7XG4gICAgdmFyIEg7XG4gICAgdmFyIFM7XG4gICAgLy8gSFNMIHJlc3VsdHMgZnJvbSAwIHRvIDFcbiAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgSCA9IDA7XG4gICAgICAgIFMgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKEwgPCAwLjUpIHtcbiAgICAgICAgICAgIFMgPSBkZWx0YSAvICh2TWF4ICsgdk1pbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBTID0gZGVsdGEgLyAoMiAtIHZNYXggLSB2TWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWx0YVIgPSAoKCh2TWF4IC0gUikgLyA2KSArIChkZWx0YSAvIDIpKSAvIGRlbHRhO1xuICAgICAgICB2YXIgZGVsdGFHID0gKCgodk1heCAtIEcpIC8gNikgKyAoZGVsdGEgLyAyKSkgLyBkZWx0YTtcbiAgICAgICAgdmFyIGRlbHRhQiA9ICgoKHZNYXggLSBCKSAvIDYpICsgKGRlbHRhIC8gMikpIC8gZGVsdGE7XG5cbiAgICAgICAgaWYgKFIgPT09IHZNYXgpIHtcbiAgICAgICAgICAgIEggPSBkZWx0YUIgLSBkZWx0YUc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoRyA9PT0gdk1heCkge1xuICAgICAgICAgICAgSCA9ICgxIC8gMykgKyBkZWx0YVIgLSBkZWx0YUI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQiA9PT0gdk1heCkge1xuICAgICAgICAgICAgSCA9ICgyIC8gMykgKyBkZWx0YUcgLSBkZWx0YVI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSCA8IDApIHtcbiAgICAgICAgICAgIEggKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIID4gMSkge1xuICAgICAgICAgICAgSCAtPSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhzbGEgPSBbSCAqIDM2MCwgUywgTF07XG5cbiAgICBpZiAocmdiYVszXSAhPSBudWxsKSB7XG4gICAgICAgIGhzbGEucHVzaChyZ2JhWzNdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHNsYTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpZnQoY29sb3IsIGxldmVsKSB7XG4gICAgdmFyIGNvbG9yQXJyID0gcGFyc2UoY29sb3IpO1xuICAgIGlmIChjb2xvckFycikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbG9yQXJyW2ldID0gY29sb3JBcnJbaV0gKiAoMSAtIGxldmVsKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2xvckFycltpXSA9ICgoMjU1IC0gY29sb3JBcnJbaV0pICogbGV2ZWwgKyBjb2xvckFycltpXSkgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3JBcnIsIGNvbG9yQXJyLmxlbmd0aCA9PT0gNCA/ICdyZ2JhJyA6ICdyZ2InKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgoY29sb3IpIHtcbiAgICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG4gICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICAgIHJldHVybiAoKDEgPDwgMjQpICsgKGNvbG9yQXJyWzBdIDw8IDE2KSArIChjb2xvckFyclsxXSA8PCA4KSArICgrY29sb3JBcnJbMl0pKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgfVxufVxuXG4vKipcbiAqIE1hcCB2YWx1ZSB0byBjb2xvci4gRmFzdGVyIHRoYW4gbGVycCBtZXRob2RzIGJlY2F1c2UgY29sb3IgaXMgcmVwcmVzZW50ZWQgYnkgcmdiYSBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkVmFsdWUgQSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGNvbG9ycyBMaXN0IG9mIHJnYmEgY29sb3IgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIE1hcHBlZCBnYmEgY29sb3IgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSB3aWxsIGJlIG51bGwvdW5kZWZpbmVkIGlmIGlucHV0IGlsbGVnYWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYXN0TGVycChub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgb3V0KSB7XG4gICAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpXG4gICAgICAgIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpXG4gICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvdXQgPSBvdXQgfHwgW107XG5cbiAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICAgIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gICAgdmFyIGxlZnRDb2xvciA9IGNvbG9yc1tsZWZ0SW5kZXhdO1xuICAgIHZhciByaWdodENvbG9yID0gY29sb3JzW3JpZ2h0SW5kZXhdO1xuICAgIHZhciBkdiA9IHZhbHVlIC0gbGVmdEluZGV4O1xuICAgIG91dFswXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKTtcbiAgICBvdXRbMV0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSk7XG4gICAgb3V0WzJdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpO1xuICAgIG91dFszXSA9IGNsYW1wQ3NzRmxvYXQobGVycE51bWJlcihsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSk7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCB2YXIgZmFzdE1hcFRvQ29sb3IgPSBmYXN0TGVycDtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzIENvbG9yIGxpc3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmdWxsT3V0cHV0IERlZmF1bHQgZmFsc2UuXG4gKiBAcmV0dXJuIHsoc3RyaW5nfE9iamVjdCl9IFJlc3VsdCBjb2xvci4gSWYgZnVsbE91dHB1dCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb2xvcjogLi4uLCBsZWZ0SW5kZXg6IC4uLiwgcmlnaHRJbmRleDogLi4uLCB2YWx1ZTogLi4ufSxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBmdWxsT3V0cHV0KSB7XG4gICAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpXG4gICAgICAgIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpXG4gICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICAgIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gICAgdmFyIGxlZnRDb2xvciA9IHBhcnNlKGNvbG9yc1tsZWZ0SW5kZXhdKTtcbiAgICB2YXIgcmlnaHRDb2xvciA9IHBhcnNlKGNvbG9yc1tyaWdodEluZGV4XSk7XG4gICAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG5cbiAgICB2YXIgY29sb3IgPSBzdHJpbmdpZnkoXG4gICAgICAgIFtcbiAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKSxcbiAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKSxcbiAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKSxcbiAgICAgICAgICAgIGNsYW1wQ3NzRmxvYXQobGVycE51bWJlcihsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSlcbiAgICAgICAgXSxcbiAgICAgICAgJ3JnYmEnXG4gICAgKTtcblxuICAgIHJldHVybiBmdWxsT3V0cHV0XG4gICAgICAgID8ge1xuICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgbGVmdEluZGV4OiBsZWZ0SW5kZXgsXG4gICAgICAgICAgICByaWdodEluZGV4OiByaWdodEluZGV4LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgOiBjb2xvcjtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgdmFyIG1hcFRvQ29sb3IgPSBsZXJwO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtudW1iZXI9fSBoIDAgfiAzNjAsIGlnbm9yZSB3aGVuIG51bGwuXG4gKiBAcGFyYW0ge251bWJlcj19IHMgMCB+IDEsIGlnbm9yZSB3aGVuIG51bGwuXG4gKiBAcGFyYW0ge251bWJlcj19IGwgMCB+IDEsIGlnbm9yZSB3aGVuIG51bGwuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb2RpZnlIU0woY29sb3IsIGgsIHMsIGwpIHtcbiAgICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICAgIGlmIChjb2xvcikge1xuICAgICAgICBjb2xvciA9IHJnYmEyaHNsYShjb2xvcik7XG4gICAgICAgIGggIT0gbnVsbCAmJiAoY29sb3JbMF0gPSBjbGFtcENzc0FuZ2xlKGgpKTtcbiAgICAgICAgcyAhPSBudWxsICYmIChjb2xvclsxXSA9IHBhcnNlQ3NzRmxvYXQocykpO1xuICAgICAgICBsICE9IG51bGwgJiYgKGNvbG9yWzJdID0gcGFyc2VDc3NGbG9hdChsKSk7XG5cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShoc2xhMnJnYmEoY29sb3IpLCAncmdiYScpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyPX0gYWxwaGEgMCB+IDFcbiAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vZGlmeUFscGhhKGNvbG9yLCBhbHBoYSkge1xuICAgIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gICAgaWYgKGNvbG9yICYmIGFscGhhICE9IG51bGwpIHtcbiAgICAgICAgY29sb3JbM10gPSBjbGFtcENzc0Zsb2F0KGFscGhhKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvciwgJ3JnYmEnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyQ29sb3IgbGlrZSBbMTIsMzMsNDQsMC40XVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgJ3JnYmEnLCAnaHN2YScsIC4uLlxuICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHQgY29sb3IuIChJZiBpbnB1dCBpbGxlZ2FsLCByZXR1cm4gdW5kZWZpbmVkKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShhcnJDb2xvciwgdHlwZSkge1xuICAgIGlmICghYXJyQ29sb3IgfHwgIWFyckNvbG9yLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb2xvclN0ciA9IGFyckNvbG9yWzBdICsgJywnICsgYXJyQ29sb3JbMV0gKyAnLCcgKyBhcnJDb2xvclsyXTtcbiAgICBpZiAodHlwZSA9PT0gJ3JnYmEnIHx8IHR5cGUgPT09ICdoc3ZhJyB8fCB0eXBlID09PSAnaHNsYScpIHtcbiAgICAgICAgY29sb3JTdHIgKz0gJywnICsgYXJyQ29sb3JbM107XG4gICAgfVxuICAgIHJldHVybiB0eXBlICsgJygnICsgY29sb3JTdHIgKyAnKSc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9zcmMvdG9vbC9jb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==